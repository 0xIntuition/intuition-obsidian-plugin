# Intuition Protocol - Complete Documentation

> This file contains comprehensive documentation for the Intuition protocol, including all guides, API references, and technical documentation.

Intuition is a permissionless protocol that enables users to create attestations (atoms), make connections between concepts (triples), and signal agreement or disagreement through economic mechanisms. It creates a decentralized knowledge graph of validated information.


# 

Source: https://docs.intuition.systems/guides/contribute/contribution-guidelines


# Contribution Guidelines

Thanks for your interest in contributing to 0xIntuition! We're excited to have you join our community of builders working on the trust protocol for the internet.

Please take a moment to review this document before submitting your first pull request. We also strongly recommend that you check for open issues and pull requests to see if someone else is working on something similar.

If you need any help, feel free to reach out to [@0xintuition](https://twitter.com/0xintuition).

## General Guidelines

These guidelines apply across all Intuition repositories. Each repository may have additional specific requirements, so be sure to check the repository-specific sections below.

### Code of Conduct

By participating in this project, you agree to abide by our community standards. We expect all contributors to be respectful, inclusive, and constructive in their interactions.

### Getting Started

1. **Fork the repository** you want to contribute to
2. **Clone your fork** locally
3. **Create a new branch** for your feature or fix: `git checkout -b feature/my-new-feature`
4. **Make your changes** following the repository's coding standards
5. **Test your changes** thoroughly
6. **Commit your changes** with a descriptive message
7. **Push to your fork** and **submit a pull request**

### Commit Message Guidelines

We largely follow conventional commit format across all repositories:
- `feat: Description` - for new features
- `fix: Description` - for bug fixes
- `docs: Description` - for documentation updates
- `refactor: Description` - for code refactoring
- `test: Description` - for adding or updating tests

### Pull Request Process

Our PR process is consistent across repositories:
- Provide a clear description of what your PR does
- Reference any related issues
- Ensure all tests pass
- Be responsive to feedback during code review
- Keep PRs focused and atomic when possible

### Versioning

We follow [Semantic Versioning](https://semver.org/) (SemVer) across all our repositories:
- **MAJOR** version for incompatible API changes
- **MINOR** version for backwards-compatible functionality additions
- **PATCH** version for backwards-compatible bug fixes

## Repository-Specific Guidelines

While we maintain consistent practices across all repositories, each has specific setup requirements and workflows. **Always check the individual repository's README and CONTRIBUTING.md (if present) for detailed, repo-specific instructions.**

### intuition-ts

**Description**: TypeScript monorepo containing our SDK, UI components, API interactions, and core applications.

**What's included**:
- SDK packages for protocol and API interactions
- 1ui component library with Storybook
- Core applications and utilities

**Contributing**: This repository has comprehensive contribution guidelines. Please read the [CONTRIBUTING.md](https://github.com/0xIntuition/intuition-ts/blob/main/CONTRIBUTING.md) file for detailed instructions on:
- Monorepo structure and workspace commands
- Development setup with pnpm and Nx
- Testing requirements and changesets workflow
- Component development guidelines

### intuition-rs

**Description**: Rust workspace containing the backend infrastructure, indexing services, and data processing pipeline.

**What's included**:
- CLI tools and TUI client
- Event consumers (raw, decoded, resolver)
- Indexing services (envio-indexer, substreams-sink)
- Database models and RPC proxy
- Docker and Kubernetes deployment configurations

**Contributing**:
- Install [Rust](https://rustup.rs/) and [cargo-make](https://github.com/sagiegurari/cargo-make)
- Follow the setup instructions in the [README](https://github.com/0xIntuition/intuition-rs/blob/main/README.md)
- Run tests with `cargo nextest run`
- Use `cargo make` commands for common development tasks
- Note: This repository follows Rust-specific conventions for code style and testing

### intuition-mcp-server

**Description**: Model Context Protocol server for interacting with the Intuition knowledge graph, enabling powerful AI integrations.

**What's included**:
- HTTP stream server with MCP protocol support
- Tools for extracting triples and searching entities
- Account and relationship management APIs
- Client SDK and examples

**Contributing**:
- Requires Node.js 14+ and pnpm
- Follow setup instructions in the [README](https://github.com/0xIntuition/intuition-mcp-server/blob/main/README.md)
- Test locally with `pnpm run start:http`
- See the Contributing section in the README for MCP-specific development guidelines

### intuition-contracts-v2

**Description**: Smart contracts for Intuition V2 protocol built with Foundry, handling core protocol logic and token economics.

**What's included**:
- Core protocol smart contracts
- Deployment and migration scripts
- Comprehensive test suite
- Gas optimization and security features

**Contributing**:
- Install [Foundry](https://book.getfoundry.sh/getting-started/installation)
- Install [Bun](https://bun.sh/) for Node.js package management
- Follow setup instructions in the [README](https://github.com/0xIntuition/intuition-contracts-v2/blob/main/README.md)
- Run tests with `forge test`
- Use `forge fmt` for code formatting and `bun run lint` for linting
- Follow Solidity best practices and security guidelines for smart contract development

## Getting Help

- **GitHub Issues**: Use the Issues tab in the relevant repository for bug reports and feature requests
- **Twitter**: Follow [@0xintuition](https://twitter.com/0xintuition) for updates
- **Documentation**: Visit our [docs site](https://docs.intuition.systems) for comprehensive guides

## What to Contribute

We welcome contributions of all kinds:

- **Bug fixes** - Help us identify and resolve issues
- **Feature development** - Build new capabilities for the protocol
- **Documentation** - Improve guides, examples, and API documentation
- **Testing** - Add test coverage and improve quality assurance
- **Examples** - Create tutorials and sample applications
- **Performance** - Optimize existing code and infrastructure

Thank you for contributing to the future of decentralized trust! ðŸš€

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/audit-reports


# Audit Reports

## Overview

This page contains security audit reports for Intuition smart contracts. All contracts undergo rigorous security assessments before deployment.

## Latest Audit

### Security Assessment (Summary Report) - March 28, 2024

**Audit Scope**: The smart contracts audited can be found on the main branch in the repository: `intuition-tob-audit`

## Summary of Findings and Fixes

**No high severity issues found** âœ…

| Issue | Status | Fix |
|-------|--------|-----|
| Protocol deposit fees unaccounted for in createAtom | âœ… Fixed | commit#edc4584 |
| Triple identifiers can contain hash collisions | âœ… Fixed | PR#33 |
| Atom equity should be calculated on raw asset amounts | âœ… Fixed | commit#028748d |
| Distributing atom equity should not include protocol fees | âœ… Fixed | commit#028748d |
| Asset accounting should not be reduced by minShare | âœ… Fixed | PR#36 |

| Issue | Status | Fix |
|-------|--------|-----|
| createAtomCompressed allows creating duplicate atoms with the same URI | âœ… Fixed | commit#4d0b2ba from PR#30 |
| Upgrade could lead to mismatch in atom wallet address prediction | âœ… Fixed | PR#38 |
| createAtom mints sharesForZeroAddress twice | âœ… Fixed | commit#edc4584 |
| EthMultiVault should not receive ether donations | âœ… Fixed | PR#24 |
| Atom wallets can be created before the atom is created | âœ… Fixed | PR#29 |
| Atom URI data is unbounded | âœ… Fixed | PR#32 |

| Issue | Status | Fix |
|-------|--------|-----|
| Salt contains superfluous address(this) | âœ… Fixed | PR#27 |
| Unbound storage reads in getVaultStates | âœ… Fixed | PR#25 |
| EthMultiVault is missing ERC-4626 functionality | ðŸ“ Addressed in comments | - |
| Redundant and ineffective reinitialization check | âœ… Fixed | PR#28 |
| Impossible condition | âœ… Fixed | PR#26 |
| Distributing atom equity should not mint new shares to receiver | âœ… Fixed | PR#39 |
| getVaultStates does not retrieve counter vaults | âœ… Fixed | PR#25 |
| Excessive duplicate code | âœ… Fixed | PR#30 |
| Admin can bypass fee setter limits | âœ… Fixed | PR#34 |
| Minting ghost shares is unnecessary to prevent share inflation attacks | ðŸ—‘ï¸ Removed from report | - |
| Code Quality | âœ… Fixed | PR#40 and PR#41 |
| [Weak Maturity] Decentralization | âœ… Fixed | PR#42 and PR#45 |
| [Weak Maturity] Arithmetic | ðŸ“ Addressed in comments | - |


---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/configuration


# Configurations & Fees

The Intuition protocol smart contracts utilize a configuration system that allows for dynamic adjustment of various parameters effecting the behavior of the protocol. This document outlines the key configuration parameters and fees associated with the **mainnet Intuition protocol** deployment.

The smart contract configurations and parameters can be adjusted by governance through onchain proposals, allowing for flexibility and adaptability as the protocol evolves.

## MultiVault

### Atom & Triple Creation Fees

The following fixed fees are applied when creating atoms and triples within the MultiVault:

### Deposit & Withdrawal Fees & Minimums

When depositing into an atom or triple, a minimum amount of TRUST is required:   

The percentage-based fees are applied to the total TRUST being deposited/withdrawn after accounting for fixed costs:

**The percentage fees are calculated using a denominator of 10,000.**

For example, if a user deposits 100 TRUST into an atom, the entry fee would be calculated as follows:

- ```Entry Fee = (50 / 10,000) * 100 TRUST = 0.5 TRUST```
- ```Protocol Fee = (125 / 10,000) * 100 TRUST = 1.25 TRUST```

The total fees for 100 TRUST deposit would be 0.5 TRUST (entry fee) + 1.25 TRUST (protocol fee) = 1.75 TRUST.

### Low-Level Configuration Parameters

The Intuition Smart Contracts also include several low-level configuration parameters that can be adjusted by governance to fine-tune the protocol's behavior. These parameters include:

- **Fee Denominator:** 10000
- **Atom Data Max Length:** 1000

## TrustBonding & EmissionsController

The TrustBonding, BaseEmissionsController and SatelliteEmissionsController all share the same configuration parameters for emissions. This allows for a consistent emission schedule across the protocol, even though new TRUST tokens are minted on the Base (8453) network and released on the Intuition (1155) network.

## OffsetProgressiveCurve

The Offset Progressive Curve is used to calculate the amount of shares minted when a user deposits. The curve is defined by the following parameters:

- **Offset:** 1e17
- **Slope:** 3e19 

The OffsetProgressiveCurve parameters are fixed and cannot be changed by governance.

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/contract-migration


# Migrating from 2.0 to 2.1 Smart Contracts

## MultiVault

### Last Active Epoch is now User Epoch History

The `lastActiveEpoch` mapping in the `MultiVault` contract has been replaced with a more comprehensive `userEpochHistory` mapping. This new mapping tracks up 3 epochs in which each user has been active.

**Previous:**
```solidity
mapping(address => uint256) public lastActiveEpoch;
```

**Current:**
```solidity
mapping(address => uint256[3]) public userEpochHistory;
```

To get the last active epoch of a user, you can now use the following function:

```solidity
function getUserLastActiveEpoch(address user) external view returns (uint256) {
    return userEpochHistory[user][0];
}
```

### MultiVault Config

The `GeneralConfig` struct has been updated to include a new parameter `feeThreshold` and remove the `decimalPrecision` parameter.

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength;
    uint256 feeThreshold;
}
```

Previously the `GeneralConfig` struct contained the `decimalPrecision` parameter that has been removed in this version.

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength;
    uint256 decimalPrecision;
}
```

The `getGeneralConfig` function now reflects the updated `GeneralConfig` struct:

```solidity
function getGeneralConfig() external view returns (GeneralConfig memory);
```

### Triple Config

The `tripleConfig` struct has been updated to include only two parameters: `tripleCreationProtocolFee` and `atomDepositFractionForTriple`.

```solidity
struct TripleConfig {
    uint256 tripleCreationProtocolFee;
    uint256 atomDepositFractionForTriple;
}
```

Previously the `tripleConfig` struct contained `totalAtomDepositsOnTripleCreation` parameters that have been removed in this version.

```solidity
struct TripleConfig {
    uint256 tripleCreationProtocolFee;
    uint256 totalAtomDepositsOnTripleCreation;
    uint256 atomDepositFractionForTriple;
}
```

The `getTripleConfig` return value now reflects the updated `TripleConfig` struct:

```solidity
getTripleConfig() external view returns (TripleConfig memory);
```

# Bonding Curves

## Offset Progressive Curve

The `OffsetProgressiveCurve.sol` contract no longer auto-scales the `slope` parameter during initialization. The `slope` parameter should now be provided in its scaled form.

**Previous:**
```solidity
SLOPE=2;
```

**Current:**
```solidity
SLOPE=2e18;
```

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/deployments


# Contract Deployments

The Intuition protocol contracts are deployed on both the Base Mainnet and the Intuition Layer 3 network, as well as their respective testnets. Below are the details of the deployed contracts, including their addresses and network configurations.

## Mainnet

### Base Mainnet

| Contract      | Address                                    |
|---------------|--------------------------------------------|
| Trust (ERC20) | 0x6cd905dF2Ed214b22e0d48FF17CD4200C1C6d8A3 |

### Intuition Mainnet (L3)

| Contract Name                 | Address                                    |
|-------------------------------|--------------------------------------------|
| WrappedTrust                  | 0x81cFb09cb44f7184Ad934C09F82000701A4bF672 |
| Upgrades TimelockController   | 0x321e5d4b20158648dFd1f360A79CAFc97190bAd1 |
| Parameters TimelockController | 0x71b0F1ABebC2DaA0b7B5C3f9b72FAa1cd9F35FEA |
| MultiVault                    | 0x6E35cF57A41fA15eA0EaE9C33e751b01A784Fe7e |
| AtomWalletFactory             | 0x33827373a7D1c7C78a01094071C2f6CE74253B9B |
| AtomWalletBeacon              | 0xC23cD55CF924b3FE4b97deAA0EAF222a5082A1FF |
| AtomWarden                    | 0x98C9BCecf318d0D1409Bf81Ea3551b629fAEC165 |
| SatelliteEmissionsController  | 0x73B8819f9b157BE42172E3866fB0Ba0d5fA0A5c6 |
| TrustBonding                  | 0x635bBD1367B66E7B16a21D6E5A63C812fFC00617 |
| BondingCurveRegistry          | 0xd0E488Fb32130232527eedEB72f8cE2BFC0F9930 |
| LinearCurve                   | 0xc3eFD5471dc63d74639725f381f9686e3F264366 |
| OffsetProgressiveCurve        | 0x23afF95153aa88D28B9B97Ba97629E05D5fD335d |
| Multicall3                    | 0xcA11bde05977b3631167028862bE2a173976CA11 |
| EntryPoint                    | 0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108 |
| SafeSingletonFactory          | 0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7 |

## Testnet

### Base Sepolia Testnet

| Contract Name               | Address                                    |
|-----------------------------|--------------------------------------------|
| TestTrust                   | 0xA54b4E6e356b963Ee00d1C947f478d9194a1a210 |
| Upgrades TimelockController | 0x9099BC9fd63B01F94528B60CEEB336C679eb6d52 |
| BaseEmissionsController     | 0xC14773Aae24aA60CB8F261995405C28f6D742DCf |

### Intuition Testnet (L3)

| Contract Name                 | Address                                    |
|-------------------------------|--------------------------------------------|
| WrappedTrust                  | 0xDE80b6EE63f7D809427CA350e30093F436A0fe35 |
| Upgrades TimelockController   | 0x59B7EaB1cFA47F8E61606aDf79a6b7B5bBF1aF26 |
| Parameters TimelockController | 0xcCB113bfFf493d80F32Fb799Dca23686a04302A7 |
| MultiVault                    | 0x2Ece8D4dEdcB9918A398528f3fa4688b1d2CAB91 |
| AtomWalletFactory             | 0xa4e96c6dB8Dd3314c64bF9d0E845A4905a8705d4 |
| AtomWalletBeacon              | 0x4B0aC884843576dBA0B0fda925f202aB8b546E33 |
| AtomWarden                    | 0x040B7760EFDEd7e933CFf419224b57DFB9Eb4488 |
| SatelliteEmissionsController  | 0xD3be4d1E56866b98f30Ae6C326F14EF9c6ffBBDF |
| TrustBonding                  | 0x75dD32b522c89566265eA32ecb50b4Fc4d00ADc7 |
| BondingCurveRegistry          | 0x2AFC4949Dd3664219AA2c20133771658E93892A1 |
| LinearCurve                   | 0x6df5eecd9B14E31C98A027b8634876E4805F71B0 |
| OffsetProgressiveCurve        | 0xE65EcaAF5964aC0d94459A66A59A8B9eBCE42CbB |
| Multicall3                    | 0xcA11bde05977b3631167028862bE2a173976CA11 |
| EntryPoint                    | 0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108 |

## Network Details

### Intuition Mainnet Configuration
- **Chain ID**: 1155
- **RPC URL**: `https://rpc.intuition.systems`
- **WebSocket**: `wss://rpc.intuition.systems`
- **Explorer**: `https://explorer.intuition.systems/`
- **Native Token**: $TRUST

### Intuition Testnet Configuration
- **Chain ID**: 13579
- **RPC URL**: `https://testnet.rpc.intuition.systems`
- **WebSocket**: `wss://testnet.rpc.intuition.systems`
- **Explorer**: `https://testnet.explorer.intuition.systems/`
- **Native Token**: $tTRUST

### Base Sepolia Configuration
- **Chain ID**: 84532
- **RPC URL**: `https://sepolia.base.org`
- **Explorer**: `https://sepolia.basescan.org`
- **Native Token**: ETH

### Base Sepolia Configuration
- **Chain ID**: 8453
- **RPC URL**: `https://mainnet.base.org`
- **Explorer**: `https://basescan.org`
- **Native Token**: ETH

## Verified Contracts

All deployed contracts are verified on their respective block explorers. You can view the source code and interact with the contracts directly through the explorer interfaces.

## Contract ABIs

Contract ABIs can be found in the following locations:
- **npm package**: `@0xintuition/protocol`
- **GitHub**: [0xIntuition/intuition-contracts-v2](https://github.com/0xIntuition/intuition-contracts-v2)
- **Block Explorer**: Available on verified contract pages

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/multivault


# MultiVault.sol

The MultiVault contract is the core economic engine of the Intuition protocol, managing deposits, redemptions, and creation of atoms and triples. It implements a sophisticated vault system that supports multiple bonding curves and provides the foundation for the protocol's economic incentives.

The MultiVault is the primary interface for users to interact with the economic aspects of atoms and triples:

### Atom IDs
Atom IDs are generated using a hash function that hashes the Atom's data.

```solidity
function calculateAtomId(bytes memory data) public pure returns (bytes32 id) {
    return keccak256(abi.encodePacked(data));
}
```

### Triple IDs
Triple IDs are generated using a hash function that hashes the subject, predicate, and object Atom IDs.

```solidity
function calculateTripleId(
    bytes32 subjectId,
    bytes32 predicateId,
    bytes32 objectId
) public pure returns (bytes32 id) {
    return keccak256(abi.encodePacked(subjectId, predicateId, objectId));
}
```

## Smart Contract Writes
The MultiVault contract allows users to create new terms, plus deposit and redeem assets.

### Creating Atoms
An Atom represents an entity within the Intuition ecosystem and is identified by a unique `bytes32` identifier. Atoms can represent objects, individuals, organizations, or any other entity type. Atom data is stored onchain and also emitted for caching/indexing using the `AtomCreated` event.

Any user can create an Atom by calling the `createAtoms` function on the MultiVault contract.

```solidity
function createAtoms(
        bytes[] calldata data,
        uint256[] calldata assets
        external
        payable
        returns (bytes32[] memory)
    {
    // Atom creation logic
}
```
The function accepts an array of Atom data and an array of asset amounts, allowing for the creation of multiple Atoms in a single transaction.

Creating an Atom requires a fee payment, which is paid in the native blockchain currency (e.g., TRUST on the Intuition Network). In addition to the fee, users can also deposit TRUST tokens when creating an Atom. This deposit acts as a signal, ensuring that users have a vested interest in the integrity of the Atom they are creating.

### Creating Triples
A Triple represents a claim or statement. A triple is structured using a **subject-predicate-object** relationship. For example, in the triple "Alice is a friend of Bob", "Alice" is the subject, "is a friend of" is the predicate, and "Bob" is the object.

```solidity
function createTriples(
    bytes32[] calldata subjectIds,
    bytes32[] calldata predicateIds,
    bytes32[] calldata objectIds,
    uint256[] calldata assets
    external
    payable
    whenNotPaused
    nonReentrant
    returns (bytes32[] memory)
{
    // Triple creation logic
}
```

### Deposit
Deposits are made in the native blockchain currency (e.g., TRUST). Users can also batch multiple deposits or redemptions into a single transaction for efficiency.

The `deposit` function allows users to deposit assets into a specific term and bonding curve. The user specifies the receiver address, term ID, curve ID, and minimum shares they expect to receive.

The `msg.value` sent with the transaction represents the amount of assets being deposited.

```solidity
function deposit(
    address receiver,
    bytes32 termId,
    uint256 curveId,
    uint256 minShares
    external
    payable
    whenNotPaused
    nonReentrant
    returns (uint256)
{
    /// Deposit logic
}
```

### Batch Deposit
The `depositBatch` function allows users to make multiple deposits in a single transaction. The user provides arrays of receiver addresses, term IDs, curve IDs, and minimum shares for each deposit.

The `msg.value` sent with the transaction represents the total amount of assets being deposited across all specified deposits. The sum of `assets` must equal `msg.value`.

```solidity
function depositBatch(
    address receiver,
    bytes32[] calldata termIds,
    uint256[] calldata curveIds,
    uint256[] calldata assets,
    uint256[] calldata minShares
    external
    payable
    whenNotPaused
    nonReentrant
    returns (uint256[] memory shares)
{
    /// Batch deposit logic
}
```

### Redeem

The `redeem` function allows users to redeem their shares for the underlying assets. The user specifies the receiver address, term ID, curve ID, and the number of shares they want to redeem.

```solidity
function redeem(
    address receiver,
    bytes32 termId,
    uint256 curveId,
    uint256 shares,
    uint256 minAssets
    external
    whenNotPaused
    nonReentrant
    returns (uint256)
{
    /// Redemption logic
}
```

### Batch Redeem

The `redeemBatch` function allows users to redeem shares from multiple terms and curves in a single transaction. The user provides arrays of term IDs, curve IDs, shares to redeem, and minimum assets they expect to receive for each redemption.

```
function redeemBatch(
    address receiver,
    bytes32[] calldata termIds,
    uint256[] calldata curveIds,
    uint256[] calldata shares,
    uint256[] calldata minAssets
    external
    whenNotPaused
    nonReentrant
    returns (uint256[] memory received)
{
    /// Batch redemption logic
}
```

## Smart Contract Reads

### Is Term Created

The `isTermCreated` function checks if a specific term has been created in the MultiVault.

```solidity
function isTermCreated(bytes32 termId) external view returns (bool) {
    // Term existence logic
}
```

### Current Share Price
The `currentSharePrice` function returns the current share price for a given term and bonding curve.

```solidity
function currentSharePrice(bytes32 termId, uint256 curveId) external view returns (uint256) {
    // Share price calculation logic
}
```

### Preview Atom Create
The `previewAtomCreate` function allows users to preview the cost of creating an Atom with a given set of data.

```solidity
function previewAtomCreate(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
    external
    view
    returns (uint256 shares, uint256 assetsAfterFixedFees, uint256 assetsAfterFees)
{
    // Atom creation cost preview logic
}
```

### Preview Triple Create
The `previewTripleCreate` function allows users to preview the cost of creating a Triple with given subject, predicate, and object IDs.

```solidity
function previewTripleCreate(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
    external
    view
    returns (uint256 shares, uint256 assetsAfterFixedFees, uint256 assetsAfterFees)
{
    // Triple creation cost preview logic
}
```

### Preview Deposit
The `previewDeposit` function allows users to preview the number of shares they would receive for a deposit of a given amount of assets into a specific term and bonding curve.

```solidity
function previewDeposit(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
    public
    view
    returns (uint256 shares, uint256 assetsAfterFees)
{
    // Deposit preview logic
}
```

### Preview Redeem
The `previewRedeem` function allows users to preview the amount of assets they would receive for redeeming a given number of shares from a specific term and bonding curve.

```solidity
function previewRedeem(
    bytes32 termId,
    uint256 curveId,
    uint256 shares
    public
    view
    returns (uint256 assetsAfterFees, uint256 sharesUsed)
{
    // Redemption preview logic
}
```

## Events
The MultiVault contract emits a number of different events to track key actions:

- `AtomCreated`: Emitted when a new Atom is created.
- `TripleCreated`: Emitted when a new Triple is created.
- `Deposited`: Emitted when a deposit is made.
- `Redeemed`: Emitted when shares are redeemed for assets.
- `SharePriceChanged`: Emitted when the share price for a term and curve changes.

### AtomCreated
```solidity
event AtomCreated(
    address indexed creator,
    bytes32 indexed termId,
    bytes data
);
```

### TripleCreated
```solidity
event TripleCreated(
    address indexed creator,
    bytes32 indexed tripleId,
    bytes32 subjectId,
    bytes32 predicateId,
    bytes32 objectId
);
```

### Deposited
```solidity
event Deposited(
    address indexed sender,
    address indexed receiver,
    bytes32 indexed termId,
    uint256 curveId,
    uint256 assets,
    uint256 assetsAfterFees,
    uint256 shares,
    uint256 totalShares,
    VaultType vaultType
);
```

### Redeemed
```solidity
event Redeemed(
    address indexed sender,
    address indexed receiver,
    bytes32 indexed termId,
    uint256 curveId,
    uint256 shares,
    uint256 totalShares,
    uint256 assets,
    uint256 fees,
    VaultType vaultType
);
```

### SharePriceChanged
```solidity
event SharePriceChanged(
    bytes32 indexed termId,
    uint256 indexed curveId,
    uint256 sharePrice,
    uint256 totalAssets,
    uint256 totalShares,
    VaultType vaultType
);
```

## Additional Resources

For more detailed information on the MultiVault contract and its functions, please refer to the [Intuition Smart Contract V2 repository](https://github.com/0xIntuition/intuition-contracts-v2).

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/overview


# Contract Architecture Overview

Intuition's smart contracts are central to the user experience, handling critical onchain activities such as the creation of Atoms (also known as Identities) and Triples (also known as Claims), as well as the staking and rewards.

# MultiVault

The MultiVault contract is the core component of Intuition's architecture, responsible for managing the creation of Atoms/Triples and handling deposits, redemptions, and share distributions. It supports multiple bonding curve implementations through a registry system.

- **Creation**: Users can create Atoms and Triples
- **Deposits**: Users can deposit ETH to receive shares in atoms/triples
- **Redemptions**: Users can redeem shares for ETH
- **Multi-Vault**: Supports multiple bonding curve implementations
- **Share Distribution**: Manages the minting and burning of shares
- **Fee Collection**: Collects small fees to maintain the system

# Trust Token
The Trust Token contract is an ERC-20 compliant token that serves as the native utility token within the Intuition ecosystem. It is used for deposits, staking, governance, and accessing various features of the platform. 

- **ERC-20 Compliance**: Fully compliant with the ERC-20 standard
- **Minting and Burning**: Controlled minting and burning of tokens
- **Transfers**: Standard token transfer functionality

The Trust Token contract is **deployed on Base** and is the **native gas token on the Intuition Network L3 chain**.

# Wrapped Trust
The Wrapped Trust contract is an ERC-20 compliant token that lives on the Intuition Network L3 chain. After users bridge their Trust tokens from Base to the Intuition Network L3 chain, they can receive Wrapped Trust tokens by depositing Trust tokens into the Wrapped Trust contract.

**Wrapped Trust tokens can be used for staking in the Trust Bonding contract.**

# Trust Bonding
The Trust Bonding contract is a smart contract introduced in V2. Inheriting from the Curve VotingEscrow contract, it enables staking of Wrapped Trust to earn rewards and participate in governance. Key features include:

- **Staking**: Users can stake Wrapped Trust to earn rewards
- **Locking**: Users can lock their stake for a specified duration to increase voting power
- **Rewards**: Users earn rewards based on their stake and lock duration
- **Governance**: Stakers can participate in governance decisions

# Bonding Curve Registry
The Bonding Curve Registry contract is a registry for bonding curve implementations. It allows the MultiVault contract to look up and use different bonding curve implementations. Key features include:

- **Registration**: Developers can register new bonding curve implementations
- **Lookup**: The MultiVault contract can look up bonding curve implementations by ID
- **Management**: The registry can be managed by the contract owner

# BaseEmissionsController
The BaseEmissionsController contract is responsible for managing the emissions of Trust tokens. It controls the rate at which new Trust tokens are minted and distributed to stakers in the Trust Bonding contract. Key features include:

- **Emission Rate**: Controls the rate of Trust token emissions
- **Distribution**: Distributes newly minted Trust tokens to the SatelliteEmissionsController
- **Bridging**: Uses the Caldera MetaLayer protocol to bridge emissions to the Intuition Network L3 chain

# SatelliteEmissionsController
The SatelliteEmissionsController contract is responsible for managing the emissions of Trust tokens on the Intuition Network L3 chain. It receives emissions from the BaseEmissionsController and distributes them to stakers via the Trust Bonding contract. Key features include:

- **Receiving Emissions**: Receives Trust token emissions from the BaseEmissionsController
- **Distribution**: Distributes Trust tokens to stakers via the Trust Bonding contract
- **Bridging/Burning**: Uses the Caldera MetaLayer protocol to bridge/burn emissions back to Base

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/contracts/trust-bonding


# TrustBonding.sol

The TrustBonding contract is the primary smart contract for bonding/staking of TRUST tokens within the Intuition protocol. Responsible for managing emissions of new TRUST tokens for various stakeholders, including atom creators, triple creators, and other participants in the ecosystem.

### Wrapped Trust (wTRUST)
The TrustBonding contract requires users to wrap their TRUST tokens into Wrapped TRUST (wTRUST) before locking them in the voting escrow. This wrapping process is handled by the `WrappedTrust` contract, which allows users to deposit TRUST tokens and receive an equivalent amount of wTRUST tokens.

### Voting Escrow (veTRUST)
The TrustBonding contract inherits from the popular Voting Escrow mechanism, allowing users to lock their TRUST tokens for a specified period in exchange for veTRUST tokens. These veTRUST tokens represent voting power and can be used to influence governance decisions within the Intuition protocol.

The voting escrow mechanism is implemented using the `VotingEscrow` contract, which provides functions for creating locks, increasing lock amounts, and extending lock durations.

Originated from Curve Finance's veCRV model, originally written in Vyper, the Voting Escrow contract has been adapted to Solidity for use in the Intuition protocol and forked from the Stargate DAO's [implementation](https://github.com/stargate-protocol/stargate-dao/blob/main/contracts/VotingEscrow.sol).

## Smart Contract Writes

### Creating Locks
Users can create a new lock by calling the `create_lock` function, specifying the amount of Wrapped TRUST tokens to lock and the duration of the lock.

```solidity
function create_lock(uint256 _value, uint256 _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock creation logic
}
```

### Increasing Lock Amount
Users can increase the amount of Wrapped TRUST tokens in an existing lock by calling the `increase_amount` function.

```solidity
function increase_amount(uint256 _value) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock amount increase logic
}
```

### Increasing Lock Duration
Users can extend the duration of an existing lock by calling the `increase_unlock_time` function.

```solidity
function increase_unlock_time(uint256 _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock duration extension logic
}
```

### Increase Amount and Duration
Users can simultaneously increase the amount of Wrapped TRUST tokens and extend the duration of an existing lock by calling the `increase_amount_and_duration` function.

```solidity
function increase_amount_and_duration(uint256 _value, uint256 _unlock_time) external nonRentrant onlyUserOrWhitelist notUnlocked {
    // Lock amount and duration increase logic
}
```

### Withdraw
Once the lock period has expired, users can withdraw their locked Wrapped TRUST tokens by calling the `withdraw` function.

```solidity
function withdraw() external nonReentrant onlyUserOrWhitelist {
    // Withdrawal logic
}
```

## Smart Contract Reads

### Balance Of
The `balanceOf` function returns the voting power of a specific address at a given timestamp.

```solidity
function balanceOf(address _addr) external view returns (uint256) {
    // Balance calculation logic
}
```

### Balance Of At Timestamp
The `balanceOfAtT` function returns the voting power of a specific address at a given timestamp.

```solidity
function balanceOfAt(address _addr, uint256 _t) external view returns (uint256) {
    // Balance calculation logic
}
```

### Total Supply
The `totalSupply` function returns the total voting power in the system at a given timestamp.

```solidity
function totalSupply() external view returns (uint256) {
    // Total supply calculation logic
}
```

### Total Supply At Timestamp
The `totalSupplyAtT` function returns the total voting power in the system at a given timestamp.

```solidity
function totalSupplyAtT(uint256 t) external view returns (uint256) {
    // Total supply calculation logic
}
```

## Events

### Rewards Claimed
The `RewardsClaimed` event is emitted when a user claims their rewards.

```solidity
event RewardsClaimed(address indexed user, address indexed recipient, uint256 amount);
``` 

## Additional Resources

For more detailed information on the MultiVault contract and its functions, please refer to the [Intuition Smart Contract V2 repository](https://github.com/0xIntuition/intuition-contracts-v2).

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/deep-dive/architecture


# Technical Architecture

Intuition's architecture consists of three tightly integrated layers that work together to create a high-performance, decentralized knowledge graph. This document provides a technical deep-dive into each layer and how they interconnect.

## Architecture Overview

![Intuition System Overview](/img/intuition-intro.png)

Intuition's architecture is designed for **speed**, **scale**, and **interoperability**. By separating concerns across three specialized layers, we achieve optimal performance while maintaining decentralization and cross-chain compatibility.

```mermaid
graph TB
    subgraph "Application Layer"
        SDK[TypeScript SDK]
        API[GraphQL/REST APIs]
        APPS[dApps & Integrations]
    end

    subgraph "Rust Subnet"
        INDEX[Indexing Engine]
        TRANSFORM[Data Transformer]
        CACHE[Cache Layer]
        QUERY[Query Engine]
    end

    subgraph "Intuition Protocol"
        VAULT[EthMultiVault]
        ATOM[AtomWallet]
        CURVE[Bonding Curves]
    end

    subgraph "Intuition Network"
        L3[Base L3 - Orbit Stack]
        METALAYER[Metalayer Standards]
        METATOKEN[Metatoken Bridge]
    end

    SDK --> API
    API --> QUERY
    QUERY --> CACHE
    CACHE --> TRANSFORM
    TRANSFORM --> INDEX
    INDEX --> VAULT
    VAULT --> L3
    ATOM --> L3
    CURVE --> L3
    L3 --> METALAYER
    L3 --> METATOKEN

    style L3 fill:#e1f5fe
    style VAULT fill:#fff3e0
    style INDEX fill:#e8f5e9
```

## Layer 1: Intuition Network (Base L3)

### Overview

The Intuition Network is an **EVM-compatible Layer 3** built on Base using the Orbit stack. This provides the ultra-fast, low-cost transaction environment essential for high-frequency knowledge graph operations.

### Why Layer 3?

Traditional L1s and even L2s are too expensive and slow for the granular operations required by a knowledge graph. Every atom creation, triple attestation, and signal update needs to be economically viable. The L3 architecture provides:

- **Sub-cent transaction costs** - Making micro-attestations economically feasible
- **Sub-second finality** - Enabling real-time knowledge graph updates
- **Massive throughput** - Supporting millions of daily knowledge operations
- **EVM compatibility** - Leveraging existing tooling and developer knowledge

### Technical Specifications

**Performance**
- Block time: ~250ms
- Transaction throughput: 10,000+ TPS
- Finality: < 1 second
- Gas costs: < $0.001 per tx

**Stack Components**
- **Base Layer**: Orbit framework on Base
- **Consensus**: Optimistic rollup with fraud proofs
- **Execution**: EVM-compatible runtime
- **Data Availability**: Base for settlement

**Interoperability**
- **Metalayer**: Cross-chain messaging protocol
- **Metatoken**: Unified token standard
- **Bridge**: Native Base â†” L3 bridge
- **Standards**: ERC-1155, ERC-4626, ERC-4337

### Cross-Chain Interoperability

The Network leverages **Caldera's Metalayer and Metatoken standards** for seamless cross-chain operations:

```solidity
// Example: Cross-chain atom reference
interface IMetalayerBridge {
    function attestCrossChain(
        uint256 chainId,
        uint256 atomId,
        bytes calldata data
    ) external returns (bytes32 messageId);

    function resolveAtom(
        uint256 chainId,
        uint256 atomId
    ) external view returns (string memory uri);
}
```

This enables atoms and triples to reference data across any supported chain, creating a truly interoperable knowledge graph.

## Layer 2: Intuition Protocol (On-Chain Logic)

### Overview

The Intuition Protocol implements all on-chain logic for the knowledge graph through a suite of smart contracts. This is where atoms are created, triples are formed, and economic incentives are enforced.

### Core Contract Architecture

#### **EthMultiVault**
The economic engine managing all vault operations:

```solidity
contract EthMultiVault {
    // Core vault operations
    function deployVault(uint256 atomId) external returns (address vault);
    function deposit(uint256 vaultId, uint256 amount) external;
    function redeem(uint256 vaultId, uint256 shares) external;

    // Bonding curve integration
    function calculatePrice(uint256 supply) public view returns (uint256);
    function calculateShares(uint256 deposit, uint256 totalSupply) external view;
}
```

**Key Features:**
- Automated vault deployment for atoms/triples
- Dynamic pricing via bonding curves
- Share-based ownership model
- Fee distribution to stakers

#### **AtomWallet**
Primary interface for creating and managing knowledge graph primitives:

```solidity
contract AtomWallet {
    // Atom operations
    function createAtom(string memory uri) external returns (uint256 atomId);

    // Triple operations
    function createTriple(
        uint256 subjectId,
        uint256 predicateId,
        uint256 objectId
    ) external returns (uint256 tripleId);

    // Signal operations
    function depositAtom(uint256 atomId, uint256 amount) external;
    function depositTriple(uint256 tripleId, uint256 amount, bool isPositive) external;
}
```

**Key Features:**
- Gas-efficient batch operations
- Account abstraction support (ERC-4337)
- Multi-signature capabilities
- Upgradeable proxy pattern

### Economic Mechanics

The Protocol implements sophisticated economic incentives:

**Bonding Curves**
- Automated price discovery
- Early adopter rewards
- Exponential growth model
- Anti-manipulation mechanics

**Fee Distribution**
- Creator fees: 5% of deposits
- Protocol fees: 2% of deposits
- Staker rewards: Proportional shares
- Compound interest mechanics

**Vault Mechanics**
- Positive/negative signal vaults
- Automatic liquidity provision
- Rage quit protection
- Time-weighted averaging

### State Management

The Protocol maintains the complete on-chain state of the knowledge graph:

```typescript
interface OnChainState {
  atoms: Map<number, {
    id: number;
    uri: string;
    vault: address;
    creator: address;
    timestamp: number;
  }>;

  triples: Map<number, {
    id: number;
    subjectId: number;
    predicateId: number;
    objectId: number;
    vaultFor: address;
    vaultAgainst: address;
  }>;

  signals: Map<address, Map<number, {
    shares: bigint;
    lastUpdate: number;
  }>>;
}
```

## Layer 3: Rust Subnet (Off-Chain Infrastructure)

### Overview

The Rust Subnet is Intuition's high-performance off-chain infrastructure that indexes on-chain state, resolves off-chain data references, and serves the unified knowledge graph through APIs.

**Why Rust?**

The Subnet is built in Rust for maximum performance and reliability:
- **Memory safety** without garbage collection
- **Concurrent processing** for parallel indexing
- **Zero-cost abstractions** for efficient data structures
- **WebAssembly compatibility** for edge deployment

### Core Components

#### **Event Processing Pipeline**

Processes blockchain events through multiple stages:

```rust
// Consumer modes for different processing stages
pub enum ConsumerMode {
    Raw(RawConsumerContext),           // Raw event ingestion
    Decoded(DecodedConsumerContext),   // Event decoding
    Resolver(ResolverConsumerContext), // Data resolution
}

impl ConsumerMode {
    pub async fn process_message(&self, message: String) -> Result {
        match self {
            ConsumerMode::Raw(context) => {
                self.raw_message_store_and_relay(message, context).await
            }
            ConsumerMode::Decoded(context) => {
                self.handle_decoded_message(message, context).await
            }
            ConsumerMode::Resolver(context) => {
                self.handle_resolved_message(message, context).await
            }
        }
    }
}
```

- Real-time event processing through SQS queues
- Multi-stage pipeline (Raw â†’ Decoded â†’ Resolved)
- Chain reorganization handling
- Parallel processing across consumers

#### **Data Resolver**

Resolves and enriches on-chain references with off-chain data:

```rust
pub struct ResolverConsumerContext {
    pub client: Arc,
    pub image_guard_url: String,
    pub ipfs_resolver: IPFSResolver,
    pub mainnet_client: Arc, RootProvider>>>,
    pub pg_pool: PgPool,
    pub reqwest_client: reqwest::Client,
}

impl ResolverConsumerContext {
    pub async fn resolve_atom_data(&self, atom_uri: &str) -> Result {
        match atom_uri {
            uri if uri.starts_with("ipfs://") => {
                self.ipfs_resolver.fetch_content(uri).await
            }
            uri if uri.starts_with("http") => {
                self.reqwest_client.get(uri).send().await?.json().await
            }
            addr if is_ethereum_address(addr) => {
                self.resolve_ens_name(addr).await
            }
        }
    }
}
```

- IPFS content resolution via Pinata
- HTTP/HTTPS metadata fetching
- ENS name resolution on mainnet
- Image validation through image-guard service

#### **Database Integration**

Processes and stores structured data for API consumption:

```rust
pub struct DecodedConsumerContext {
    pub base_client: Arc, RootProvider>>>,
    pub pg_pool: PgPool,
    pub backend_schema: String,
}

impl DecodedConsumerContext {
    pub async fn handle_decoded_message(&self, message: DecodedMessage) -> Result {
        match &message.body {
            EthMultiVaultEvents::AtomCreated(atom_data) => {
                atom_data.handle_atom_creation(self, &message).await?;
            }
            EthMultiVaultEvents::TripleCreated(triple_data) => {
                triple_data.handle_triple_creation(self, &message).await?;
            }
            EthMultiVaultEvents::Deposited(deposit_data) => {
                deposit_data.handle_deposit_creation(self, &message).await?;
            }
        }
        Ok(())
    }
}
```

- PostgreSQL with Hasura GraphQL layer
- Real-time event storage and indexing
- Complex relationship mapping
- Optimized queries with database migrations

### Data Pipeline

The Subnet implements a sophisticated data pipeline:

```mermaid
graph LR
    subgraph "Input"
        CHAIN[Chain Events]
        IPFS[IPFS Data]
        HTTP[HTTP Sources]
    end

    subgraph "Processing"
        INDEX[Indexer]
        VALIDATE[Validator]
        TRANSFORM[Transformer]
        ENRICH[Enricher]
    end

    subgraph "Storage"
        GRAPH[Graph DB]
        SEARCH[Search Index]
        CACHE[Redis Cache]
    end

    subgraph "Output"
        GQL[GraphQL API]
        REST[REST API]
        WS[WebSocket]
    end

    CHAIN --> INDEX
    IPFS --> TRANSFORM
    HTTP --> TRANSFORM
    INDEX --> VALIDATE
    VALIDATE --> TRANSFORM
    TRANSFORM --> ENRICH
    ENRICH --> GRAPH
    ENRICH --> SEARCH
    GRAPH --> CACHE
    CACHE --> GQL
    CACHE --> REST
    CACHE --> WS
```

### API Layer

The Subnet exposes multiple API interfaces:

**GraphQL API**
```graphql
query GetAtomWithTriples {
  atom(id: "123") {
    uri
    vault {
      totalStaked
      sharePrice
    }
    triplesAsSubject {
      predicate { uri }
      object { uri }
      signal
    }
  }
}
```

**REST API**
```http
GET /api/v1/atoms/123
GET /api/v1/triples?subject=123
POST /api/v1/search
WebSocket /ws/subscriptions
```

**Real-time Subscriptions**
```typescript
subscription OnAtomUpdate {
  atomUpdated(id: "123") {
    signal
    lastActivity
    vaultBalance
  }
}
```

## Data Flow Architecture

### Transaction Lifecycle

Understanding how data flows through the system is crucial for developers:

1. **User Action** â†’ SDK creates transaction
2. **Network Processing** â†’ L3 validates and includes in block
3. **Protocol Execution** â†’ Smart contracts update state
4. **Event Emission** â†’ Contracts emit events
5. **Subnet Indexing** â†’ Events processed and indexed
6. **Data Resolution** â†’ Off-chain data fetched and cached
7. **API Response** â†’ Unified data served to applications

**Average End-to-End Latency: < 2 seconds**

### State Synchronization

The system maintains consistency across all layers:

```typescript
interface SyncStrategy {
  // Real-time sync for recent blocks
  realtimeSync: {
    blockLag: 2,
    confirmations: 1,
    retryPolicy: ExponentialBackoff
  };

  // Batch sync for historical data
  batchSync: {
    chunkSize: 1000,
    parallelWorkers: 10,
    checkpointInterval: 100
  };

  // Consistency checks
  validation: {
    stateRootVerification: true,

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/custom-queries


# Custom Queries

This page provides practical examples of common GraphQL queries for the Intuition API.

## Best Practices

1. **Use Fragments**: Create reusable fragments for common fields
2. **Optimize Queries**: Only request the fields you need
3. **Handle Errors**: Always implement proper error handling
4. **Cache Strategically**: Use React Query's caching capabilities
5. **Type Safety**: Leverage generated types for better development experience

## Basic Queries

:::note
This page will be expanded with more query examples, advanced patterns, and real-world use cases.
:::

### Fetching Atoms

```graphql
query GetAtom($id: ID!) {
  atom(id: $id) {
    id
    content
    metadata {
      title
      author
      createdAt
    }
  }
}
```

### Fetching Triples

```graphql
query GetTriples($subject: ID, $predicate: String, $object: ID) {
  triples(subject: $subject, predicate: $predicate, object: $object) {
    id
    subject {
      id
      content
    }
    predicate
    object {
      id
      content
    }
    metadata {
      createdAt
      confidence
    }
  }
}
```

### Fetching Signals

```graphql
query GetSignals($type: String, $limit: Int) {
  signals(type: $type, limit: $limit) {
    id
    type
    data
    timestamp
    source
  }
}
```

## Advanced Queries

### Complex Filtering

```graphql
query SearchAtoms($query: String!, $filters: AtomFilters) {
  searchAtoms(query: $query, filters: $filters) {
    id
    content
    metadata {
      title
      tags
      createdAt
    }
    relevance
  }
}
```

### Pagination

```graphql
query GetAtomsPaginated($first: Int, $after: String) {
  atoms(first: $first, after: $after) {
    edges {
      node {
        id
        content
        metadata {
          title
          createdAt
        }
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
```

## React Query Hooks

### Using Generated Hooks

```tsx

function AtomViewer({ atomId }: { atomId: string }) {
  const { data, loading, error } = useGetAtomQuery({
    variables: { id: atomId }
  })

  return (
      {data?.atom?.metadata?.title}
}
```

### Custom Hooks

```tsx

function useCustomAtomQuery(atomId: string) {
  return useQuery({
    queryKey: ['atom', atomId],
    queryFn: () => client.request(getAtomDocument, { id: atomId }),
    enabled: !!atomId
  })
}
```

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/graphql-generator


# GraphQL Generator

The Intuition GraphQL package can be used as a GraphQL generator for your custom queries. It provides a type-safe interface for interacting with the Intuition API. It functions as the core data fetching layer, supplying generated types and React Query hooks for easy integration with the semantic knowledge graph.

## Key Features

- Type-safe GraphQL operations leveraging code gen
- React Query hooks for data fetching
- Reusable GraphQL fragments
- Easy to customize to your specific needs
- Supports real-time updates from the Intuition GraphQL API through GraphQL subscriptions

## Installation

The source code for the GraphQL generator is available on GitHub, which you can copy and paste into your own project to use as a GraphQL generator: [`intuition-ts/packages/graphql`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)

## Schema Management

The package uses a local-first approach for schema management:

- Local `schema.graphql` as source of truth
- Remote schema fallback for resilience
- Automatic schema generation during builds
- Version controlled schema for team consistency

## Package Structure

```bash
graphql/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ client.ts # Client configuration
â”‚ â”œâ”€â”€ fragments/ # Reusable fragments
â”‚ â”œâ”€â”€ queries/ # GraphQL queries
â”‚ â”œâ”€â”€ mutations/ # GraphQL mutations
â”‚ â””â”€â”€ generated/ # Generated types
â”œâ”€â”€ schema.graphql # Schema definition
â””â”€â”€ codegen.ts # Codegen config
```

Although this package does not include a subscriptions folder, you can easily add one to the generator because the GraphQL API allows subscriptions for real-time updates.

## Package Approach

1. **Schema Updates**
    - Uses the local schema committed in the repository as the source for codegen and uses the remote URL as a fallback
2. **Query Organization**
    - Uses fragments for reusable fields
    - Includes use-case specific queries as well as general purpose queries
3. **Type Safety**
    - Leverages generated types from our schema
    - Generates React Query hooks as well as document queries that can be used in a server context (or with another client such as Apollo)
4. **Client Configuration**
    - Default client configuration can be overridden in each consumer app
    - Supports environment-specific API URLs

## Craft your own custom queries

We advise drafting and testing your queries, mutations, and subscriptions before implementing them into code. You should also use a GraphQL explorer to explore the Intuition GraphQL API schema.

For this, you can use [Apollo Explorer](https://studio.apollographql.com/sandbox/explorer) and input the URL of the Intuition testnet GraphQL API: `https://testnet.intuition.sh/v1/graphql`.

## Development Workflow

1. **Code Generation**
    - `pnpm codegen:build # Generate types`
    - `pnpm codegen:watch # Watch mode for development`
2. **Building**
    - `pnpm build # Full build with codegen`
    - `pnpm dev # Development mode with watch`
3. **Testing**
    - `pnpm test`

## Use your custom React Query hooks

Once you have run the codegen, you can use your custom React Query Hooks in your own components.

```tsx

function MyComponent() {
  // Query triples based on your custom needs
  const { data: triples, isLoading: triplesLoading } = useCustomTriplesQuery({
}
```

The GraphQL API provides the foundation for building powerful applications on Intuition.

## Related Resources

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen)
- [React Query Documentation](https://tanstack.com/query)
- [Intuition GraphQL Package Source](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)


---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/migration-guide


# Migrating GraphQL from v1.5 to v2.0

## Overview

| Environment | Endpoint |
|-------------|----------|
| **Intuition Testnet** | `https://testnet.intuition.sh/v1/graphql` |

## âš ï¸ Breaking Changes

### 1. ID Field Type Changes: Numeric â†’ String

**CRITICAL IMPACT** - All existing queries and mutations using these fields will break.

#### Core Entity ID Changes

| Entity        | Field             | Old Type   | New Type  |
| ------------- | ----------------- | ---------- | --------- |
| `accounts`    | `atom_id`         | `numeric`  | `String`  |
| `atoms`       | `term_id`         | `numeric!` | `String!` |
| `atoms`       | `value_id`        | `numeric`  | `String`  |
| `atom_values` | `id`              | `numeric!` | `String!` |
| `atom_values` | `book_id`         | `numeric`  | `String`  |
| `atom_values` | `byte_object_id`  | `numeric`  | `String`  |
| `atom_values` | `json_object_id`  | `numeric`  | `String`  |
| `atom_values` | `organization_id` | `numeric`  | `String`  |
| `atom_values` | `person_id`       | `numeric`  | `String`  |
| `atom_values` | `text_object_id`  | `numeric`  | `String`  |
| `atom_values` | `thing_id`        | `numeric`  | `String`  |
| `vaults`      | `term_id`         | `numeric!` | `String!` |

#### Entity Primary ID Changes

All primary `id` fields changed from `numeric!` to `String!`:

- `books`
- `byte_object`
- `caip10`
- `json_objects`
- `organizations`
- `persons`
- `text_objects`
- `things`
- `terms`

### 2. Removed Aggregate Fields

**MEDIUM IMPACT** - Statistical queries will break for entities with String IDs.

Removed aggregate field types (no longer available for statistical operations):

- `*_avg_fields` for: accounts, atom_values, books, byte_object, json_objects, organizations, persons, text_objects, things
- `*_stddev_fields`, `*_stddev_pop_fields`, `*_stddev_samp_fields`
- `*_sum_fields`, `*_var_pop_fields`, `*_var_samp_fields`, `*_variance_fields`

## ðŸ†• New Features

### 1. New Optional Fields

#### atom_values

- `caip10_id: String` - Link to CAIP-10 identifiers

### 2. New Entity Types

Statistics and analytics entities:

- `statHours` - Hourly statistics aggregation
- `term_total_state_changes` - Term state change tracking
- `term_total_state_change_stats_daily` - Daily aggregated statistics
- `term_total_state_change_stats_hourly` - Hourly aggregated statistics
- `term_total_state_change_stats_monthly` - Monthly aggregated statistics
- `term_total_state_change_stats_weekly` - Weekly aggregated statistics

### 3. New Scalar Types

- `atom_resolving_status` - Custom scalar for atom resolution states
- `vault_type` - Custom scalar for vault type definitions

## ðŸ”§ Migration Checklist

### Client Application Updates

#### 1. Query/Mutation Updates

- [ ] Update all numeric ID field references to String
- [ ] Remove or update queries using deprecated aggregate fields
- [ ] Test all existing GraphQL operations

#### 2. Code Generation Updates

- [ ] Regenerate TypeScript types
- [ ] Update GraphQL codegen configuration
- [ ] Verify generated types match new schema

#### 3. Variable Updates

```graphql
# OLD
query GetAtom($termId: numeric!) {
  atoms(where: { term_id: { _eq: $termId } }) {
    term_id
    value_id
  }
}

# NEW
query GetAtom($termId: String!) {
  atoms(where: { term_id: { _eq: $termId } }) {
    term_id
    value_id
    raw_data
    resolving_status
  }
}
```

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/npm-package


# GraphQL NPM Package

The Intuition GraphQL package provides a type-safe interface for interacting with the Intuition API. It functions as the core data fetching layer, supplying generated types and React Query hooks for easy integration with the semantic knowledge graph.

## Key Features

- React Query hooks for data fetching
- Type-safe data fetching
- Error handling
- Loading state
- Pagination
- Sorting
- Filtering

## Installation

Install the package using your preferred package manager:

```bash
npm install @0xintuition/graphql
```

```bash
pnpm install @0xintuition/graphql
```

```bash
yarn add @0xintuition/graphql
```

```bash
bun install @0xintuition/graphql
```

## Quick Start

### 1. Client Configuration (Optional)

Configure the GraphQL client at the root of your application:

```tsx

// Configure the GraphQL client with desired API URL
configureClient({
  apiUrl: API_URL_LOCAL, // For local development
})
```

**Available API URLs:**
- `API_URL_PROD`: `https://testnet.intuition.sh/v1/graphql` (default)
- `API_URL_DEV`: `https://testnet.intuition.sh/v1/graphql`
- `API_URL_LOCAL`: `http://localhost:8080/v1/graphql`

If you omit this configuration, the package defaults to `API_URL_PROD`.

### 2. Server Client Usage

For server-side operations:

```typescript

// Basic usage (most common)
const client = createServerClient({})

// With optional authentication token (rarely needed)
const clientWithAuth = createServerClient({
}
```

## Available React Hooks
The following groups correspond to the query documents in the `src/queries` subdirectory of the package. Hook names are generated from each document and follow the `useQuery` convention. The complete and canonical list may be found in the directory: [`packages/graphql/src/queries`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql/src/queries)

### Accounts
      useAccountByIdQuery
    
      useAccountsQuery
    
### Atoms
      useAtomByIdQuery
      useGetAtomQuery
    
      useAtomsQuery
      useGetAtomsQuery
    
### Claims
      useClaimByIdQuery
    
      useClaimsQuery
    
### Events
      useEventByIdQuery
    
      useEventsQuery
    
### Follows
      useFollowByIdQuery
    
      useFollowsQuery
    
### Lists
      useListByIdQuery
    
      useListsQuery
    
### Points
      usePointByIdQuery
    
      usePointsQuery
    
### Positions
      usePositionByIdQuery
    
      usePositionsQuery
      useUserPositionsQuery
    
### Signals
      useSignalByIdQuery
    
      useSignalsQuery
      useGetSignalsQuery
    
### Stats
      useGetStatsQuery
    
      useStatsQuery
    
### Tags
      useTagByIdQuery
    
      useTagsQuery
    
### Triples
      useTripleByIdQuery
    
      useTriplesQuery
    
### Vaults
      useVaultByIdQuery
    
      useVaultsQuery
    
These hooks are generated via GraphQL Code Generator and may expand over time as new documents are added. See the package source below for the current and authoritative list.

## Source Code

The GraphQL package source code is available on GitHub: [`intuition-ts/packages/graphql`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)

## Related Resources

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen)
- [React Query Documentation](https://tanstack.com/query)


---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/overview


# GraphQL API Overview

  {() => (
    
  )}

Intuition provides GraphQL APIs for querying its knowledge graph in a convenient and versatile way. 

**Available endpoints**

      Intuition mainnet
    
      ```text
      https://mainnet.intuition.sh/v1/graphql
      ```
      <a
        href="https://studio.apollographql.com/sandbox/explorer?endpoint=https://mainnet.intuition.sh/v1/graphql"
        target="_blank"
        rel="noreferrer"
      >
        Try on GraphQL Explorer
      
      Intuition testnet
    
      ```text
      https://testnet.intuition.sh/v1/graphql
      ```
      <a
        href="https://studio.apollographql.com/sandbox/explorer?endpoint=https://testnet.intuition.sh/v1/graphql"
        target="_blank"
        rel="noreferrer"
      >
        Try on GraphQL Explorer
      
Alternatively, you can import these URLs from the GraphQL package:

```ts
```

If this is your first time using GraphQL, you can learn more at [graphql.org](https://graphql.org/).

There are a few ways to get started with this GraphQL API, depending on the level of abstraction and customization you require : 

  <a
    href="/docs/developer-tools/sdks/overview"
  >
      SDK
    
      Integrate with Intuition smart contracts using our TypeScript SDK.
  
  <a
    href="/docs/developer-tools/graphql-api/custom-queries"
  >
      Custom Queries
    
      Create bespoke GraphQL queries for your specific use case.
  
### GraphQL Package

  <a
    href="/docs/developer-tools/graphql-api/npm-package"
  >
      Install it with NPM
    
      Install and use the NPM package with ready-made React Query hooks.
  
  <a
    href="/docs/developer-tools/graphql-api/npm-package"
  >
      Use it as a GraphQL Generator
    
      Use the GraphQL package to generate your own queries and mutations.
  
## Interactive Playground

Try the Intuition GraphQL API straight from your browser!  The playground below connects to the live testnet endpoint and allows you to explore the knowledge graph in real time.


---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/reads


# Reads

## GraphQL API

Our GraphQL API provides a flexible and efficient way to interact with our atomic data structure system. Through this documentation, you'll learn how to query and manipulate atomic data using our GraphQL endpoints. To help you explore and test the API interactively, we've integrated Apollo Explorer sandbox environments throughout this documentation.

These interactive playgrounds allow you to experiment with queries in real-time, seeing exactly how the API responds to different inputs and parameters.

This documentation will be split into sections by primitive, such as `Atoms`, `Triples`, and so on.

:::tip
We maintain a GraphQL SDK for our API that includes these queries with additional hooks for React developers to use directly in their apps. You can find it here: [https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)

Our SDK utilizes GraphQL Codegen and Fragments, but for the sake of clarity and simplicity the query examples in the playgrounds won't utilize Fragments.
:::

## Best Practices

1. **Use the SDK**: Leverage our GraphQL SDK for type-safe queries
2. **Optimize Queries**: Only request the fields you need
3. **Handle Loading States**: Always show loading indicators
4. **Implement Error Boundaries**: Catch and handle errors gracefully
5. **Use Pagination**: Implement proper pagination for large datasets
6. **Cache Strategically**: Use React Query's caching capabilities

## Backend Architecture Overview

This architecture diagram illustrates the data flow and integration stack for the Intuition backend. We ingest data from two primary RPC sources: our EthMultiVault contract and a ChainLinkOracle contract. This blockchain data is processed in a Docker environment indexed through Substreams, parsing and structuring the data into a PostgreSQL database.

Hasura then provides a GraphQL API layer on top of Postgres, enabling flexible data querying powering our app layers. This architecture provides efficient blockchain data indexing, reliable storage, and scalable API access. Our upcoming GraphQL SDK will further streamline the process for app developers looking to consume our data for building and extending the Intuition protocol.

## GraphQL Playground

The interactive Apollo Sandbox below lets you explore our GraphQL API in real-time. You can write and execute queries, inspect the schema, and see live responses from our API. We've set up this environment to help you get familiar with our data structure and available operations.

Try starting with some basic queries like fetching atoms or exploring relationship triples. Here's a query to get you started:

:::tip
You can copy and paste the code snippet below into the sandbox above to view the results.
:::

```graphql
query GetAtoms(
  $limit: Int
  $offset: Int
  $orderBy: [atoms_order_by!]
  $where: atoms_bool_exp
) {
  total: atoms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  atoms(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    # Basic metadata
    term_id
    data
    image
    label
    emoji
    type
    wallet_id
    creator {
      id
      label
      image
    }

    # Transaction details
    block_number
    created_at
    updated_at
    transaction_hash
    creator_id

    # Vault details
    term {
      vaults(where: { curve_id: { _eq: "1" } }, order_by: { curve_id: asc }) {
        position_count
        total_shares
        current_share_price
        market_cap
        positions_aggregate {
          aggregate {
            count
            sum {
              shares
            }
          }
        }
        positions {
          id
          account {
            label
            id
          }
          shares
        }
      }
    }

    # Value metadata
    value {
      person {
        name
        image
        description
        url
      }
      thing {
        name
        image
        description
        url
      }
      organization {
        name
        image
        description
        url
      }
      account {
        id
        label
        image
      }
    }
  }
}
```

You can start with this initial `GetAtoms` query in the Apollo Sandbox or write your own. The schema Explorer (docs tab) on the left side of the sandbox shows all available queries, mutations, and types. As you type, you'll get real-time autocompletion and documentation hints to help you build your queries. You can then click the play button to see the response and then adjust your query as you explore our data.

Need inspiration? Check out the example queries in the GraphQL API Example Queries page to get started, or jump right in and start exploring!

## Query Examples

### GetAtoms

The `GetAtoms` query is the primary way to fetch atom data from the Intuition system. It provides comprehensive information about atoms including metadata, transaction details, and vault information.

```graphql
query GetAtoms(
  $limit: Int
  $offset: Int
  $orderBy: [atoms_order_by!]
  $where: atoms_bool_exp
) {
  total: atoms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  atoms(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    # Basic metadata
    term_id
    data
    image
    label
    emoji
    type
    wallet_id
    creator {
      id
      label
      image
    }

    # Transaction details
    block_number
    created_at
    updated_at
    transaction_hash
    creator_id

    # Vault details
    term {
      vaults(where: { curve_id: { _eq: "1" } }, order_by: { curve_id: asc }) {
        position_count
        total_shares
        current_share_price
        market_cap
        positions_aggregate {
          aggregate {
            count
            sum {
              shares
            }
          }
        }
        positions {
          id
          account {
            label
            id
          }
          shares
        }
      }
    }

    # Value metadata
    value {
      person {
        name
        image
        description
        url
      }
      thing {
        name
        image
        description
        url
      }
      organization {
        name
        image
        description
        url
      }
      account {
        id
        label
        image
      }
    }
  }
}
```

### GetAccounts

Query account information including balances and positions.

```graphql
query GetAccounts($limit: Int, $offset: Int) {
  accounts(limit: $limit, offset: $offset) {
    id
    label
    image
    positions {
      id
      shares
      vault {
        id
        atom {
          label
          image
        }
      }
    }
  }
}
```

### GetTriples

Fetch relationship triples between atoms.

```graphql
query GetTriples(
  $limit: Int
  $offset: Int
  $orderBy: [triples_order_by!]
  $where: triples_bool_exp
) {
  total: triples_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  triples(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    term_id
    counter_term_id
    created_at
    subject {
      term_id
      label
      image
      data
      type
      value {
        thing {
          description
          url
        }
        person {
          description
          url
        }
        organization {
          description
          url
        }
      }
    }
    predicate {
      term_id
      label
      image
      data
      type
    }
    object {
      term_id
      label
      image
      data
      type
      value {
        thing {
          description
          url
        }
        person {
          description
          url
        }
        organization {
          description
          url
        }
      }
    }
    # Vault details for pro/counter positions
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }
    counter_term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }
  }
}
```

### GetPositions

Query user positions in atom vaults.

```graphql
query GetPositions(
  $limit: Int
  $offset: Int
  $orderBy: [positions_order_by!]
  $where: positions_bool_exp
) {
  total: positions_aggregate(where: $where) {
    aggregate {
      count
      sum {
        shares
      }
    }
  }
  positions(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    id
    created_at
    updated_at
    shares
    account {
      id
      label
      image
    }
    vault {
      created_at
      updated_at
      term {
        atom {
          term_id
          label
          image
          term {
            vaults(where: { curve_id: { _eq: "1" } }) {
              term_id
              total_shares
              current_share_price
              position_count
            }
          }
        }
        triple {
          term_id
          subject {
            term_id
            label
            image
          }
          predicate {
            term_id
            label
            image
          }
          object {
            term_id
            label
            image
          }
          term {
            vaults(where: { curve_id: { _eq: "2" } }) {
              market_cap
              current_share_price
              position_count
            }
          }
        }
      }
    }
  }
}
```

### GetVaults

Fetch vault information including share prices and positions.

```graphql
query GetVaults($limit: Int, $offset: Int) {
  vaults(limit: $limit, offset: $offset) {
    id
    atom {
      id
      label
      image
    }
    current_share_price
    total_shares
    position_count
    positions_aggregate {
      aggregate {
        count
        sum {
          shares
        }
      }
    }
  }
}
```

## Utilities

### Search and Filtering

```graphql
query SearchAtoms($query: String!, $filters: atoms_bool_exp) {
  atoms(where: $filters) {
    id
    label
    image
    type
    creator {
      id
      label
    }
  }
}
```

### Pagination

```graphql
query GetAtomsPaginated($first: Int, $after: String) {
  atoms(first: $first, after: $after) {
    edges {
      node {
        id
        label
        image
        type
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
```

## React Integration

### Using the GraphQL SDK

```tsx

function AtomList() {
  const { data, loading, error } = useGetAtomsQuery({
    variables: {
      limit: 10,
      offset: 0
    }
  })

  return (
      {data?.atoms.map(atom => (
          {atom.label}
          
      ))}
}
```

---

*For more examples and advanced patterns, check out our [GraphQL SDK](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql) and [Example Queries](/guides/developer-tools/graphql-api/query-examples) page.* 

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/use-cases/building-user-activity-feeds


# Building User Activity Feeds

Learn how to create personalized, real-time activity feeds that track user interactions across the Intuition ecosystem using the GraphQL API.

## Understanding the Progression

1. **Get the whole user activity feed**, including atoms made and positions taken, along with vault details.
2. **Get recent claims** produced by the user, both atoms (max 10) and triples (max 10) with detailed metadata.
3. **Get active user positions** ordered by share amount - shows current stakes with vault performance metrics.

  {

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/use-cases/discovering-most-trusted-accounts


# Discovering the Most Trusted Accounts

Learn how to leverage the Intuition GraphQL API to find and rank the ecosystem's most trusted accounts based on their positions, stakes, and activity patterns.

## Understanding the Progression

1. **Get top 20 accounts** ranked by total shares across all positions, showing the most trusted accounts based on cumulative stakes.
2. **Get detailed information** for a given account including all positions and atoms created.
3. **Find top 20 individual positions** by share amount, showing which accounts hold the largest single stakes.

  {

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/use-cases/finding-related-claims


# Finding Related Claims

Learn how to find and navigate related claims in the Intuition knowledge graph by exploring triples, their relationships, and semantic connections.

## Understanding the Progression

1. **Find all triples** where a specific atom appears as subject or object and discover direct relationships.
2. **Find similar claims** by predicate pattern and subject type, then discover relationship patterns across the graph.
3. **Get detailed information** about a specific triple, including vault metrics and top positions.

  {

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/use-cases/finding-top-dapps-on-coinbase


# Finding the Top dApps on Coinbase

This guide shows you how to progressively build queries to discover and rank the top decentralized applications (Dapps) on Coinbase by market capitalization.

Follow these 4 queries step-by-step. Each one builds on the previous to achieve the final result: **a ranked list of top dApps on Coinbase**.

## Understanding the Progression

1. **Run a basic query** to view all dApps (organizations) in the system.
2. **Repeat the query**, but filtered for Coinbase-related Dapps (note how the results narrow down).
3. **Add performance metrics** from vaults (market cap, shares, and positions), data is now richer but not yet sorted.
4. **Repeat the query from Step 3**, but this time sort by market cap to show the top performing dApps first.

  {

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/use-cases/overview


# GraphQL API Use Cases

This section contains practical, step-by-step tutorials for common use cases when working with the Intuition GraphQL API. Each example explains how to build real-world applications with our semantic knowledge graph.

## Available Examples

Select a use case above to see detailed step-by-step implementation guides.

  <a
    href="/finding-top-dapps-on-coinbase"
  >
      Finding the Top dApps on Coinbase
    
      Query and rank decentralized applications based on market data.
  
  <a
    href="/discovering-most-trusted-accounts"
  >
      Discovering the Most Trusted Accounts
    
      Find highly trusted accounts based on stake and activity.
  
  <a
    href="/building-user-activity-feeds"
  >
      Building User Activity Feeds
    
      Create personalized activity streams for users.
  
  <a
    href="/finding-related-claims"
  >
      Finding Related Claims
    
      Discover linked triples and relationship patterns.
  

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/graphql-api/writes


# Writes

## GraphQL Mutations

Our GraphQL API provides convenient mutations to help structure and publish Atom metadata following common schemas and best practices. While the protocol supports any URI scheme, these mutations offer an opinionated approach to creating well-structured, interoperable data.

## Current Schema Support

Our GraphQL API provides mutations for uploading structured metadata following common schemas. The primary mutation is `pinThing` which uploads metadata to IPFS following the **Thing schema**.

### pinThing Mutation

```graphql
mutation pinThing(
  $name: String!
  $description: String
  $image: String
  $url: String
) {
  pinThing(
    thing: {
      name: $name,
      description: $description,
      image: $image,
      url: $url
    }
  ) {
    uri
  }
}
```

### Example Usage

```json
{
  "name": "My First Thing",
  "description": "This is an example description of a thing",
  "image": "https://example.com/image.png",
  "url": "https://example.com"
}
```

### Variables Example

```json
{
  "name": "Intuition Protocol",
  "description": "A decentralized trust protocol for the internet",
  "image": "https://intuition.systems/logo.png",
  "url": "https://intuition.systems"
}
```

The mutation returns an IPFS URI that can be used when creating an Atom:

```typescript
const { data } = await pinThing(thingVariables)
// data.pinThing.uri contains the IPFS URI
// Use this URI when creating atoms via the SDK
```

## Advanced Mutation Examples

### Creating Atoms with Metadata

```graphql
mutation CreateAtomWithMetadata($uri: String!, $curveId: Int!) {
  createAtom(uri: $uri, curveId: $curveId) {
    id
    uri
    createdAt
    vault {
      id
      curveId
      isActive
    }
  }
}
```

### Creating Triples

```graphql
mutation CreateTriple(
  $subjectId: String!
  $predicateId: String!
  $objectId: String!
  $curveId: Int!
) {
  createTriple(
    subjectId: $subjectId
    predicateId: $predicateId
    objectId: $objectId
    curveId: $curveId
  ) {
    id
    subject {
      id
      uri
    }
    predicate {
      id
      uri
    }
    object {
      id
      uri
    }
    positiveVault {
      id
      curveId
    }
    negativeVault {
      id
      curveId
    }
  }
}
```

### Taking Positions on Atoms

```graphql
mutation TakePositionOnAtom(
  $atomId: String!
  $shares: String!
  $curveId: Int!
) {
  takePosition(
    atomId: $atomId
    shares: $shares
    curveId: $curveId
  ) {
    id
    user
    shares
    assets
    atom {
      id
      uri
    }
    vault {
      id
      curveId
    }
  }
}
```

### Taking Positions on Triples

```graphql
mutation TakePositionOnTriple(
  $tripleId: String!
  $shares: String!
  $isPositive: Boolean!
  $curveId: Int!
) {
  takeTriplePosition(
    tripleId: $tripleId
    shares: $shares
    isPositive: $isPositive
    curveId: $curveId
  ) {
    id
    user
    shares
    assets
    isPositive
    triple {
      id
      subject {
        uri
      }
      predicate {
        uri
      }
      object {
        uri
      }
    }
    vault {
      id
      curveId
    }
  }
}
```

## Example Workflows

### Basic Thing Creation

```typescript
// 1. Upload metadata
const thingData = {
}
```

We are actively finalizing patterns to properly externalize this package, which will be released shortly. This guide will be updated to provide example implementations once the package is released.

## Related Resources

- [GraphQL API Overview](/guides/developer-tools/graphql-api/overview)
- [GraphQL Reads](/guides/developer-tools/graphql-api/reads)
- [Intuition GraphQL Package Source](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql) 

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/interactions/create-atom


# Create Atom

Creating atoms in the Intuition protocol involves interacting with the EthMultiVault contract to establish new entities in the knowledge graph. This process includes creating the atom itself and managing its associated vault.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

## Implementation

We recommend creating a `multivault.ts` that includes the following atom creation functionality:

{`// Create atom with initial deposit
const createAtomConfig = {
  ...multiVaultContract,
    
    if (!atomCreatedEvent) {
      throw new Error('Atom creation event not found')
    }
    
    const atomId = atomCreatedEvent.args.atomId
    const vaultId = atomCreatedEvent.args.vaultId
    
    return {
      success: true,
      atomId,
      vaultId,
      transactionHash: hash,
      receipt
    }
  } catch (error) {
    return {
      success: false,
      error: error.message
    }
  }
}`}

## Key Functions

We use this pattern to create atoms and manage their lifecycle:

Creates a new atom with optional initial deposit and returns atom/vault IDs.

Validates atom data format and ensures it meets protocol requirements.

Estimates the cost of creating an atom including fees and gas costs.

## Usage Example

{`// Create a new atom
const atomData = "did:ethr:mainnet:0x1234567890abcdef"
const initialDeposit = parseEther("0.1")

const result = await createAtom(
  MULTIVAULT_CONTRACT_ADDRESS,
  atomData,
  initialDeposit,
  walletClient,
  publicClient

if (result.success) {
  console.log({
    atomId: result.atomId,
    vaultId: result.vaultId,
    transactionHash: result.transactionHash
  })
} else {
  console.error('Atom creation failed:', result.error)
}`}

## Error Handling

Ensure wallet has sufficient ETH for gas and deposit amount.
Validate atom data format before submission.
Handle RPC failures and network connectivity issues.

## Best Practices

- Always validate atom data before submission
- Estimate costs before executing transactions
- Implement proper error handling and user feedback
- Use multicall patterns for batch operations
- Monitor transaction status and provide confirmation feedback

## Next Steps

After creating atoms, explore:

- [Create Triple](/guides/developer-tools/interactions/create-triple) - Learn how to create relationships between atoms
- [Deposit & Return](/guides/developer-tools/interactions/deposit-return) - Manage vault deposits and withdrawals
- [Retrieve Vault Details](/guides/developer-tools/interactions/retrieve-vault-details) - Get comprehensive vault information

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/interactions/create-triple


# Create Triple

Creating triples in the Intuition protocol involves establishing relationships between atoms through the EthMultiVault contract. This process creates both the triple structure and its associated vaults for positive and negative positions.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide and have existing atoms to work with.

## Implementation

We recommend creating a `multivault.ts` that includes the following triple creation functionality:

{`// Create triple with initial deposit
const createTripleConfig = {
  ...multiVaultContract,

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/interactions/deposit-return


# Deposit & Return

Managing deposits and withdrawals from vaults in the Intuition protocol involves interacting with the EthMultiVault contract to stake and unstake tokens. This process includes proper fee handling and share price calculations.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

## Implementation

We recommend creating a `multivault.ts` that includes the following deposit and withdrawal functionality:

{`// Deposit into vault
const depositConfig = {
  ...multiVaultContract,

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/interactions/overview


# Contract Interactions Overview

The Intuition protocol's smart contracts manage complex state involving Atoms, Triples, and their associated vaults. When interacting with these primitives, we recommend retrieving state data directly from the EthMultiVault contract.

## Key Concepts

Batch multiple read-only contract calls into a single request to reduce RPC calls and improve performance.

Retrieve comprehensive vault information including assets, share prices, and user positions.

Access global protocol configuration including fee structures and minimum deposits.

## Implementation Approach

We utilize multicall operations that batch multiple read-only contract calls into a single request. This approach significantly reduces RPC calls and provides data you'll need for contract interactions, such as the `atomCost` that is referenced in the contract interaction guides.

{`// Core multicall configuration
const coreContractConfigs = [
  {
    ...multiVaultContract,

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/interactions/retrieve-vault-details


# Retrieve Vault Details

The Intuition protocol's EthMultiVault contract manages complex state involving Atoms, Triples, and their associated vaults. When interacting with these primitives, we recommend retrieving the state data directly from the EthMultiVault contract.

We utilize multicall operations that batch multiple read-only contract calls into a single request. This approach significantly reduces RPC calls and provides data you'll need for contract interactions, such as the `atomCost` that is referenced in the contract interaction guides.

## Implementation

This implementation guide assumes that you've completed the steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

We recommend creating a `multivault.ts` that includes the following:

{`// createMultiVaultcontract
const multiVaultContract = createMultiVaultContract(contract)

// Core multicall configuration
const coreContractConfigs = [
  {
    ...multiVaultContract,

// Access formatted values such as atom_cost and triple_cost
console.log({
  atomCost: vaultDetails.atom_cost,
  tripleCost: vaultDetails.triple_cost,
})`}

## Reference Implementation

For a full example of how we implement all of our EthMultiVault multicalls, you can look at a reference implementation in our monorepo:

- [https://github.com/0xIntuition/intuition-ts/blob/main/apps/portal/app/.server/multivault.ts](https://github.com/0xIntuition/intuition-ts/blob/main/apps/portal/app/.server/multivault.ts)

## Best Practices

- Use multicall patterns to reduce RPC calls and improve performance
- Always handle errors gracefully when retrieving vault data
- Cache vault details when possible to reduce redundant calls
- Validate returned data before using it in your application
- Monitor vault state changes and update your UI accordingly

## Next Steps

After retrieving vault details, explore:

- [Create Atom](/guides/developer-tools/interactions/create-atom) - Create atoms and manage their vaults
- [Create Triple](/guides/developer-tools/interactions/create-triple) - Create triples with associated vaults
- [Deposit & Return](/guides/developer-tools/interactions/deposit-return) - Manage vault deposits and withdrawals

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/sdks/migration-guide


# Migrating SDK from v1.5 to v2.0

This guide helps you migrate your code from v1.x to v2.0.0-alpha of the Intuition TypeScript packages. This is a **major version update** with significant breaking changes due to the underlying contract migration from `EthMultiVault` to `MultiVault`.

## Contract Migration Overview

The core smart contract has been upgraded from `EthMultiVault` to `MultiVault`, introducing significant architectural changes that impact all TypeScript libraries built on top.

### Key Contract Changes

#### 1. **ID System Migration**

- **EthMultiVault**: Uses `uint256` for atom/triple IDs
- **MultiVault**: Uses `bytes32` for term IDs (atoms and triples are now "terms")

#### 2. **Terminology Changes**

- **EthMultiVault**: Atoms and Triples as separate entities
- **MultiVault**: Unified "Terms" concept (atoms and triples are both terms)
- **EthMultiVault**: Vault IDs
- **MultiVault**: Term IDs with Curve IDs for bonding curves

#### 3. **Bonding Curve Integration**

- **EthMultiVault**: Limited bonding curve support
- **MultiVault**: Full bonding curve integration with curve IDs for all operations

## Breaking Changes Overview

### Package Version Updates

| Package                 | Previous Version | New Version     |
| ----------------------- | ---------------- | --------------- |
| `@0xintuition/protocol` | `1.0.0-alpha.1`  | `2.0.0-alpha.2` |
| `@0xintuition/sdk`      | `1.0.0-alpha.3`  | `2.0.0-alpha.2` |
| `@0xintuition/graphql`  | `1.0.0-alpha.3`  | `2.0.0-alpha.2` |
| `@0xintuition/cli`      | `0.0.2`          | `2.0.0-alpha.2` |

## 1. Contract Migration Impact

### Contract Function Mapping

The migration from `EthMultiVault` to `MultiVault` requires updating all contract interactions. Here's the complete function mapping:

#### Core Creation Functions

##### Atom Creation

```solidity
// EthMultiVault
function createAtom(bytes atomUri) payable returns (uint256)
function batchCreateAtom(bytes[] atomUris) payable returns (uint256[])

// MultiVault
function createAtoms(bytes[] data, uint256[] assets) payable returns (bytes32[])
```

##### Triple Creation

```solidity
// EthMultiVault
function createTriple(uint256 subjectId, uint256 predicateId, uint256 objectId) payable returns (uint256)
function batchCreateTriple(uint256[] subjectIds, uint256[] predicateIds, uint256[] objectIds) payable returns (uint256[])

// MultiVault
function createTriples(bytes32[] subjectIds, bytes32[] predicateIds, bytes32[] objectIds, uint256[] assets) payable returns (bytes32[])
```

#### Deposit Functions

##### EthMultiVault

```solidity
function depositAtom(address receiver, uint256 id) payable returns (uint256)
function depositTriple(address receiver, uint256 id) payable returns (uint256)
function batchDeposit(address receiver, uint256[] termIds, uint256[] amounts) payable returns (uint256[])
```

##### MultiVault

```solidity
function deposit(address receiver, bytes32 termId, uint256 curveId, uint256 minShares) payable returns (uint256)
function depositBatch(address receiver, bytes32[] termIds, uint256[] curveIds, uint256[] assets, uint256[] minShares) payable returns (uint256[])
```

#### Redeem Functions

##### EthMultiVault

```solidity
function redeemAtom(uint256 shares, address receiver, uint256 id) returns (uint256)
function redeemTriple(uint256 shares, address receiver, uint256 id) returns (uint256)
function batchRedeem(uint256 percentage, address receiver, uint256[] ids) returns (uint256[])
```

##### MultiVault

```solidity
function redeem(address receiver, bytes32 termId, uint256 curveId, uint256 shares, uint256 minAssets) returns (uint256)
function redeemBatch(address receiver, bytes32[] termIds, uint256[] curveIds, uint256[] shares, uint256[] minAssets) returns (uint256[])
```

### Contract Address Changes: `EthMultiVault` â†’ `MultiVault`

**Before:**

```typescript

const address = getEthMultiVaultAddress(chainId)
```

**After:**

```typescript

const address = getMultiVaultAddressFromChainId(intuitionTestnet.id)
```

### Contract Event Changes

#### EthMultiVault Events

```solidity
event AtomCreated(address indexed creator, address indexed atomWallet, bytes atomData, uint256 vaultId)
event TripleCreated(address indexed creator, uint256 subjectId, uint256 predicateId, uint256 objectId, uint256 vaultId)
```

#### MultiVault Events

```solidity
event AtomCreated(address indexed creator, bytes32 indexed termId, bytes atomData, address atomWallet)
event TripleCreated(address indexed creator, bytes32 indexed termId, bytes32 subjectId, bytes32 predicateId, bytes32 objectId)
```

### Data Structure Migration

#### ID Handling Update

```typescript
// Before (EthMultiVault)
const atomId: bigint = 123n;
const tripleId: bigint = 456n;

// After (MultiVault)
const atomId: `0x${string}` = "0x1234..."; // 32-byte hash
const tripleId: `0x${string}` = "0x5678..."; // 32-byte hash
```

#### Query Functions

```solidity
// EthMultiVault
function atoms(uint256 atomId) view returns (bytes)
function getTripleAtoms(uint256 id) view returns (uint256, uint256, uint256)

// MultiVault
function atom(bytes32 atomId) view returns (bytes)
function getAtom(bytes32 atomId) view returns (bytes)
function triple(bytes32 tripleId) view returns (bytes32, bytes32, bytes32)
function getTriple(bytes32 tripleId) view returns (bytes32, bytes32, bytes32)
```

#### Share and Asset Conversions

```solidity
// EthMultiVault
function convertToShares(uint256 assets, uint256 id) view returns (uint256)
function convertToAssets(uint256 shares, uint256 id) view returns (uint256)

// MultiVault
function convertToShares(bytes32 termId, uint256 curveId, uint256 assets) view returns (uint256)
function convertToAssets(bytes32 termId, uint256 curveId, uint256 shares) view returns (uint256)
```

### New MultiVault Features

#### 1. **Utilization Tracking**

```typescript
const userUtilization = await multiVault.getUserUtilizationForEpoch(
  userAddress,
  epoch,
const totalUtilization = await multiVault.getTotalUtilizationForEpoch(epoch)
```

#### 2. **Epoch System**

```typescript
const currentEpoch = await multiVault.currentEpoch()
const lastActiveEpoch = await multiVault.lastActiveEpoch(userAddress)
```

#### 3. **Enhanced Fee Management**

```typescript
// Atom wallet deposit fees
const accumulatedFees =
  await multiVault.accumulatedAtomWalletDepositFees(atomWallet)
await multiVault.claimAtomWalletDepositFees(termId)

// Protocol fees by epoch
const protocolFees = await multiVault.accumulatedProtocolFees(epoch)
```

#### 4. **Improved Preview Functions**

```typescript
// Preview with different scenarios
const [shares, assetsAfterFees] = await multiVault.previewDeposit(termId, curveId, assets);
const [shares, assetsAfterFixedFees, assetsAfterFees] = await multiVault.previewAtomCreate(termId, curveId, assets);
```

## 2. TypeScript Library Changes

### Protocol Package (`@0xintuition/protocol`)

#### Atom Creation: Singular â†’ Plural

**Before:**

```typescript
  createAtom,
  createAtomCalculateBaseCost,
  createAtomEncode,
} from '@0xintuition/protocol'

// Single atom creation
await createAtom(config, { args: [atomUri], value })

// Encoding
const encodedData = createAtomEncode(atomUri)

// Cost calculation
const cost = await createAtomCalculateBaseCost(config)
```

**After:**

```typescript
  createAtoms,
  createAtomsEncode,
  getAtomCost,
} from '@0xintuition/protocol'

// Atoms creation (supports single or multiple)
await createAtoms(config, {
  args: [
    [atomUri1, atomUri2],
    [assets1, assets2],
  ],
  value,
})

// Encoding
const encodedData = createAtomsEncode([atomUri1, atomUri2], [assets1, assets2])

// Cost calculation
const cost = await getAtomCost(config)
```

#### Triple Creation: Singular â†’ Plural

**Before:**

```typescript
  createTriple,
  createTripleCalculateBaseCost,
  createTripleEncode,
} from '@0xintuition/protocol'

await createTriple(config, {
  args: [subjectId, predicateId, objectId],
  value,
})

const encodedData = createTripleEncode(subjectId, predicateId, objectId)
const cost = await createTripleCalculateBaseCost(config)
```

**After:**

```typescript
  createTriples,
  createTriplesEncode,
  getTripleCost,
} from '@0xintuition/protocol'

await createTriples(config, {
  args: [
    [subjectId1, subjectId2],
    [predicateId1, predicateId2],
    [objectId1, objectId2],
    [assets1, assets2],
  ],
  value,
})

const encodedData = createTriplesEncode(
  [subjectId1, subjectId2],
  [predicateId1, predicateId2],
  [objectId1, objectId2],
  [assets1, assets2],

const cost = await getTripleCost(config)
```

#### Deposit and Redeem Simplification

**Before:**

```typescript
  depositAtom,
  depositAtomEncode,
  depositTriple,
  depositTripleEncode,
  redeemAtom,
  redeemAtomEncode,
  redeemTriple,
  redeemTripleEncode,
} from '@0xintuition/protocol'

// Separate functions for atoms and triples
await depositAtom(config, { args: [receiver, atomId], value })
await depositTriple(config, { args: [receiver, tripleId], value })
await redeemAtom(config, { args: [shares, receiver, atomId] })
await redeemTriple(config, { args: [shares, receiver, tripleId] })
```

**After:**

```typescript
  deposit,
  depositEncode,
  redeem,
  redeemEncode,
} from '@0xintuition/protocol'

// Unified functions for any vault (atom or triple)
await deposit(config, {
  args: [receiver, termId, curveId, assets, minShares],
  value,
})
await redeem(config, { args: [receiver, termId, cirveId, shares, minAssets] })

// Unified encoding
const depositData = depositEncode(receiver, vaultId)
const redeemData = redeemEncode(shares, receiver, vaultId)
```

#### Batch Operations Renamed

**Before:**

```typescript
  batchCreateAtom,
  batchCreateTriple,
  batchDepositCurve,
  batchRedeemCurve,
} from '@0xintuition/protocol'
```

**After:**

```typescript
  createAtoms, // Replaces batchCreateAtom
  createTriples, // Replaces batchCreateTriple
  depositBatch, // Replaces batchDepositCurve
  redeemBatch, // Replaces batchRedeemCurve
} from '@0xintuition/protocol'
```

#### Multicall Function Name

**Before:**

```typescript

const config = await multiCallIntuitionConfigs({ address, publicClient })
```

**After:**

```typescript

const config = await multicallIntuitionConfig({ address, publicClient })
```

#### Removed EthMultiVault API

**Before:**

```typescript

const ethMultiVault = new EthMultiVault({ publicClient, walletClient })
const result = await ethMultiVault.createAtom('hello')
```

**After:**

```typescript
  getMultiVaultAddressFromChainId,
  intuitionTestnet,
  MultiVaultAbi,
} from '@0xintuition/protocol'

const multiVault = getContract({
  abi: MultiVaultAbi,
  address: getMultiVaultAddressFromChainId(intuitionTestnet.id),
  client: {
    public: publicClient,
    wallet: walletClient,
  },
})

const atomCost = await multiVault.read.getAtomCost()
const result = await multiVault.createAtoms([['hello'], [atomCost]], {
  value: atomCost,
})
```

### Bonding Curve Integration

The new `MultiVault` contract requires curve IDs for all operations:

```typescript
// MultiVault requires curve ID for all operations
const defaultCurveId = await multiVault.getBondingCurveConfig().defaultCurveId

// Use in all deposit/redeem operations
await multiVault.deposit(receiver, termId, defaultCurveId, minShares, {
  value: assets,
})
```

### Migration Steps

#### Step 1: Update Function Calls

##### Creating Atoms

```typescript
// Before
const atomId = await ethMultiVault.createAtom(atomData, { value: fee });

// After
const atomIds = await multiVault.createAtoms([atomData], [assets], { value: totalValue });
const atomId = atomIds[0];
```

##### Depositing

```typescript
// Before
const shares = await ethMultiVault.depositAtom(receiver, atomId, { value: assets });

// After
const shares = await multiVault.deposit(receiver, termId, curveId, minShares, { value: assets });
```

##### Redeeming

```typescript
// Before
const assets = await ethMultiVault.redeemAtom(shares, receiver, atomId);

// After
const assets = await multiVault.redeem(receiver, termId, curveId, shares, minAssets);
```

## 3. SDK Package Changes (`@0xintuition/sdk`)

### API Function Renaming

**Before:**

```typescript

const atomData = await getAtom('124862')
const tripleData = await getTriple('54670')
```

**After:**

```typescript

const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21',
const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6',
```

### Triple Creation Parameter Changes

**Before:**

```typescript

const triple = await createTripleStatement(config, {
  args: [subjectVaultId, predicateVaultId, objectVaultId],
  depositAmount: 1000000000000000000n, // Optional
})
```

**After:**

```typescript

const triple = await createTripleStatement(config, {
  args: [
    [subjectVaultId],
    [predicateVaultId],
    [objectVaultId],
    [1000000000000000000n],
  ],
  value: 1000000000000000000n, // Required
})
```

## 4. Configuration Changes

### EthMultiVault Config

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomUriMaxLength;
    uint256 decimalPrecision;
    uint256 minDelay;
}
```

### MultiVault Config

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;      // New
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength; // Renamed
    uint256 decimalPrecision;
    // minDelay removed
}
```

## 5. Removed Functions

The following functions have been removed and replaced:

### Protocol Package

- `createAtom` â†’ `createAtoms`
- `createTriple` â†’ `createTriples`
- `batchCreateAtom` â†’ `createAtoms`
- `batchCreateTriple` â†’ `createTriples`
- `depositAtom` / `depositTriple` â†’ `deposit`
- `redeemAtom` / `redeemTriple` â†’ `redeem`
- `createAtomCalculateBaseCost` â†’ `getAtomCost`
- `createTripleCalculateBaseCost` â†’ `getTripleCost`
- All curve-specific functions â†’ `depositBatch` / `redeemBatch`
- `atoms-by-hash.ts` file completely removed

### SDK Package

- `createThing` â†’ `createAtomFromThing`
- `createEthereumAccount` â†’ `createAtomFromEthereumAccount`
- `getEthMultiVaultAddress` â†’ `getMultiVaultAddressFromChainId`
- `getAtom` â†’ `getAtomDetails`
- `getTriple` â†’ `getTripleDetails`

## 6. Breaking Changes Summary

1. **All IDs changed from `uint256` to `bytes32`**
2. **Curve ID parameter required for most operations**
3. **Batch functions have different signatures**
4. **Event structures updated**
5. **Some functions renamed or merged**
6. **New slippage protection with `minShares`/`minAssets` parameters**

## 7. Best Practices

1. **Always use the default curve ID** unless you have specific bonding curve requirements
2. **Implement proper slippage protection** with min/max parameters
3. **Handle the new epoch system** for utilization tracking
4. **Update your event listeners** to match new event structures
5. **Use preview functions** to estimate outcomes before transactions

## ðŸ“ Summary

This major version update consolidates and simplifies the API while adding new functionality. The main changes are:

- **Contract Migration**: `EthMultiVault` â†’ `MultiVault` with architectural improvements
- **ID System**: Changed from `uint256` to `bytes32` for all term identifiers
- **Bonding Curves**: Full integration requiring curve IDs for all operations
- **Singular â†’ Plural**: Functions now support batch operations by default
- **Unified APIs**: Simplified deposit/redeem functions for all vault types
- **Enhanced Features**: New utilization tracking, epoch system, and preview functions
- **Event Updates**: Improved event parsing with new event structures

Take your time with the migration and test thoroughly. The new API is more powerful and consistent, providing a better developer experience.

---

# 

Source: https://docs.intuition.systems/guides/developer-tools/sdks/overview


# Intuition SDK Guide

The Intuition SDK is your toolkit for building with the Intuition Protocol. Think of it as a friendly bridge between your application and Intuition's powerful knowledge graph system.

## What does the SDK do?

The SDK makes it easy to:

- **Create and manage semantic data** - Build atoms (individual pieces of information) and triples (relationships between atoms)
- **Interact with the blockchain** - Handle deposits, withdrawals, and smart contract interactions seamlessly
- **Query the knowledge graph** - Search and retrieve data from Intuition's decentralized database
- **Build user-friendly apps** - Focus on your app's features while the SDK handles the complex protocol interactions

Whether you're building a social platform, a data verification tool, or any application that needs to work with verifiable, decentralized information, the SDK provides the building blocks you need.

The Intuition SDK simplifies development with the Intuition backend systems, providing a clean TypeScript interface for creating and managing Atoms and Triples with ease.

## Installation

### From NPM Registry

Install the SDK using your preferred package manager:

```bash
npm install @0xintuition/sdk
```

```bash
pnpm install @0xintuition/sdk
```

```bash
bun install @0xintuition/sdk
```

### Local Development

For local development or testing with a custom build:

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
npm install

# Build the package
npm run build

# Link locally
npm link

# In your project
npm link @0xintuition/sdk
```

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
pnpm install

# Build the package
pnpm build

# Link locally
pnpm link --global

# In your project
pnpm link --global @0xintuition/sdk
```

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
bun install

# Build the package
bun run build

# Link locally
bun link

# In your project
bun link @0xintuition/sdk
```

## Prerequisites

The SDK requires **viem@2.x.x** to execute reads and writes. Make sure you have it installed:

```bash
npm install viem@^2.0.0
```

## Setup

### Basic Client Configuration

Set up your viem clients for interacting with the Intuition protocol:

```typescript
  getMultiVaultAddressFromChainId,
  intuitionTestnet,
} from '@0xintuition/protocol'

  createPublicClient,
  createWalletClient,
  http,
  privateKeyToAccount,
} from 'viem'

  chain: intuitionTestnet,
  transport: http(),
})

const account = privateKeyToAccount(
  '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  chain: intuitionTestnet,
  transport: http(),
  account: account,
})
```

## Supported Networks

The Intuition SDK supports multiple networks:

| Network | Chain ID | Type | Status |
|---------|----------|------|--------|
| Intuition Network | 1155 | Mainnet | âœ… Production |
| Intuition Network Testnet | 13579 | Testnet | âœ… Development |
| Base Mainnet | 8453 | Mainnet | âœ… Production |
| Base Sepolia | 84532 | Testnet | âœ… Development |
| Ethereum Mainnet | 1 | Mainnet | âœ… Production |
| Sepolia | 11155111 | Testnet | âœ… Development |
| Arbitrum One | 42161 | Mainnet | âœ… Production |
| Arbitrum Sepolia | 421614 | Testnet | âœ… Development |

The SDK automatically detects the network and uses the appropriate contract addresses via `getEthMultiVaultAddressFromChainId()`.

**Note**: The Intuition L3 network (Caldera rollup) is currently in development. Access the [Hub](https://intuition-testnet.hub.caldera.xyz/) for L3 network development tools and testing.

## Reading Data

### Fetching Atoms and Triples

```typescript

// Get atom data by ID
const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21',

// Get triple data by ID
const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6',

## Creating Triples

Triples connect three atoms in a subject-predicate-object relationship:

```typescript

// Create three atoms first
const atom1 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom1',
const atom2 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom2',
const atom3 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom3',

// Create a triple statement connecting the three atoms
const triple = await createTripleStatement(
  { walletClient, publicClient, address },
  {
    args: [atom1.state.termId, atom2.state.termId, atom3.state.termId],
    value: 1000000000000000000n, // 1 ETH in wei for deposit
  },
```

## Creating Atoms

### Create Atom from String

The simplest way to create an atom with a text label:

```typescript

const data = await createAtomFromString(
  { walletClient, publicClient, address },
  'is great',
```

### Create Atom from IPFS Upload

Create an atom by uploading metadata to IPFS:

```typescript

const data = await createAtomFromIpfsUpload(
  {
    walletClient,
    publicClient,
    address,
```

### Create a Thing

Create an atom representing a structured object:

```typescript

const data = await createAtomFromThing(
  { walletClient, publicClient, address },
  {
```

### Create an Ethereum Account

Create an atom representing an Ethereum account:

```typescript

const data = await createAtomFromEthereumAccount(
  { walletClient, publicClient, address },
  {
```

### Batch Operations

The SDK provides efficient batch operations for creating multiple atoms at once:

#### Batch Create Atoms from IPFS URIs

```typescript
  batchCreateAtomsFromIpfsUris,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromIpfsUris(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    'ipfs://bafkreib7534cszxn2c6qwoviv43sqh244yfrxomjbealjdwntd6a7atq6u',
    'ipfs://bafkreicq2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q',
  ],
```

#### Batch Create Atoms from Smart Contracts

```typescript
  batchCreateAtomsFromSmartContracts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromSmartContracts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    '0xA0b86a33E6441b8c4C8C8C8C8C8C8C8C8C8C8C8C',
    '0xB1c97a44E7551b9d5C8C8C8C8C8C8C8C8C8C8C8C8C',
  ],
```

#### Batch Create Atoms from Ethereum Accounts

```typescript
  batchCreateAtomsFromEthereumAccounts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromEthereumAccounts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', chainId: 1 },
    { address: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6', chainId: 1 },
  ],
```

#### Batch Create Atoms from Things

```typescript
  batchCreateAtomsFromThings,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromThings(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    {
```

#### Batch Create Triple Statements

```typescript
  batchCreateTripleStatements,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateTripleStatements(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { args: [atom1.state.vaultId, atom2.state.vaultId, atom3.state.vaultId] },
    { args: [atom4.state.vaultId, atom5.state.vaultId, atom6.state.vaultId] },
  ],
```

## Response Data Structure

After successfully creating a new Atom, the SDK returns a data object containing:

```typescript
const data: {
    uri: string
    transactionHash: `0x${string}`;
    state: {
        creator: Address,
        termId: Hex,
        atomData: Hex,
        atomWallet: Address
    };
}
```

## React Integration Example

Here's a complete React component that creates an atom from structured metadata:

```tsx

  createAtomFromThing,
  getMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

type IntuitionButton = React.HTMLAttributes

const IntuitionButton = ({ children, className }: IntuitionButton) => {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()

  const handleClick = async () => {
    const multiVaultAddress = getMultiVaultAddressFromChainId(chainId)
    const data = await createAtomFromThing(
      { walletClient, publicClient, address: multiVaultAddress },
      {
  }

}

```

## Development

### Building the SDK

```bash
npm run build
```

```bash
pnpm build
```

```bash
bun run build
```

### Running Tests

```bash
npm test
```

```bash
pnpm test
```

```bash
bun test
```

## Resources

- [NPMJS/Intuition](https://www.npmjs.com/package/@0xintuition/sdk)
- [Github Repo](https://github.com/0xIntuition/intuition-ts/tree/main/packages/sdk)
- [Intuition Discord](https://discord.gg/intuition)

## Contributing

Contributions are welcome! Please see the main repository for more information on how to contribute.

---

# 

Source: https://docs.intuition.systems/guides/economics/overview


# Economics

Intuition transforms every digital interaction into an economic opportunity. Every like, comment, review, connection, and action you take across the web becomes an economic bet, allowing you to buy meaningful ownership in any piece of data.

## $TRUST Token

The native token $TRUST enables users to:
- Accumulate stake in the information you believe in
- Retain true ownership of what you create
- Earn as that data gains traction and value across the network

## Trust Whitepaper

For a comprehensive understanding of Intuition's economic model and theoretical foundations, read our [Trust Whitepaper](https://cdn.prod.website-files.com/65cdf366e68587fd384547f0/68316bdfe42a265d3dc45498_trust-whitepaper.pdf).

## $TRUST Tokenomics

Learn about the $TRUST token economics, distribution, and utility in our detailed [$TRUST tokenomics overview](https://app.forgd.com/share/trust/9837b0d0-e11f-410f-80e6-62a0b6fe13ff/public).

---

# 

Source: https://docs.intuition.systems/guides/introduction


    The Trust Protocol
  
    Building the world's first open and semantic knowledge graph. A universal data layer that enables trustful interactions at scale.

## The Vision

Intuition is building the world's first **open and semantic token-curated knowledge graph**, decoupling identities, data, and algorithms from the application layer. This universal and permissionless data lake opens the door to a new pillar of the decentralized web - a **trustful interaction layer**.

Decoupled from applications, accessible everywhere

Verifiable facts and subjective opinions coexist

Rich, queryable knowledge graph with meaning

## Where Trustful Interaction Meets Trustless Code

At its core, Intuition is building a **knowledge and social graph** that integrates incentive-driven mechanisms, decentralized identifiers, and semantic data structures to lay the foundation for a trustworthy internet.

With the introduction of a few novel primitives, Intuition unlocks the ability to **operationalize information and trust** at an unprecedented scale.

The system provides applications and their users easy access to a **semantically rich dataset** about everything and anything, where both objective facts and subjective opinions can coexist and be validated.

A Semantic Web of Trust

We believe in a future where **information** is not just stored but made **verifiable**, wrapped in a semantic embrace, mapped by a directed graph of state changes captured on an immutable ledger.

## Current Information System Challenges

Intuition offers a new model for trust and identity to address the limitations of the current paradigm:

Verification & Provenance

Bias & Inequality

Accountability

Privacy & Security

Misaligned Incentives

Fragmentation

Intuition leverages **game theoretic cryptoeconomics** to solve these problems at scale, fostering a truly interoperable web - one more akin to Tim Berners-Lee's vision for the **Semantic Web**.

## Explore Introduction

Learn about Intuition's core concepts, architecture, and economic model. Understand how the system works and what makes it unique.
Architecture â€¢ Economics â€¢ Vision

Learn about the challenges Intuition addresses and our unique approach to building a decentralized knowledge graph.
Problems â€¢ Solutions â€¢ Vision

Dive deep into the fundamental building blocks: Atoms, Triples, and Signal. Learn how these primitives work together to create structured, semantic data.
Atoms â€¢ Triples â€¢ Signals

Master the essential terminology and concepts that form the foundation of the Intuition ecosystem and knowledge graph.
Glossary â€¢ Concepts â€¢ Definitions


---

# 

Source: https://docs.intuition.systems/guides/introduction/overview


# Overview

## Intuition at a Glance

Intuition is a decentralized system that makes attestations viable as a meta for digital expression. 

A universal language for signed data.

Instead of information living as unstructured, siloed, minimally-attributable data in Web2 platforms, Intuition turns information into verifiable, tokenized, and portable objects that can flow across apps, chains, and agents.

---

## The Three Pillars of Intuition

  Decentralized Identifiers (DIDs): Anyone can create a new decentralized identifier â€” for a person, concept, object, or anything else â€” permissionlessly.
  Economics Drive Convergence: While identifiers can be created freely, bonding curves and token incentives encourage communities to converge on shared canonical Atoms, so that concepts can be referenced consistently and universally across the internet.
  Consensus on Standards: Intuition leverages cryptoeconomic consensus mechanisms for the "state of the state" of its ledger â€” incentivizing convergence on consensus data schemas, structures, and relationships. This ensures that as the knowledge graph grows, it becomes more interoperable, not less.

The Protocol is the grammar of programmable attestations â€” a universal language for expressing who said what, about what, at what time, and with what conviction.

The Subnet turns raw attestations into actionable intelligence, powering AI agents, decentralized apps, and enterprise systems.

---

## Core Primitives

Unique, persistent identifiers for any concept or entity â€” person, object, idea, or anything else. Think of them as the "nodes" in the knowledge graph, or the 'words' of the Intuition dictionary.

Claims expressed in subject-predicate-object format, creating the relationships and semantic layer of the knowledge graph. The 'sentences' of the Intuition system, with words composed together into higher-order expressions.

Tokenized stakes that weight attestations with economic confidence, incentivizing the creation of many-to-one attestations that are better capable of accommodating subjective information.

---

## How It Fits Together

Together, they form the rails of a programmable knowledge economy where:

---

## Why This Matters for Developers

Building on Intuition means you don't have to reinvent trust, identity, or data models from scratch.
Attestations and identifiers give you:

ðŸ’¾ Memory

Agents and apps don't start from zero; they inherit context.

ðŸ” Trust

Every claim is signed, staked, and auditable.

ðŸŽ¯ Alignment

Incentives built into the data layer itself.

ðŸŒ Portability

Your users' context and reputation follow them across apps.

ðŸ”Œ Interoperability

Shared identifiers and standards mean your app plugs into a larger ecosystem by default.

Intuition provides the foundation. You build the apps, agents, and experiences that bring it to life.


---

# 

Source: https://docs.intuition.systems/guides/introduction/the-economics/bonding-curves


# Bonding Curves

Bonding curves define how the price of an asset changes based on supply and demand. In the Intuition Protocol, they allow vaults to dynamically price semantic assets like atoms and triples.

A bonding curve is a pricing mechanism â€” it determines how much ETH a user pays (or gets back) when depositing to or redeeming from a vault. This lets projects:

- **Incentivize early participation** with cheaper entry prices.
- **Control supply** with rising costs as more tokens are minted.
- **Align economics** with data value or staking behavior.

Intuition uses bonding curves in the EthMultiVault system to handle deposits and redemptions for both atoms (individual semantic claims) and triples (subjectâ€“predicateâ€“object sets).

## Real-World Use Cases

| Use Case | How Bonding Curves Help |
|----------|-------------------------|
| **Data Markets** | Pay to mint assertions on-chain; rising cost controls spam. |
| **Staking Derivatives** | Price increases with TVL, modeling yield or scarcity. |
| **Protocol Governance** | Curves can align incentives for governance participation. |
| **Custom Economies** | Plug in your own math logic via custom curves. |

## Design Philosophy

Bonding curves in Intuition Protocol are modular by design:

- **Registry-based routing**: Vaults remain clean and upgrade-safe.
- **Symmetrical math API**: All curves implement the same interface.
- **Upgradeable curves**: Developers can ship custom curves anytime â€” no need to upgrade the vault.

In upcoming versions (V2), we'll simplify things even further by removing suffixes like `depositAtomCurve`, replacing them with a unified API keyed by `curveId`.

## How Bonding Curves Fit into the Protocol

Here's the basic architecture:

```
User / dApp
   â”‚
   â–¼
EthMultiVault
   â”œâ”€ Standard paths (Linear math inline)
   â””â”€ Curve-specific paths
        â”‚
        â–¼
BondingCurveRegistry â”€â”€â†’ BaseCurve (Linear, OffsetProgressive, custom...)
```

- **EthMultiVault** handles deposits/redemptions.
- If a non-linear curve is specified, it routes to the **BondingCurveRegistry**.
- The registry proxies math to the appropriate curve contract using a `curveId`.

## Curve Types

### Linear Curve 
#### (curveId = 1)

A simple, pro-rata pricing model where every deposit gets the same rate:

```solidity
price = totalAssets / totalShares;
```

This is the default math embedded directly into EthMultiVault, but we include a separate LinearCurve contract for compatibility and future flexibility.

:::tip
Great for simple, predictable token issuance.
:::

### Offset Progressive Curve 
#### (curveId = 4)

A more dynamic curve where price increases linearly based on total supply:

```math
P(s) = m âˆ— (s + offset)
```

Mint cost is the area under the curve, meaning early deposits are cheaper:

```math
Cost = (m/2) âˆ— [(sâ‚‚ + offset)Â² âˆ’ (sâ‚ + offset)Â²]
```

Redemption returns are also curve-aware:

```math
Return = (m/2) âˆ— [2 âˆ— (s + offset) âˆ— r âˆ’ rÂ²]
```

Where:
```math
- **s** = current shares
- **r** = shares being redeemed
```

:::tip 
Ideal for data markets and staking derivatives â€” you can reward early supporters and make each additional share more expensive.
:::

## Interactive Demo

Try out different bonding curve types and see how they affect pricing:

## Code Examples

### Deposit Using a Curve

Deposit ETH into a vault with the Offset Progressive curve:

```solidity
EthMultiVault.depositAtomCurve{value: amountETH}(
    msg.sender,   // receiver of shares
    atomId,       // which atom to deposit into
    4             // curveId for OffsetProgressive
);
```

### Preview Deposit in Frontend

Estimate how many shares a user would get before committing ETH:

```cpp
uint256 shares = vault.previewDepositCurve(amountETH, atomId, 4);
```

You can also check the current price:

```cpp
uint256 price = registry.currentPrice(totalShares, 4);
```

### Register a New Curve (Admin Only)

If you've written your own curve, you can add it like this:

```cpp
uint256 curveId = registry.addBondingCurve(address(myCustomCurve));
vault.setBondingCurveConfig(address(registry), curveId); // optional
```

You only need to implement the BaseCurve interface to plug in.

## Share Display and User Experience

### Understanding Share Values

Intuition displays share values in a user-friendly format to make ownership easier to understand. The Portal frontend shows one "Share" as 1/100,000th of the 1 ETH-equivalent raw value recorded in smart contracts.

**Why this matters:**
- **Simpler numbers**: Users see whole numbers instead of lengthy decimals
- **Familiar concept**: Similar to how Bitcoin (Satoshis) and Ethereum (Wei) work
- **Clear ownership**: Easier to understand your position size

**Example:**
- Smart contract: 1,000,000 raw units
- Portal display: 10 shares
- Each share = 100,000 raw units

### No Impact on Positions

:::info
**Important**: This is purely a display change. Your actual positions and the underlying smart contracts remain unchanged.
:::

## Summary

- Bonding curves are a flexible pricing tool for atoms and triples.
- Intuition supports multiple curve types, each with their own pricing logic.
- You can preview, extend, or customize bonding behavior with minimal friction.
- The system is secure, upgrade-safe, and open to new economic designs.
- Share display is optimized for user experience while preserving contract integrity.

---

*This section will be expanded with detailed mathematical formulas, implementation guides, and real-world examples.* 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-economics


# The Economics

Intuition is built on the idea that information deserves its own decentralized distribution and financial rails. 

Just as blockchains turned money into programmable assets, Intuition turns information into tokenized, ownable, and composable units that anyone can create and monetize in.

At the core are Atoms (entities) and Triples (relationships). As users publish, curate, and stake on these objects, they generate a token-curated knowledge graph where ownership weights are represented by positions in $TRUST â€” the native token of the Intuition Network and Protocol.

The goal is not to tokenize data just for the sake of a token. The economics of Intuition are designed to:

---

## Example Flow: How the Incentives Work

### 1. Expression
**Alice creates a new Atom: a DID for Tesla, Inc.**
- She publishes an attestation: `[Tesla] â€“ [foundedBy] â€“ [Elon Musk]`, staking $TRUST behind it
- Because she was first, she captures the early-mover rewards

### 2. Convergence
**Bob considers creating his own identifier for Tesla**
- But Alice's Atom already has traction, with value flowing into its bonding curve
- The economics reward Bob for using the existing canonical DID instead of fragmenting the graph

### 3. Consensus on Standards
**Carol proposes that `foundedBy` and `headquarteredIn` should be standard predicates for corporate entities**
- The network's incentive structure rewards attestations that align with these schemas
- As more users adopt them, `foundedBy` becomes a consensus-backed data standard

### 4. Ongoing Rewards
**As developers and AI agents query Tesla-related data, fees flow back to the identifiers and attestations that power those queries**
- Alice, Bob, and Carol all share in the economic upside of having built durable, widely used pieces of the graph

---

## Reward Dynamics

To maximize engagement and data quality, the system favors contributions that are:

First-mover advantages for valuable identifiers and attestations

Network effects amplify rewards for commonly referenced knowledge

Stronger incentives for adopting schemas and canonical identifiers

Forward-looking value assessment ensures durable contributions

## Fees & Rewards

Every interaction with the knowledge graph involves two types of fees:
- **Gas fees**: Network transaction fees paid to the maintaners of the Intuition Network for processing transactions
- **Protocol fees**: Fees that flow through the Intuition protocol to reward data contributors and maintain the ecosystem

Because Intuition breaks data down into discrete, tokenized units, the system is aware of 'who owns what data' at any given point in time. Because of this, the system is able to programmatically flow value â€” such as these Fees â€” through data as that data is interacted with.

When users interact with or create data, these combined fees support both network operations and data contributor rewards through the following mechanisms:

To purchase tokens of an Atom or Triple, users deposit $TRUST (the native token of the Intuition Network and Protocol) into the Vault of the respective Atom or Triple. You pay a protocol fee proportional to your deposit amount. In return, you receive tokens of that specific Atom or Triple, entitling you to rewards generated by that data point proportional to your ownership percentage.

When interacting with data, part of the protocol fee is distributed to all existing shareholders (prior contributors). This encourages early, meaningful contributions, as users who add valuable data will continue to be rewarded over time through protocol fees, while gas fees go to network validators.

A of the protocol fee is paid to the Intuition protocol for platform maintenance and development. This ensures Intuition can be self-sustaining and exist in perpetuity, without risk of shutting down.

## Reducing Fragmentation

In many systems, user-generated tags and classifications, known as **folksonomies**, can lead to fragmented and disorganized data. Different people might use different labels for the same thing, making it hard to gather or analyze information effectively. Intuition solves this by encouraging users to converge on a common set of identifiers.

Intuition acts as a consensus mechanism not just for identifiers, but also for data structuresâ€”it is essentially a consensus mechanism for the 'state of the state' of decentralized systems, where participants are economically incentivized to converge on consensus identifiers and data structures.

Intuition uses a **market-driven consensus** model inspired by blockchain technology. In systems like Proof of Work (PoW) and Proof of Stake (PoS), participants are economically incentivized to act in ways that benefit the network. Users are motivated to use established and widely recognized identifiers because doing so increases their potential rewards from future interactions.

### Incentive Driven Consensus

As users interact with and endorse certain identifiers, Intuition naturally creates a **token-curated graph (TCG)**â€”a graph of popular, widely used identifiers and data structures. These identifiers become the standard, and the system self-regulates based on user interactions and rewards, ensuring only the most valuable data structures rise to prominence.

This model mirrors the behavior of prediction markets and automated market makers (AMMs), where participants align with the most trusted and valuable options due to market incentives.

Intuition also applies the **Keynesian Beauty Contest** concept, where users are rewarded for choosing options they believe others will choose. This drives consensus on data structures and identifiers, as users are motivated to align their actions with the choices of the broader community, ensuring the most popular and widely accepted options become the standard.

## Early Adopter Advantage

Users who are quick to interact with new dataâ€”whether it's creating or endorsing an identity or claimâ€”are rewarded more as the data gains traction. This system encourages users to contribute and adopt important data early, creating a race to establish high-quality, valuable information that others will rely on.

The earlier you participate, the more rewards you can earn over time as others use the same data. Early contributors receive ongoing distributions from all future interactions with their contributed data.

## Dynamic Pricing with Bonding Curves

Intuition uses bonding curves to create dynamic pricing mechanisms that automatically adjust based on supply and demand. This sophisticated approach provides multiple benefits:

Liquidity is provided automatically through mathematical curves, eliminating the need for traditional order books or manual market makers.

Early participants get better prices, encouraging adoption and rewarding pioneers who identify valuable data structures before they become widely recognized.

Prices increase as more tokens are minted, preventing inflation while ensuring scarcity creates value for established data structures.

Pricing automatically reflects the value of underlying assets, ensuring market mechanisms accurately represent the true worth of data and relationships.

## Summary

By integrating these economic principles, Intuition creates a dynamic, decentralized ecosystem where users are continuously rewarded for valuable contributions, and the community naturally converges on high-quality, standardized data structures.
This economic framework ensures sustainable growth while maintaining the platform's security and reliability, creating a virtuous cycle of value creation and distribution that benefits all participants in the Intuition ecosystem.

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/atoms


# Atoms

A system facilitating the arrival at social consensus around globally persistent canonical identifiers for all things demands that these identifiers possess a few key attributes.

These identifiers should be decentralized identifiers, providing unique, secure, and verifiable identification without any reliance on a central authority.

These identifiers should have a sufficient amount of associated data to ensure precise referencing of specific entities, concepts, or pieces of information.

These identifiers must have some agent-centric state that is capable of tracking the usage of the identifier across contexts.

## The Atom Solution

To solve for these requirements, the concepts of Atoms emerge as the foundation of the Intuition framework, representing the most fundamental units of data. These units can range from a single word to a complex concept, serving as discrete, manageable, and referenceable pieces of information that facilitate seamless data integration and manipulation across the web.

Start to reference data universally across the web.
Grant users equity in data as they signal its relevancy through usage.
Reward users for signaling the relevancy of data, encouraging active participation.

Each Atom is made universally referenceable through a decentralized identifier. This approach ensures that every Atom is uniquely identifiable and can be consistently referenced across the web, maintaining data integrity and meaning regardless of the system or context.

## Decentralized Identifiers (DIDs)

{`// An example DID

did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736

// An example DID Document

{
    "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
    "verificationMethod": [
        {
            "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller",
            "type": "EcdsaSecp256k1RecoveryMethod2020",
            "controller": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
            "blockchainAccountId": "eip155:1:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736"
        }
    ],
    "authentication": [
        "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller"
    ],
    "assertionMethod": [
        "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller"
    ],
    "@context": [
        "https://www.w3.org/ns/did/v1",
        "https://w3id.org/security/suites/secp256k1recovery-2020/v2",
        "https://w3id.org/security/v3-unstable"
    ]
}`}

## Data Requirements

To ensure reliable referencing of entities, concepts, or data within an Atom, each Atom must include at least minimal corresponding data. This data can be of any type, stored anywhere, and presented in any format.

Use a Verifiable Data Registry to strengthen data usability through guarantees around immutability, availability, liveness, and persistence.
Adhere to supported data structures and schemas for better interoperability and reliability.
For mutable data, include a timestamp to ensure future references understand exactly what the data represented at the moment of attestation.

The uniqueness of each Atom is enforced by hashing its underlying data, preventing duplicate Atoms for the same piece of data. This approach allows Atoms to segment data into discrete, manageable units that can be easily combined and reused across diverse contexts and applications.

## Atom Ownership and Token Curated Registries

Given the permissionless nature of the system, multiple Atoms may be representative of the same concept. To foster consensus on high-quality Atoms and establish canonical identifiers for all things, Intuition employs the concept of a Token Curated Registry (TCR).

Users gain fractional ownership over the Atoms they interact with and receive a portion of the interaction fees each respective Atom generates.
This model incentivizes engagement with popular Atoms, encouraging active participation in the ecosystem.
A TCR emerges, ranking Atoms based on their relevance using metrics such as an Atom's Total Value Locked (TVL).

As users increasingly interact with these Atoms, a TCR emerges, ranking Atoms based on their relevance using metrics such as an Atom's Total Value Locked (TVL). This mechanism facilitates ecosystem convergence on and easy discoverability of the most valuable and widely accepted Atoms/identifiers representing each concept.

## Next Steps

Now that you understand Atoms, explore:

- [Triples](/guides/introduction/the-primitives/fundamentals/triples) - Learn how Atoms combine to form relationships
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how users interact with Atoms
- [Structuring Atoms](/guides/introduction/the-primitives/structuring/atoms) - Advanced techniques for working with Atoms 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/fees-rewards


# Fees & Rewards

In the Intuition system, interactions incur a fee similar to the gas costs in blockchain transactions. These fees serve critical roles in maintaining the system's integrity, incentivizing meaningful contributions, and fostering the creation of high-quality, structured data.

## Purpose of Fees in Intuition

### Preventing Abuse and Attacks

Decentralized and permissionless systems face risks such as Sybil and denial-of-service (DoS) attacks. Intuition mitigates these risks through an economic model that introduces fees for data creation.

**Disincentive Against Abuse**: Fees deter malicious activity by imposing a cost on system misuse.

**Network Resilience**: Any attacks inadvertently benefit the system, as fees are still paid, much like Ethereum benefits from transaction fees, even in non-productive use cases.

This mechanism ensures the ecosystem remains robust and sustainable, even in the face of potential misuse.

### Encouraging Active Participation

Merely providing infrastructure for generating verifiable data is insufficient to motivate meaningful contributions.

**Historical Challenges**: Platforms like Amazon, Yelp, and Wikipedia in Web2 face similar participation issues, where most users refrain from contributing reviews or endorsements.

**Economic Incentives**: Intuition mirrors the blockchain model of block rewards, providing tangible incentives to encourage users to create coherent and valuable data.

### Promoting High-Quality Data

The global proliferation of data has led to an overwhelming amount of low-quality, redundant, or irrelevant information.

**Quality Over Quantity**: Intuition shifts the focus from producing more data to generating reliable, actionable insights.

**Economic Mechanisms**: Fees discourage the creation of irrelevant data while rewarding high-quality contributions.

By implementing this model, contributors are incentivized to create data that meets standards of relevance and accuracy, reducing the prevalence of "junk data."

### Establishing Standards Through Incentives

Creating standards in data structures and schemas has traditionally been challenging, often described as "standards hell."

**Expanding Blockchain Principles**: Intuition applies the concept of financial rewards for distributed consensusâ€”proven in blockchain ecosystemsâ€”to social consensus and global coordination.

**Use Cases**: These principles extend to data structures, schemas, formats, and canonical identifiers.

## Fee Allocation in Intuition

Intuition allocates fees in two key ways:

1. **Granting Ownership in Data**  
A portion of the fee grants users ownership of the data they interact with, promoting responsibility and meaningful engagement.

2. **Rewarding Data Owners**  
Another portion is distributed to existing data owners, incentivizing the creation and maintenance of valuable data.

## Incentivizing Fractal Data Structures

Intuition's data modelâ€”built on Atoms, Triples, and Signalâ€”allows for programmatic value distribution throughout the system.

Consider a user who wishes to create a new data entry stating that they like a YouTube video. The user must pay a fee to create this data which rewards previous owners of related data. If the user wishes to obtain ownership in the statement, they must make an initial deposit.

Other users who agree with this statement can also deposit to signal their agreement, which pays existing depositors on the Triple and underlying Atoms and increases the share price of the Triple. In other words, future depositors reinforce the validity and increase the value of the underlying data.

**Creating Data**: A user pays a fee to state they like a YouTube video.  
- The Triple creation fee rewards prior owners of related data.  
- The initial deposit grants ownership of the statement.

**Reinforcing Data**: Other users can also stake on the Triple to explicitly agree with the statement, reinforcing its validity and increasing its value.

This model ensures high-quality, relevant data remains prominent while incentivizing accuracy and meaningful contributions.

## Aligning Incentives with Data Structures

Intuition's economic model motivates users to interact with data they believe will gain engagement. The explicit structure of data encourages users to converge on:

* **Entities and Concepts**: Consensus on key data points.
* **Effective References**: Agreement on the best ways to describe and structure data.

This drives fractal consensus, ensuring scalability from individual Atoms to complex nested Triples.

## Promoting a Self-Regulating Ecosystem

By integrating economic incentives, Intuition creates a self-regulating system that achieves:

* **System Security**: Fees deter attacks and ensure robustness.
* **Meaningful Contributions**: Rewards motivate high-quality data creation.
* **Structured Consensus**: Users are incentivized to align on effective data representations.

By integrating these economic principles, Intuition not only secures the system against malicious attacks but also promotes a healthy, self-regulating ecosystem where users are rewarded for their contributions to the integrity and value of the data.

## Next Steps

Now that you understand Fees & Rewards, explore:

- [State Interpretations](/guides/introduction/the-primitives/fundamentals/state-interpretations) - Learn how the system state is interpreted
- [Calculating Rewards](/guides/introduction/the-primitives/structuring/calculating-rewards) - Advanced techniques for reward calculation
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how users interact with the economic system 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals


# Fundamentals

Master the core concepts that form the foundation of the Intuition system. These fundamentals provide the essential knowledge needed to understand and work with Atoms, Triples, Signal, and the economic mechanisms that drive the ecosystem.

## Explore Fundamentals

Learn about the atomic units of knowledge in Intuition - unique, persistent identifiers for all things in the digital universe.

Discover how Triples create relationships between Atoms, forming the semantic structure of the knowledge graph.

Understand how Signal expresses intent, belief, and support within the Intuition ecosystem.

Explore the economic mechanisms that incentivize quality contributions and maintain system integrity.

Discover how Intuition's state can be interpreted in countless ways, avoiding "truth lock-in" while enabling flexible analysis.

See how Intuition primitives work together in real-world scenarios with practical examples and use cases.

## Recommended Reading Order

For the best learning experience, we recommend following this sequence:

1. **Atoms** - Start with the fundamental building blocks
2. **Triples** - Learn how relationships are formed
3. **Signal** - Understand how trust and belief are expressed
4. **Fees & Rewards** - Explore the economic incentives
5. **State Interpretations** - See how the system can be interpreted
6. **Intuition in Practice** - Apply your knowledge to real scenarios

## Next Steps

After mastering the fundamentals, explore:

- **[Structuring](/docs/introduction/the-primitives/structuring)** - Advanced techniques for organizing data
- **[Developer Tools](/docs/developer-tools)** - Practical tools for building with Intuition
- **[Use Cases](/docs/use-cases)** - Real-world applications and examples 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/intuition-in-practice


# In Practice

The introduction of Intuition's core primitives lays a robust foundation for constructing a system that fosters a trustful interaction layer for the decentralized web. These seemingly basic primitives enable a wide range of powerful functionalities, transforming how we manage identities, data, and trust online.

To illustrate this, consider the experience of buying a product on Amazon. With Intuition's primitives, this process can be reimagined in a decentralized, trustless manner:

## Atoms and Triples

Every user, product, review, and transaction can be represented as discrete objects (Atoms) and linked through relationships (Triples). For instance, a Triple could link a product (Atom) to a review (Atom) through a relationship like "hasReview."

did:ethr:mainnet:0x...product123
did:ethr:mainnet:0x...review456
[Product] [hasReview] [Review]

## Signal

Each review can be evaluated for credibility using the Signal primitive. Reviews and Signals from verified purchasers or highly reputable users can carry more weight, helping users discern trustworthy feedback from potentially fraudulent reviews.

Higher signal weight due to confirmed purchase
Enhanced credibility based on historical accuracy
Automatic flagging of suspicious review patterns

## Fees, Economics, and Incentives

Users are encouraged to express themselves, and reviewers are incentivized to provide honest and detailed feedback. Users earn money for their valuable data contributions, and their reputation becomes cross-contextual, increasing its significance beyond a single platform.

For example, a user's status as a trusted reviewer on Amazon could serve as a valuable reputation data point in other contexts, such as securing better loan-to-value ratios in decentralized finance (DeFi) or enhancing the ability to obtain a loan.
Better loan-to-value ratios based on reputation
Reputation follows users across platforms
Earn tokens for valuable contributions

### Portable Social and Trust Graphs

Additionally, users might be more inclined to attest to useful information about products on Amazon because their claims can be easily seen by the people they care about, thanks to portable social and trust graphs. Unlike the current Amazon platform, which lacks a friends list, Intuition allows users to take their singular social graph or a set of trust graphs with them anywhere they go.

Take your social graph anywhere you go
Trusted individual reviews > anonymous reviews
Valuable insights from trusted sources prioritized

## Interpretations

The listing of a product on a marketplace such as Amazon can be represented as a literal interpretation. For instance, adding a product to a marketplace can be as straightforward as creating a Triple like [Product][listedOn] [Amazon].

Expanding on this concept, various stakeholders can publish their interpretations of product reviews:
Aggregate all reviews and provide summary scores
Highlight reviews mentioning safety concerns
Third-party verification and validation

## Algorithms

Users can choose from various algorithms to filter and sort reviews based on their preferences. For instance, an algorithm can prioritize reviews from users with similar purchase histories or highlight reviews that mention specific product features.

Prioritize reviews from users with similar tastes
Highlight reviews mentioning specific features
Weight reviews based on user trust networks

## Reality Tunnel

Users can compose together interpretations and algorithms to create curated 'views' of data, allowing them to find the voices they trust among thousands of anonymous voices.

Combine interpretations and algorithms
Find reliable sources among anonymous reviews
Tailored data presentation based on preferences

## Portable Identity and Data

Identities and data become universal, and can be referenced and integrated anywhere across the web. Users can see a product's aggregated reviews across Amazon, Facebook Marketplace, Craigslist, or eBay, provided the same canonical identifier for the products is used in each context.

See reviews from Amazon, Facebook, Craigslist, eBay
Data persists even if platforms shut down
Maintain control over your digital interactions

## The Decentralized Trust Layer

By integrating these primitives into contexts and interactions that cannot yet be fully 'trustless,' Intuition establishes a decentralized trust layer. This layer allows users to interact with confidence, knowing that the information they rely on is transparent, verifiable, and free from centralized manipulation.

All data is open and verifiable
No single entity controls the data
Users maintain control over their data

For instance, when buying a product, users can access a wealth of credible reviews, filtered and presented according to their preferences, all while maintaining control over their data and identities. By leveraging these tools, we can build a more trustworthy and user-centric digital ecosystem, addressing many of the inherent flaws in the current Web2 trust stack and paving the way for a more decentralized and equitable internet.

## Next Steps

Now that you understand how Intuition primitives work together in practice, explore the [Structuring](/guides/introduction/the-primitives/structuring) section to learn advanced techniques for working with Atoms and Triples in real-world applications. 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/signal


# Signal

Signal, in the context of Intuition, refers to any action or indication that expresses intent, belief, or support. Signals can be classified into three broad categories: explicit signal, implicit signal, and transitive signal. These signals play a crucial role in interpreting user behavior, beliefs, and preferences within the system.

## Types of Signal

A clear, intentional action taken by a user to express support, belief, or intent. These actions are directly observable and often involve a formal mechanism within the system.

Indirect or inferred indications of support, belief, or intent. This signal is not always directly observable and are often deduced from user behavior or patterns.

Trust or belief that is passed along through a network of relationships. This type of signal leverages the idea that trust can be extended through connections.

## Signal in Intuition

Though all systems naturally generate implicit signal, explicit signal in Intuition is expressed in a novel format that enables and incentivizes the creation of many-to-one, non-deterministic attestations.

In Intuition, these semantic statements do not have a single 'issuer' - instead, anyone/anything can signal support or rejection of any existing statement/attestation at any point in time. This decoupling of information from 'who is presently expressing/supporting that information' introduces the ability to accommodate many-to-one attestations, making the data significantly more usable - especially for more complex use cases that involve the concept of transitive signal, such as reputation.

To accomplish this, the Intuition system enables users to maintain positions on Atoms and Triples, interpreting these positions as explicit signal from the user. This mechanism can be implemented using tokens or other accounting systems that have the ability to track user balances over time across an arbitrarily large number of entities.

## Atom Signal

Within the Intuition framework, users signal their belief in the relevance of an Atom by adjusting their balance on that Atom. This balance can be increased or decreased arbitrarily.

Implies no signal, indicating neutral stance on the Atom's relevance.
Indicates a degree of belief in the Atom's relevance, with higher balances showing stronger belief.
May be used to explicitly signal the irrelevance of an Atom (if supported by the implementation).

This mechanism is economically driven: users earn fees proportional to their ownership stake in an Atom as other users interact with it. Thus, if a user deems an Atom relevant, they are incentivized to signal its relevance to receive these rewards.

## Triple Signal

In the Intuition framework, users signal their belief in both the relevance and truthfulness of a Triple by modifying their balance on that Triple. Triple balances can be any integer, allowing for a nuanced expression of belief.

Indicates no signal, neutral stance on the Triple.
Affirms the Triple, indicating it is considered true and relevant.
Signals rejection of the Triple, indicating it is considered false and relevant.

### Example: Trustworthiness Triple

For example, with a Triple asserting "[Vitalik][is] [trustworthy]," users would express their belief in its truthfulness, and the relevancy of this truthfulness, by increasing their balance on the affirmative side of the Triple, or signal disbelief by decreasing their balance into the negative. This mechanism allows for nuanced expressions of trust and belief within the decentralized ecosystem.

This mechanism allows for nuanced expressions of trust and belief within the decentralized ecosystem.

## Advanced Applications

This system enables each "statement" to exist in different states based on who is affirming or rejecting it. To illustrate the power of this approach, consider the example of building a decentralized list of followers.

If a user had 1,000 followers, there would be 1,000 separate "following" claims. Most of this data would be redundant, as the "following Y" part would remain constant across all claims.
A single Triple representing "I am following Y." Users adjust their balances on this statement to express their stance. To see all followers of Y, examine the Triple and identify who has positive balances.

Furthermore, the ability to adjust balances allows for a more nuanced expression of preferences. In the context of a 'follow' functionality, instead of a flat follow list where all followers are treated equally, users could explicitly signal varying levels of interest or endorsement.

By increasing their balance on the followers they value more, users can effectively rank their follow list. This means that someone could show a stronger preference for certain individuals or entities by staking more tokens on their affirmations, creating a dynamic and tiered system of trust and preference.

This not only enhances the granularity of data but also provides richer insights into user preferences and social dynamics within the network.

## Next Steps

Now that you understand Signal, explore:

- [Fees & Rewards](/guides/introduction/the-primitives/fundamentals/fees-rewards) - Learn about the economic incentives
- [Capturing Signal](/guides/introduction/the-primitives/structuring/capturing-signal) - Advanced techniques for signal capture
- [State Interpretations](/guides/introduction/the-primitives/fundamentals/state-interpretations) - Understand how signal is interpreted 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/state-interpretations


# State Interpretations

The Intuition system enables a state that can be interpreted in countless ways, intentionally avoiding the imposition of any single perspective. This design aligns with Intuition's principle of avoiding "truth lock-in" by ensuring the protocol remains neutral regarding state and signal interpretations.

While the system does not enforce specific interpretations, understanding various methods and perspectives for analyzing the system's state is critical for leveraging its full potential.

## Types of Interpretations

Structured, explicit expressions of the state that form the foundation for higher-order applications by defining clear and consistent frameworks for data usage.

Tools for filtering and interpreting data, providing flexibility beyond deterministic logic. Essential for extracting meaningful signal from noise in a permissionless environment.

Modular combinations of literal interpretations, algorithms, and other components that provide tailored perspectives on data.

## Literal Interpretations

Literal interpretations within Intuition provide structured, explicit expressions of the state. These interpretations form the foundation for higher-order applications by defining clear and consistent frameworks for data usage.

A Triple is defined using the Predicate "has access to," where the Subject is a user, and the Object is a resource (e.g., System X).
If [Company's Multisig] attests to the Triple being True, the Subject of the Triple has access to the Object.

This structured interpretation allows implementers to provision access programmatically. For instance, if System Y references the same data, it could use this interpretation to grant access to User A based on their access to System X.

Adjusting loan-to-value ratios based on access control data.
Modifying reputational scores in specific contexts based on access patterns.

By registering and sharing these interpretations as Atoms or Triples, the Intuition system creates a registry of literal interpretations. This recursive system enhances transparency, coordination, and innovation, enabling the development of programmatic languages that leverage the principles of discrete objects and their relationships.

## Algorithms

Algorithms in the Intuition framework serve as tools for filtering and interpreting data, providing flexibility beyond deterministic logic. In a permissionless environment where anyone can make claims about anything, algorithms are essential for extracting meaningful signal from the noise.

Intuition's ecosystem rejects "truth lock-in," recognizing that no single algorithm suits all needs. Instead, it promotes a diverse marketplace of algorithms, empowering users and developers to choose or create solutions tailored to specific contexts.

This decoupling of algorithms from applications allows for greater customization and interoperability, contrasting sharply with traditional platforms that enforce opaque, pre-set algorithms.

### Example: Social Graph Algorithm

Consider an algorithm that filters data based on a user's social graph:
This algorithm provides a nuanced interpretation of data based on proximity, allowing for trust-based filtering that aligns with user preferences.

## Reality Tunnels

The modular nature of Intuition's data interpretation mechanisms enables the creation of "Reality Tunnels." A Reality Tunnel combines literal interpretations, algorithms, and other relevant components to provide a tailored perspective on data.

[Subject] [in trust graph] [Vitalik's Web3 Trust Graph]

This integrated perspective becomes a Reality Tunnel, offering a customized lens through which users can view and interpret data.

### Switching Perspectives

Reality Tunnels also enable users to switch between perspectives. For instance, during a debate, a user could toggle to their opponent's Reality Tunnel to better understand their reasoning.

This flexibility contrasts with traditional platforms, where users are often restricted to a single perspective defined by a specific algorithm and social graph. By allowing users to explore multiple Reality Tunnels, Intuition fosters a richer, more comprehensive understanding of data and encourages well-informed decision-making.

## Enhancing Perspectives and Collaboration

The flexibility to create and toggle between Reality Tunnels transforms how users interact with data. By integrating literal interpretations, customizable algorithms, and composable data structures, Intuition empowers users to access diverse perspectives and foster collaboration.

Multiple perspectives lead to more comprehensive and nuanced discussions.
Access to diverse viewpoints enables better-informed decisions.
The system remains adaptable and inclusive for all participants.

This approach enriches discussions, improves decision-making, and ensures the ecosystem remains adaptable and inclusive for all participants.

## Next Steps

Now that you understand State Interpretations, explore:

- [Structuring](/guides/introduction/the-primitives/structuring) - Learn advanced techniques for working with interpretations
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how signal influences interpretations
- [Developer Tools](/guides/developer-tools) - Implement custom interpretations and algorithms 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/fundamentals/triples


# Triples

With discrete units of data established through Atoms, defining relationships between these units to form higher-order structures is essential. Intuition achieves this by employing Semantic Triples, ensuring a uniform and discrete structure that can be prescribed a decentralized identifier and have some associated agent-centric state.

This structure is essential for achieving consensus on arbitrarily sophisticated and expressive forms of data.

## Triple Structure

Triples consist of three elements: Subject, Predicate, and Object, with each element represented as an Atom. This Subject-Predicate-Object format allows users to clearly and explicitly define relationships between Atoms.

The entity or concept being described in the relationship.

The relationship or attribute that connects the subject to the object.

The value or characteristic attributed to the subject through the predicate.

These connections can be visualized as a graph where each node and edge is an Atom.

## Example Triple

In this example, each componentâ€”Subject, Predicate, and Object is an Atom, and the Triple expresses a specific relationship between these Atoms.

## Fractal Data Representations

Triples offer a flexible yet structured method for representing data relationships. By allowing Triples to act as Atoms within other Triples, Intuition facilitates the expression, storage, and usage of arbitrarily complex data models that can scale and evolve over time.

This flexibility is crucial for capturing intricate relationships and dynamics within data.
Enabling users to construct sophisticated applications and services on the Intuition framework.
This approach maintains discrete, referenceable units for data at every layer of the structure.

This flexibility is crucial for capturing intricate relationships and dynamics within data, enabling users to construct sophisticated applications and services on the Intuition framework. This approach maintains discrete, referenceable units for data at every layer of the structure, ensuring scalability and precision in data representation.

## Triple Ownership and Token Curated Registries

Akin to the process outlined for Atoms, the structure of Triples allows users to gain fractional ownership of Triples through interaction. Each interaction generates interaction fees, which are distributed to the owners of each respective Triple, creating an incentivized Token Curated Registry (TCR) for data structures.

The TCR encourages system participants to adopt common ways of structuring data by offering economic rewards.
This approach promotes an organic, incentive-driven structuring of data.
Contrasts with more rigid and traditional methods such as standards committees, which often struggle to achieve effective standardization.

The TCR encourages system participants to adopt common ways of structuring data by offering economic rewards. This approach promotes an organic, incentive-driven structuring of data, contrasting with more rigid and traditional methods such as standards committees, which often struggle to achieve effective standardization.

## Next Steps

Now that you understand Triples, explore:

- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Learn how users interact with Triples
- [Structuring Triples](/guides/introduction/the-primitives/structuring/triples) - Advanced techniques for working with Triples
- [Fees & Rewards](/guides/introduction/the-primitives/fundamentals/fees-rewards) - Understand the economic model 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives


# Primitives

The Intuition System is built on a set of novel primitives, which form the foundation of the ecosystem and enable the creation of a structured, semantic web of trust. 

:::note
Intuition introduces three new primitives: 

1. **Atoms**: Intuition's atomic unit of knowledge, enabling unique, persistent, canonical identifiers for all things - not just people.
2. **Triples:** A composition of Atoms - defined as Semantic Triples which represent the relationships between Atoms
3. **Signal:** The weight of Atoms and Triples, derived from the total amount of ETH deposited in Atom and Triple Vaults
:::

## Explore Primitives

Learn the core concepts of Atoms, Triples, Signal, Fees & Rewards, and State Interpretations. Master the building blocks of the Intuition system.

Discover advanced techniques for structuring data with Atoms and Triples, capturing signal, and calculating rewards in the Intuition ecosystem.

## Core Primitives Overview

The most basic units of knowledge within Intuition, functioning as unique, globally persistent, decentralized identifiers for all thingsâ€”people, concepts, products, and more.

Higher-order structures used to define relationships between Atoms. Each Triple consists of three components: a Subject, Predicate, and Object.

Actions that express intent, belief, or support within the system. Signals can be explicit or implicit, contributing to trust and belief expression.

## Understanding Atoms

The digital universe is vast, where everything from tangible objects to abstract concepts can be endowed with a digital identity. Atoms confer unique recognition and definition to persons, places, ideas, or even memes, ensuring each entity's distinct presence. Within Intuition, every Atom is secured by a unique DID (Decentralized Identifier) and an Ethereum wallet address, establishing a verifiable foundation.

Atoms are categorized into three primary roles within semantic structures: **Subjects**, **Predicates**, and **Objects**. This structure facilitates the creation of **Triples** that articulate specific assertions or facts about the world.

### Example Triple Structure

* **Alice** is the **Subject**
* **hasAccessTo** is the **Predicate**
* **Intuition** is the **Object**

Further illustrating the flexibility of Atoms, **Intuition** can also act as a **Subject:**

This claim demonstrates Intuition's role and essence in a semantic, structured format.

## Composition of Knowledge

Acknowledging the potential for any entity, concept, or piece of data to hold a digital identity opens the door to collaboratively crafting an expansive knowledge graph. By arranging Atoms into Triples, we co-create a graph mapping out entities' interrelations and factual, verifiable assertions about the world.

The journey within Intuition starts with an Atom. Engaging with this concept might begin by identifying entities within your realm of knowledge that fit neatly into the categories of Subjects, Predicates, or Objects. This process is a first step toward contributing to our collective mission: building a collaborative knowledge graph demonstrating the connections and relationships among all entities.

## Components of an Atom

Describes the concept or entity represented by an Atom, typically stored off-chain using decentralized storage solutions like IPFS or Arweave, with a URI pointing to this data stored on-chain.

A smart contract wallet associated with each Atom, granting it agency over its identity. This wallet is controlled by a specialized smart contract known as the Atom Warden.

A mechanism that allows users to deposit tokens into an Atom, signaling its relevance and support within the system. The Total Value Locked (TVL) in an Atom Vault indicates the Atom's acceptance and importance.

## Triples

Triples are higher-order structures within Intuition, used to define relationships between Atoms. Each Triple consists of three components: a Subject, Predicate, and Object, all of which are Atoms. This structure enables precise, machine-readable representations of data, facilitating complex and interconnected attestations.

### Triple Structure

The entity or concept being described.

The relationship or attribute of the subject.

The value or characteristic attributed to the subject.

In this example, each componentâ€”Subject, Predicate, and Objectâ€”is an Atom, and the Triple expresses a specific relationship between these Atoms.

Triples form the relationships between Atoms, allowing for arbitrarily-linked data across the web.

:::tip
Triples can be used as Atoms in other Triples, allowing for the expression of arbitrarily complex statements in a standardized format.
:::

## Signal

Signal in Intuition refers to any action that expresses intent, belief, or support within the system. Signals can be explicit, such as voting mechanisms or signed attestations, or implicit, inferred from user behavior.

### Signal Mechanisms

Users hold positions on Atoms and Triples, signaling their stance by increasing their balance on the relevant entities. Signals contribute to the nuanced expression of trust and belief, allowing for a dynamic and tiered system of preferences within the decentralized ecosystem.

Creating an Atom or Triple is distinctly different from taking a position on them. While users have the option to both create and take a position on an Atom/Triple at the time of creation, this Initial Deposit is not required. A user who makes no Initial Deposit will only create an Atom or Triple, which does not constitute a Signal.

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/structuring/atoms


# Atoms

Atoms are the fundamental building blocks of data in Intuition. Understanding how to properly structure atoms is crucial for building effective applications on the protocol.

## What are Atoms?

Atoms represent discrete, manageable pieces of information that can be referenced and combined across the web. Each atom is uniquely identified by a decentralized identifier (DID) and contains structured data that can be of any type or format.

## Structuring Atoms

### Basic Structure

An atom consists of three core components:

1. **Decentralized Identifier (DID)** - Unique identifier for the atom
2. **Data Content** - The actual information being represented
3. **Metadata** - Additional context and properties

### Example Atom Structure

```json
{
  "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
  "data": {
    "type": "concept",
    "content": "Machine Learning",
    "description": "A subset of artificial intelligence that enables systems to learn and improve from experience",
    "tags": ["AI", "technology", "computing"]
  },
  "metadata": {
    "created": "2024-01-15T10:30:00Z",
    "creator": "did:ethr:mainnet:0x123...",
    "version": "1.0"
  }
}
```

## Best Practices for Atom Structure

### 1. Clear and Descriptive Content

- Use precise, unambiguous language
- Include sufficient context for understanding
- Avoid overly complex or nested structures

### 2. Consistent Naming Conventions

- Use camelCase for property names
- Maintain consistent terminology across related atoms
- Follow established domain conventions

### 3. Proper Metadata

- Always include creation timestamps
- Specify the creator's DID
- Include version information for mutable atoms

### 4. Scalable Design

- Design atoms to be composable
- Consider future extensibility
- Maintain backward compatibility

## Atom Categories

### Concept Atoms
Represent abstract ideas, categories, or classifications.

```json
{
  "type": "concept",
  "content": "Blockchain Technology",
  "category": "technology"
}
```

### Entity Atoms
Represent specific people, places, or things.

```json
{
  "type": "entity",
  "content": "Ethereum",
  "category": "blockchain",
  "properties": {
    "founded": "2015",
    "creator": "Vitalik Buterin"
  }
}
```

### Attribute Atoms
Represent characteristics or properties.

```json
{
  "type": "attribute",
  "content": "Decentralized",
  "category": "property",
  "appliesTo": ["blockchain", "governance"]
}
```

## Creating Atoms Programmatically

### Using the SDK (copyâ€‘paste ready)

```ts
  createAtomFromString,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

// 1) Configure viem clients (example uses Sepolia)
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
const walletClient = createWalletClient({ account, chain: sepolia, transport: http() })
const publicClient = createPublicClient({ chain: sepolia, transport: http() })

// 2) Resolve MultiVault address for the current chain
const multivaultAddress = getEthMultiVaultAddressFromChainId(sepolia.id)

// 3) Create an Atom from a simple string label
const result = await createAtomFromString(
  { walletClient, publicClient, address: multivaultAddress },
  'Machine Learning',

console.log('Created atom vaultId:', result.state.vaultId)
```

### Validation

Ensure your atoms follow these validation rules:

- **Required Fields**: `id`, `data.content`, `metadata.created`
- **Content Length**: Minimum 1 character, maximum 10,000 characters
- **Tag Count**: Maximum 20 tags per atom
- **Metadata**: Must include creator DID and timestamp

## Atom Relationships

Atoms can be related to each other through various mechanisms:

### Direct References
```json
{
  "content": "Deep Learning",
  "relatedAtoms": [
    "did:ethr:mainnet:0x...", // Machine Learning atom
    "did:ethr:mainnet:0x..."  // Neural Networks atom
  ]
}
```

### Hierarchical Structure
```json
{
  "content": "Artificial Intelligence",
  "children": [
    "did:ethr:mainnet:0x...", // Machine Learning
    "did:ethr:mainnet:0x..."  // Expert Systems
  ]
}
```

## Quality Guidelines

### Content Quality
- Ensure accuracy and verifiability
- Use clear, concise language
- Provide sufficient context
- Avoid redundant or duplicate atoms

### Technical Quality
- Follow proper DID standards
- Include comprehensive metadata
- Use consistent data formats
- Implement proper versioning

### Community Standards
- Respect intellectual property
- Avoid misleading or false information
- Contribute to the ecosystem's growth
- Engage with the community constructively

## Next Steps

Now that you understand how to structure atoms, explore:

- [Triples](./triples.md) - Learn how to connect atoms into meaningful relationships
- [Capturing Signal](./capturing-signal.md) - Understand how to measure atom usage and relevance
- [Calculating Rewards](./calculating-rewards.md) - Discover how atom interactions generate rewards

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/structuring/calculating-rewards


# Calculating Rewards

The reward system in Intuition incentivizes high-quality contributions and active participation in the ecosystem. Understanding how rewards are calculated helps users maximize their earnings and contribute effectively.

## Reward Fundamentals

### What are Rewards?

Rewards in Intuition are distributed in $TRUST tokens to users who:
- Create valuable atoms and triples
- Provide accurate and useful information
- Engage with the ecosystem meaningfully
- Stake tokens to back their contributions

### Reward Types

#### 1. Creation Rewards
Rewards for creating high-quality atoms and triples.

```javascript
const creationReward = await calculateCreationReward({

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/structuring/capturing-signal


# Capturing Signal

Signal capture is the process of measuring and quantifying how users interact with atoms and triples in the Intuition ecosystem. This data drives the reward system and helps identify the most valuable and relevant information.

## What is Signal?

Signal represents the collective behavior and preferences of users interacting with the Intuition protocol. It includes:

- **Usage Patterns**: How often atoms and triples are accessed
- **User Engagement**: Time spent, interactions, and feedback
- **Quality Indicators**: Accuracy, relevance, and usefulness
- **Network Effects**: How data spreads and influences other users

## Signal Types

### 1. Direct Signal
Explicit user actions that directly indicate value.

```javascript
// User explicitly rates an atom
const rating = await rateAtom({

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/structuring


# Structuring

Learn advanced techniques for working with Atoms and Triples in real-world applications. This section covers practical approaches to structuring data, capturing signal, and calculating rewards within the Intuition ecosystem.

## Explore Structuring Techniques

Advanced techniques for creating and managing Atoms, including best practices for identifier design and data organization.
Learn about Atom Structuring â†’

Discover how to effectively structure relationships using Triples, including complex nested structures and semantic modeling.
Learn about Triple Structuring â†’

Learn how to effectively capture and structure signal data, including user interactions, preferences, and behavioral patterns.
Learn about Signal Capture â†’

Understand the mathematical and economic principles behind reward calculation in the Intuition ecosystem.
Learn about Reward Calculation â†’

## Structuring Principles

Design structures that can be easily combined and reused across different contexts.
Ensure your data structures can grow and evolve without breaking existing relationships.
Create structures that work seamlessly with other systems and data sources.

## Learning Path

## Prerequisites

Before diving into structuring techniques, make sure you have a solid understanding of the [Fundamentals](/docs/introduction/the-primitives/fundamentals) section, particularly:

- Basic concepts of Atoms, Triples, and Signal
- Understanding of the economic model (Fees & Rewards)
- Familiarity with state interpretation approaches

## Next Steps

After mastering structuring techniques, explore the [Developer Tools](/docs/developer-tools) section to learn how to implement these concepts in your applications. 

---

# 

Source: https://docs.intuition.systems/guides/introduction/the-primitives/structuring/triples


# Triples

Triples are the fundamental way to create relationships between atoms in Intuition. They follow a subject-predicate-object structure that enables rich, interconnected knowledge graphs.

## What are Triples?

A triple consists of three atoms connected in a specific relationship:
- **Subject**: The entity being described
- **Predicate**: The relationship or property
- **Object**: The value or target of the relationship

## Basic Triple Structure

```json
{
  "id": "did:ethr:mainnet:0x...",
  "subject": "did:ethr:mainnet:0x...", // Subject atom
  "predicate": "did:ethr:mainnet:0x...", // Predicate atom
  "object": "did:ethr:mainnet:0x...", // Object atom
  "metadata": {
    "created": "2024-01-15T10:30:00Z",
    "creator": "did:ethr:mainnet:0x...",
    "confidence": 0.95
  }
}
```

## Triple Categories

### 1. Property Triples
Describe attributes or characteristics of entities.

**Example**: "Ethereum is decentralized"
- Subject: Ethereum atom
- Predicate: "is" atom
- Object: "decentralized" atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Ethereum
  "predicate": "did:ethr:mainnet:0x...", // is
  "object": "did:ethr:mainnet:0x...", // decentralized
  "type": "property"
}
```

### 2. Relationship Triples
Connect entities through specific relationships.

**Example**: "Vitalik Buterin created Ethereum"
- Subject: Vitalik Buterin atom
- Predicate: "created" atom
- Object: Ethereum atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Vitalik Buterin
  "predicate": "did:ethr:mainnet:0x...", // created
  "object": "did:ethr:mainnet:0x...", // Ethereum
  "type": "relationship"
}
```

### 3. Classification Triples
Establish hierarchical or categorical relationships.

**Example**: "Machine Learning is a subset of AI"
- Subject: Machine Learning atom
- Predicate: "is a subset of" atom
- Object: AI atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Machine Learning
  "predicate": "did:ethr:mainnet:0x...", // is a subset of
  "object": "did:ethr:mainnet:0x...", // AI
  "type": "classification"
}
```

## Creating Triples

### Using the SDK (copyâ€‘paste ready)

```ts

// 1) Configure viem clients (example uses Sepolia)
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
const walletClient = createWalletClient({ account, chain: sepolia, transport: http() })
const publicClient = createPublicClient({ chain: sepolia, transport: http() })

// 2) MultiVault address for current chain
const multivaultAddress = getEthMultiVaultAddressFromChainId(sepolia.id)

// 3) Create three atoms
const a = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'Ethereum')
const b = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'is')
const c = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'decentralized')

// 4) Create the triple (uses vaultIds from the created atoms)
const triple = await createTripleStatement(
  { walletClient, publicClient, address: multivaultAddress },
  { args: [a.state.vaultId, b.state.vaultId, c.state.vaultId] },

console.log('Created triple vaultId:', triple.state[0].vaultId)
```

### Validation Rules

- **Required Fields**: `subject`, `predicate`, `object`, `metadata.creator`
- **Unique Relationships**: Each subject-predicate-object combination should be unique
- **Valid Atoms**: All three components must be valid, existing atoms
- **Confidence Score**: Must be between 0 and 1

## Advanced Triple Patterns

### 1. Temporal Triples
Include time-based information.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Ethereum
  "predicate": "did:ethr:mainnet:0x...", // launched in
  "object": "did:ethr:mainnet:0x...", // 2015
  "temporal": {
    "validFrom": "2015-07-30T00:00:00Z",
    "validTo": null
  }
}
```

### 2. Weighted Triples
Include confidence or weight information.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Bitcoin
  "predicate": "did:ethr:mainnet:0x...", // is similar to
  "object": "did:ethr:mainnet:0x...", // Gold
  "weight": 0.85,
  "evidence": ["market behavior", "store of value"]
}
```

### 3. Contextual Triples
Include specific context or conditions.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Python
  "predicate": "did:ethr:mainnet:0x...", // is popular for
  "object": "did:ethr:mainnet:0x...", // Machine Learning
  "context": {
    "domain": "programming",
    "timeframe": "2020-2024",
    "geographic": "global"
  }
}
```

## Triple Composition Patterns

### 1. Chain Composition
Connect multiple triples in a chain.

```
A â†’ B â†’ C â†’ D
```

**Example**: "Ethereum is a blockchain" + "Blockchain is decentralized" â†’ "Ethereum is decentralized"

### 2. Tree Composition
Create hierarchical structures.

```
        Root
       /    \
   Child1  Child2
   /    \     |
Leaf1  Leaf2 Leaf3
```

### 3. Graph Composition
Create complex interconnected networks.

```
A â†â†’ B â†â†’ C
â†“    â†“    â†“
D â†â†’ E â†â†’ F
```

## Best Practices

### 1. Consistent Predicates
- Use standardized predicate atoms
- Maintain consistent terminology
- Avoid ambiguous relationships

### 2. Meaningful Relationships
- Ensure relationships add value
- Avoid redundant or obvious triples
- Focus on non-trivial connections

### 3. Quality Control
- Verify accuracy of relationships
- Include appropriate confidence scores
- Provide evidence when possible

### 4. Scalability
- Design for extensibility
- Consider performance implications
- Plan for complex queries

## Querying Triples

### Basic Queries (GraphQL)

```ts

configureClient({ apiUrl: API_URL_DEV })
const client = createServerClient({})

// Find triples where object label contains "decentralized"
const data = await client.request(GetTriplesDocument, {
  limit: 10,
  where: {
    object: { label: { _ilike: '%decentralized%' } },
  },
})

console.log(data.triples.length)
```

### Complex Queries (GraphQL)

```ts

configureClient({ apiUrl: API_URL_DEV })
const client = createServerClient({})

// Find AI subsets
const aiSubsets = await client.request(GetTriplesDocument, {
  limit: 20,
  where: {
    predicate: { label: { _ilike: '%is a subset of%' } },
    object: { label: { _ilike: '%AI%' } },
  },
})

console.log(aiSubsets.triples.length)
```

## Triple Analytics

### Usage Metrics
- **Frequency**: How often a triple is referenced
- **Confidence**: Average confidence score
- **Consensus**: Agreement level among contributors

### Network Analysis
- **Centrality**: Importance of atoms in the network
- **Clustering**: Groups of related atoms
- **Path Analysis**: Shortest paths between atoms

## Next Steps

Now that you understand how to structure triples, explore:

- [Capturing Signal](./capturing-signal.md) - Learn how to measure triple usage and relevance
- [Calculating Rewards](./calculating-rewards.md) - Discover how triple interactions generate rewards
- [Atoms](./atoms.md) - Review atom structure fundamentals

---

# 

Source: https://docs.intuition.systems/guides/introduction/why-intuition


# Why Intuition?

> **Every interaction online is an attestation.**
> A review or a purchase on Amazon, a comment on Reddit, the watching of a show on Netflix, a retweet, a LinkedIn endorsement, a 'follow', a bookmark, the ordering of an Uber, even a "like" â€” all are forms of attestations: claims made by things about things.

But attestations today are fragmented, unverifiable, and platform-locked. They don't move with you. They don't carry weight. They aren't semantically structured and unambiguously consumable by machines.

**Intuition changes that.** We've rebuilt attestations as first-class, tokenized primitives â€” structured, portable, and economically backed. _Attestations on steroids._

## Decentralizing Information with Attestations

**Blockchains decentralized money.
Intuition decentralizes information â€” by offering next-generation attestation infrastructure.**

An attestation in Intuition isn't just a line of text. It's:

- **Verifiable** â€” signed and attributable
- **Ownable** â€” belongs to the creator, not a platform
- **Discoverable** â€” structured as a Triple (subject â†’ predicate â†’ object)
- **Valuable** â€” backed by economic incentives through bonding curves

This turns the messy stream of human expression into a global knowledge substrate that's actually useful to developers, communities, and AI agents.

## Information Finance: Attestations as Assets

Intuition pioneers **Information Finance (InfoFi)**: the idea that information can be valued and exchanged just like money.

- **Ideas become assets** â€” an attestation isn't just data, it's collateralized
- **Reputation becomes capital** â€” your attestations are your portfolio of credibility
- **Knowledge flows freely** â€” attestations aren't siloed; they're cross-platform and composable

Attestations are no longer passive byproducts of online activity â€” they're programmable building blocks for apps and agents.

## The $200 Trillion Problem

The global knowledge economy is worth over **$200 trillion**, yet:

- Most of its value is created by individuals
- Less than 1% of that value flows back to the creators
- Instead, tech monopolies capture and silo it

**The result:** broken rails, misinformation, and AI systems consuming oceans of low-quality data without provenance.

Attestations are the missing rails. When data becomes signed, tokenized, and portable, it allows value to flow back to contributors and trust to flow into the systems that need it most.

## Rebuilding the Rails of Knowledge

Intuition makes attestations first-class protocol objects. That means:

- **Facts, claims, and perspectives** are all structured as attestations
- **Credibility is collateralized** â€” good attestations earn rewards; bad ones cost you stake
- **Distribution is programmatic** â€” attestations move frictionlessly across apps, chains, and agents

Think of it as the Ethereum moment for knowledge: where attestations flow as freely as tokens, powering new classes of decentralized infrastructure.

## Programmatic Monetization and Distribution

Attestations aren't just portable â€” they're **monetizable**.

With Intuition, every attestation can plug into programmatic distribution rails:

- Censorship-resistant search and discovery
- Verifiable knowledge bases
- Open data marketplaces
- Training sets for AI agents

Each attestation carries weight, liquidity, and discoverability, ensuring no single platform can gate what's visible or valuable.

## From Information â†’ Intuition

Why does this matter? Because **raw information without provenance is noise.**

Attestations, structured and economically backed, create a higher-resolution understanding of the world. They transform scattered data into collective intuition â€” fueling smarter AI, safer markets, and more confident human decision-making.

## Reviving the Semantic Web with Crypto-Economic Consensus

The Semantic Web failed because it required global consensus on standards without incentives to achieve it. Different organizations created competing schemas, vocabularies fragmented, and there was no mechanism to converge on shared identifiers.

**Intuition solves this with crypto-economics** â€” the same force that achieves distributed consensus in blockchains now drives semantic standardization:

- **Incentivized identifiers** â€” stake on canonical IDs for entities, creating economic pressure toward convergence
- **Market-driven standards** â€” the most useful data structures attract the most stake and become de facto standards
- **Emergent interoperability** â€” economic incentives naturally align participants toward compatible schemas
- **Consensus through collateralization** â€” disagreements resolve through staking, not committees

Where the Semantic Web asked the world to voluntarily agree on standards, Intuition makes consensus profitable. Attestations become the economic glue that binds distributed actors to shared semantic structures.

## How It Works: Skin in the Game

On Intuition, every attestation has consequences:

- **Publish a useful attestation** â†’ earn reputation and rewards
- **Publish misinformation** â†’ lose your stake and credibility
- **Signal strong conviction** â†’ stake more on your attestation
- **Build trust** â†’ accumulate a reputation that travels with you
- **Use consensus identifiers** â†’ earn more by aligning with the network
- **Fork data structures** â†’ lose money by fragmenting liquidity

This flips today's internet incentives: no longer "reward the loudest," but reward the most credible and interoperable attestations.

### The Fork Choice Rule for Data

Just like blockchains have fork choice rules that determine the canonical chain, Intuition creates economic pressure toward canonical identifiers and data structures. **When you use consensus identifiers, you tap into existing liquidity pools and network effects. When you create competing forks, you isolate yourself economically.**

**Example:** Imagine two identifiers for "Ethereum":
- **Identifier A**: Used by 10,000 attestations with $1M total stake
- **Identifier B**: Used by 50 attestations with $5K total stake

If you make an attestation about Ethereum:
- Using **Identifier A** â†’ Your attestation joins a liquid market, benefits from network effects, earns higher rewards
- Using **Identifier B** â†’ Your attestation is isolated, has minimal visibility, earns negligible rewards

The economic incentive is clear: converge on consensus or pay the price. This same dynamic applies to data structures, schemas, and semantic relationships. The network naturally evolves toward maximum interoperability because **consensus literally pays.**

## Digital Sovereignty and Data Ownership

**Your attestations are yours.** Not Facebook's, not LinkedIn's, not OpenAI's.

- You **own** them
- You **control** who can access them
- You **capture** the value they generate
- They **travel** with you across every app, chain, or agent

Attestations become the backbone of digital sovereignty.

## The Trust Layer for AI

AI doesn't just need more data â€” it needs **verifiable attestations about data**:

- Who said it
- With what reputation
- With what conviction

Intuition provides the trust graph of attestations. AI systems can finally ground themselves in data with provenance, weights, and economic signals â€” not just raw text.

This makes AI more reliable while ensuring humans share in the value of the knowledge they produce.

## What You Can Build

By treating attestations as programmable primitives, you can create:

- **Verifiable identity systems**
- **Reputation networks** powered by attestations
- **Decentralized fact-checking** with stakes
- **AI agents** that reason over attestations as context
- **Information markets** where attestations themselves are the assets

## Join the Movement

Intuition is about reclaiming the internet by giving attestations real weight.

Whether you're a developer, researcher, or community builder, your contributions aren't just ephemeral posts â€” they're portable, valuable attestations that strengthen the global knowledge graph.

**Together, we can rebuild the web around truth, attribution, and trust.**

---

# 

Source: https://docs.intuition.systems/guides/intuition-ai


# Intuition AI

Intuition AI enables powerful integrations between AI models and the Intuition knowledge graph, allowing AI systems to query, create, and interact with decentralized trust data.

## What is Intuition AI?

Intuition AI bridges the gap between artificial intelligence and decentralized knowledge systems, enabling:

- **Semantic Queries**: AI models can query the knowledge graph using natural language
- **Knowledge Creation**: Programmatically create Atoms and Triples through AI analysis
- **Trust Analysis**: Leverage AI for intelligent signal attestation and pattern recognition
- **Context Enhancement**: Enrich AI responses with verified on-chain data

## Model Context Protocol (MCP) Integration

The cornerstone of Intuition AI is our MCP server, which provides a standardized way for AI models to interact with the Intuition protocol through the Model Context Protocol specification.

### Key Capabilities

- **Extract Triples**: Convert natural language into structured knowledge triples
- **Search Entities**: Find atoms, accounts, and concepts across the knowledge graph
- **Account Information**: Retrieve detailed information about accounts and their connections
- **Social Graphs**: Explore following/follower relationships and recommendations
- **List Management**: Search and manage curated lists of entities

## Getting Started

Ready to integrate AI with Intuition? Check out our MCP server:

- **[Intuition MCP Server](/guides/intuition-ai/mcp-server)** - Complete guide to setting up and using the MCP server for AI integrations

## Use Cases

### Knowledge Graph Queries
AI models can ask questions like "What are the most trusted DeFi protocols?" and receive structured data from the knowledge graph.

### Automated Knowledge Creation
Transform unstructured data and natural language into structured Atoms and Triples automatically.

### Trust Signal Analysis
Use AI to analyze patterns in trust signals and provide insights about entity reliability.

### Enhanced AI Context
Enrich AI model responses with verified, on-chain data about entities and relationships.

## Open Source

All Intuition AI components are open source and available on GitHub. The MCP server is actively maintained and welcomes community contributions. 

---

# 

Source: https://docs.intuition.systems/guides/intuition-ai/mcp-server


# Intuition MCP Server

The Intuition MCP Server is an HTTP stream server designed to interact with the Intuition knowledge graph, enabling AI models and applications to query and manage data through powerful tools built on the Model Context Protocol.

## Overview

The Intuition MCP Server acts as a bridge between AI applications and the Intuition protocol, providing:

- **Structured data extraction** from natural language using triple extraction
- **Comprehensive search** for entities (atoms), accounts, and concepts
- **Social graph exploration** with followers and following relationships
- **Account information** retrieval with detailed connection data
- **List management** for curated entity collections

This server supports both modern Streamable HTTP and legacy Server-Sent Events (SSE) transports for maximum compatibility.

## GitHub Repository

    Intuition MCP Server
  
    Open-source Model Context Protocol server for knowledge graph interactions
  <a
    href="https://github.com/0xIntuition/intuition-mcp-server"
    target="_blank"
    rel="noopener noreferrer"
    
    onMouseOver={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
    onMouseOut={(e) => e.currentTarget.style.transform = 'scale(1)'}
  >
    View on GitHub â†’
  
## Getting Started

### Prerequisites
- Node.js 14+
- pnpm (install globally with `npm install -g pnpm`)

### Installation

1. **Clone the repository**:
```bash
git clone https://github.com/0xIntuition/intuition-mcp-server
cd intuition-mcp-server
```

2. **Install dependencies**:
```bash
pnpm install
```

3. **Start the server**:
```bash
pnpm run start:http
```

The server will be available at the configured host and port (e.g., http://localhost:3001).

## Available Tools

The MCP Server provides several powerful tools for interacting with the Intuition knowledge graph. All tools return responses sorted by relevance and include comprehensive information.

### search_atoms
Searches for entities (accounts, concepts, people) by name, description, URL, or ENS domain.

**Input Schema**:
```json
{
  "queries": ["ethereum", "vitalik.eth", "defi protocols"]
}
```

**Usage**: Find atoms related to your search terms with detailed information and connections.

### get_account_info
Retrieves detailed information about an account using its address or identifier.

**Input Schema**:
```json
{
  "identifier": "0x1234567890123456789012345678901234567890"
}
```

**Usage**: Get comprehensive account details including connections and activity.

### search_lists
Searches for curated lists of entities by name or description.

**Input Schema**:
```json
{
  "query": "top defi protocols"
}
```

**Usage**: Find organized collections of related entities with ranking and metadata.

### get_following
Retrieves atoms that an account follows, optionally filtered by predicate.

**Input Schema**:
```json
{
  "account_id": "0x3e2178cf851a0e5cbf84c0ff53f820ad7ead703b",
  "predicate": "recommend"
}
```

**Usage**: Explore what entities an account follows or recommends.

### get_followers
Retrieves followers of an account, optionally filtered by predicate.

**Input Schema**:
```json
{
  "account_id": "0x3e2178cf851a0e5cbf84c0ff53f820ad7ead703b",
  "predicate": "follow"
}
```

**Usage**: See who follows or recommends a specific account.

### search_account_ids
Resolves identifiers (like ENS domains) to account addresses.

**Input Schema**:
```json
{
  "identifier": "vitalik.eth"
}
```

**Usage**: Convert ENS names or other identifiers to blockchain addresses.

## Client Integration

### Using the MCP SDK

The server uses the Model Context Protocol SDK for client interactions. Here's a basic client setup:

```typescript

async function connectToMcpServer(url: string) {
  const client = new Client({

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/backup


# Run a Node

Learn how to set up and run your own Intuition node to participate in the network using the official Rust implementation.

## Overview

The `intuition-rs` workspace is a comprehensive Rust workspace for blockchain data indexing and processing, featuring a modular architecture with multiple specialized services. This implementation provides high performance, memory safety, and reliability for running Intuition nodes and backend services.

Running an Intuition node requires Docker, Rust toolchain, and proper environment configuration. This guide provides comprehensive setup instructions for local development and production deployments.

## Architecture

This workspace contains the following core services:

## Prerequisites

### Required Tools

### Environment Configuration

You'll need to set up environment variables for various services. Create a `.env` file based on the `.env.sample` template with the following required variables:

| Variable | Description | Source |
|----------|-------------|---------|
| `OPENAI_API_KEY` | OpenAI API key for AI features | [OpenAI Platform](https://platform.openai.com/api-keys) |
| `PINATA_GATEWAY_TOKEN` | Pinata gateway token for IPFS | [Pinata Dashboard](https://app.pinata.cloud/developers/gateway-settings) |
| `PINATA_API_JWT` | Pinata API JWT for IPFS uploads | [Pinata Dashboard](https://app.pinata.cloud/developers/api-keys) |
| `BASE_MAINNET_RPC_URL` | Base mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `BASE_SEPOLIA_RPC_URL` | Base sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `ETHEREUM_MAINNET_RPC_URL` | Ethereum mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_MAINNET_RPC_URL` | Linea mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_SEPOLIA_RPC_URL` | Linea sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `TRUST_TESTNET_RPC_URL` | Trust testnet RPC endpoint (local geth) | Local development |
| `TRUST_MAINNET_RPC_URL` | Trust mainnet RPC endpoint (local geth) | Local development |
| `INDEXER_SCHEMA` | Database schema for indexer (set to "local") | Local development |
| `INTUITION_CONTRACT_ADDRESS` | Intuition contract address | Contract deployment |

## Running the System

**Note**: All scripts are located in the `scripts/` directory and should be run from the project root.

### Option 1: Using Published Docker Images (Recommended)

```bash
# Start with local Ethereum node
cargo make start-local
```

### Option 2: Building from Source

```bash
# Build all Docker images from source
cargo make build-docker-images

# Start the system
cargo make start-local
```

### Option 3: Running with Integration Tests

```bash
# Start with tests enabled
cargo make start-local test
```

## Testing

### Run All Tests
```bash
cargo nextest run
```

### Run Integration Tests
```bash
cd integration-tests
pnpm test src/follow.test.ts
```

### Run Specific Test Suites
```bash
# Test account operations
pnpm test src/create-person.test.ts

# Test vault operations
pnpm test src/vaults.test.ts

# Test AI agents
pnpm test src/ai-agents.test.ts
```

## Development

### CLI Tool
```bash
# Run the CLI to verify latest data
./scripts/cli.sh
```

### Code Quality
```bash
# Format code
cargo make fmt

# Run linter
cargo make clippy

# Run all checks
cargo make check
```

### Database Operations
```bash
# Start services and run migrations
cargo make start-docker-and-migrate

# Manual migration (if needed)
cp .env.sample .env
source .env
```

## Local Development Setup

### Using Local Ethereum Node

Add to your `.env` file:
```bash
INTUITION_CONTRACT_ADDRESS=0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B
START_BLOCK=0
```

Create local test data:
```bash
cd integration-tests
npm install
npm run create-predicates
```

### Manual Service Management

```bash
# Start all services
docker-compose -f docker/docker-compose-apps.yml up -d

# Stop all services
./scripts/stop.sh

# View logs
docker-compose -f docker/docker-compose-apps.yml logs -f
```

## Project Structure

```
intuition-rs/
â”œâ”€â”€ apps/                 # Custom Rust applications
â”‚   â”œâ”€â”€ cli/             # Terminal UI client
â”‚   â”œâ”€â”€ consumer/        # Event processing pipeline (Redis Streams)
â”‚   â”œâ”€â”€ histocrawler/    # Historical data crawler
â”‚   â”œâ”€â”€ image-guard/     # Image processing service
â”‚   â”œâ”€â”€ models/          # Domain models & data structures
â”‚   â”œâ”€â”€ rpc-proxy/       # RPC proxy with caching
â”‚   â””â”€â”€ shared-utils/    # Common utilities
â”œâ”€â”€ infrastructure/      # Infrastructure components
â”‚   â”œâ”€â”€ hasura/         # GraphQL API & migrations
â”‚   â”œâ”€â”€ blockscout/     # Blockchain explorer
â”‚   â”œâ”€â”€ drizzle/        # Database schema management
â”‚   â”œâ”€â”€ geth/           # Local Ethereum node config
â”‚   â”œâ”€â”€ indexer-and-cache-migrations/  # Database migrations
â”‚   â”œâ”€â”€ migration-scripts/  # Migration utilities
â”‚   â””â”€â”€ prometheus/     # Monitoring configuration
â”œâ”€â”€ docker/             # Docker configuration
â”‚   â”œâ”€â”€ docker-compose-apps.yml   # Application services
â”‚   â”œâ”€â”€ docker-compose-shared.yml # Shared infrastructure
â”‚   â””â”€â”€ Dockerfile      # Multi-stage build
â”œâ”€â”€ scripts/            # Shell scripts
â”‚   â”œâ”€â”€ start.sh        # System startup
â”‚   â”œâ”€â”€ stop.sh         # System shutdown
â”‚   â”œâ”€â”€ cli.sh          # CLI runner
â”‚   â”œâ”€â”€ init-dbs.sh     # Database initialization
â”œâ”€â”€ integration-tests/  # End-to-end tests
â””â”€â”€ README.md          # This file
```

## Event Processing Pipeline

The system processes blockchain events through multiple stages:

1. **RAW** - Raw event ingestion from blockchain
2. **DECODED** - Event decoding and parsing
3. **RESOLVER** - Data resolution and enrichment
4. **IPFS-UPLOAD** - Upload images to IPFS and track them in the local DB

### Supported Contract Versions
- Multivault v2.0

## Monitoring and Observability

### Logging

The system includes comprehensive logging capabilities:

**Features:**
- **Structured JSON Logging**: All services output machine-readable logs
- **Container Logs**: Direct access to service logs via Docker
- **Log Filtering**: Easy filtering by log level and service

**Benefits:**
- **Debugging**: Quickly find and analyze issues across services
- **Performance Monitoring**: Track service performance and bottlenecks
- **Audit Trail**: Complete visibility into system operations

**Getting Started:**
1. Start the system: `cargo make start-local`
2. View logs: `docker logs `
3. Filter logs: `docker logs  | grep '"level":"INFO"'`

**JSON Logging:**
All consumer services output structured JSON logs with the following fields:
- `timestamp`: ISO 8601 timestamp
- `level`: Log level (INFO, WARN, ERROR, DEBUG)
- `fields.message`: Log message content
- `target`: Module path
- `filename`: Source file name
- `line_number`: Line number in source file
- `threadId`: Thread identifier

**Viewing Logs:**
```bash
# View container logs directly
docker logs decoded_consumer | grep '"level":"INFO"'
docker logs resolver_consumer | grep '"level":"ERROR"'
docker logs ipfs_upload_consumer | grep '"level":"WARN"'
```

## Troubleshooting

### Common Issues

1. **Database connection errors**: Ensure PostgreSQL is running and credentials are correct
2. **RPC endpoint issues**: Verify your Alchemy endpoints are valid and have sufficient quota
3. **Docker resource limits**: Ensure Docker has sufficient memory and CPU allocation

### Getting Help

- Check the [intuition-rs repository](https://github.com/0xIntuition/intuition-rs) for latest updates
- Review the [DeepWiki documentation](https://deepwiki.com/0xIntuition/intuition-rs) for detailed technical information
- Join the Intuition community for support

## How to Run Intuition in a Kubernetes Cluster

A comprehensive Kubernetes-based deployment infrastructure for blockchain indexing and data services, managed with ArgoCD and Terraform.

### Architecture Overview

This project deploys a complete blockchain indexing platform on Google Cloud Platform (GCP) using:

- **GKE Cluster**: Multi-node pool Kubernetes cluster
- **ArgoCD**: GitOps-based continuous deployment
- **Terraform**: Infrastructure as Code for GCP resources
- **Kustomize**: Kubernetes manifest management

### Core Services

#### Data Layer
- **TimescaleDB**: Time-series database with PostgreSQL extensions and AI capabilities
- **Indexer Database**: Dedicated database for blockchain indexing operations

#### Application Services
- **GraphQL Engine**: Hasura GraphQL API for data access
- **IPFS Node**: InterPlanetary File System for decentralized storage
- **Safe Content Service**: Content validation and processing
- **TimescaleDB Vectorizer Worker**: Vector processing for AI/ML workloads
- **Histocrawler**: Historical data crawling and indexing service
- **Image Guard**: Image validation and security service
- **RPC Proxy**: Blockchain RPC request routing and caching

#### Consumer Services
- **Decoded Consumer**: Blockchain event decoding and processing
- **IPFS Upload Consumer**: IPFS content upload and management
- **Resolver Consumer**: Data resolution and lookup services

#### Management Tools
- **pgAdmin**: PostgreSQL administration interface
- **Ingress Controller**: Traffic routing and load balancing

### Infrastructure Components

#### GKE Cluster Suggested Configuration
- **Region**: `us-west2`
- **Project**: `be-cluster`
- **Network**: Custom VPC with private/public subnets
- **Node Pools**:
  - `db-pool`: n2-standard-16 (dedicated for databases)
  - `app-pool`: e2-standard-2 (application services)
  - `consumer-pool`: custom-4-8192 (data processing)

#### Storage
- **Persistent Volumes**: GCP Persistent Disk with resizable storage class
- **IPFS Storage**: 50Gi persistent volume for IPFS data
- **Database Storage**: 50Gi for TimescaleDB

### Project Structure

```
gcp-deployment/
â”œâ”€â”€ apps/                    # Kubernetes applications
â”‚   â”œâ”€â”€ consumers/          # Data processing consumers
â”‚   â”‚   â”œâ”€â”€ decoded/        # Blockchain event decoder
â”‚   â”‚   â”œâ”€â”€ ipfs-upload/    # IPFS upload processor
â”‚   â”‚   â””â”€â”€ resolver/       # Data resolver service
â”‚   â”œâ”€â”€ graphql/            # Hasura GraphQL engine
â”‚   â”œâ”€â”€ histocrawler/       # Historical data crawler
â”‚   â”œâ”€â”€ image-guard/        # Image validation service
â”‚   â”œâ”€â”€ indexer-db/         # Indexer database
â”‚   â”œâ”€â”€ ipfs/               # IPFS node
â”‚   â”œâ”€â”€ pgadmin/            # PostgreSQL admin
â”‚   â”œâ”€â”€ rpc-proxy/          # RPC request proxy
â”‚   â”œâ”€â”€ safe-content/       # Content validation service
â”‚   â”œâ”€â”€ timescale_db/       # TimescaleDB instance
â”‚   â”œâ”€â”€ timescale_db_vectorizer/  # Vector processing
â”‚   â””â”€â”€ ingress/            # Ingress configuration
â”œâ”€â”€ argocd/                 # ArgoCD configuration
â”‚   â”œâ”€â”€ coreapps/           # Core application definitions
â”‚   â”œâ”€â”€ namespacedapps/     # Namespace-specific apps
â”‚   â”œâ”€â”€ projects/           # ArgoCD project definitions
â”‚   â””â”€â”€ repos/              # Repository secrets
â”œâ”€â”€ terraform/              # Infrastructure as Code
â”‚   â””â”€â”€ debug-gke/          # GKE cluster provisioning
â””â”€â”€ test-kustomize/         # Kustomize testing
```

### Quick Start

#### Prerequisites
- Google Cloud SDK
- Terraform >= 1.0
- kubectl
- ArgoCD CLI

#### 1. Deploy Infrastructure
```bash
cd terraform/debug-gke
terraform init
terraform plan
terraform apply
```

#### 2. Configure ArgoCD
```bash
# Get GKE credentials
gcloud container clusters get-credentials debug-cluster --region us-west2

# Install ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Apply ArgoCD configuration
kubectl apply -f argocd/
```

#### 3. Deploy Applications
Applications are automatically deployed via ArgoCD GitOps. The system monitors the Git repository and applies changes automatically.

### Configuration

#### Environment Variables
Key services require environment-specific configuration:

- **GraphQL Engine**: Database connection, CORS settings
- **TimescaleDB**: PostgreSQL credentials, AI extensions
- **IPFS**: Storage paths, network configuration
- **Safe Content**: Content validation rules
- **Histocrawler**: Blockchain endpoints, indexing parameters
- **Image Guard**: Image scanning policies, security rules
- **RPC Proxy**: Upstream RPC endpoints, caching configuration
- **Consumers**: Event processing queues, database connections

#### Secrets Management
Secrets are managed through Kubernetes secrets and external secret providers:
- Database credentials
- API keys
- Service account tokens

### Monitoring & Observability

#### Health Checks
- Liveness probes configured for all services
- Readiness probes for database services
- Custom health endpoints for GraphQL and IPFS

#### Logging
- Structured logging enabled for GraphQL engine
- Query logging for debugging
- WebSocket and HTTP request logging

### Security

#### Network Security
- Private GKE cluster with private nodes
- VPC-native networking
- NAT gateway for outbound internet access
- Ingress controller for external access

#### Access Control
- Workload Identity for GCP service accounts
- Kubernetes RBAC
- ArgoCD project-based access control

### Development

#### Local Development
```bash
# Test Kustomize configurations
cd test-kustomize
kubectl kustomize . | kubectl apply --dry-run=client

# Validate manifests
kubectl kustomize apps/graphql/ | kubectl apply --dry-run=client
```

#### Adding New Services
1. Create service directory in `apps/`
2. Add Kubernetes manifests (deployment, service, etc.)
3. Create ArgoCD application definition
4. Update project permissions if needed

### CI/CD Pipeline

The deployment follows GitOps principles:
1. Code changes pushed to Git repository
2. ArgoCD detects changes automatically
3. Applications updated in Kubernetes cluster
4. Health checks validate deployment

### Scaling

#### Horizontal Scaling
- Application services can scale horizontally via HPA
- Database services use StatefulSets for data persistence
- IPFS and GraphQL support multiple replicas

#### Vertical Scaling
- Node pools can be resized via Terraform
- Storage volumes support online resizing
- Resource limits configured per service

### Troubleshooting

#### Common Issues
1. **Database Connection**: Check TimescaleDB service and secrets
2. **IPFS Storage**: Verify PVC and storage class
3. **GraphQL Health**: Check liveness probe and database connectivity
4. **ArgoCD Sync**: Verify repository access and permissions
5. **Consumer Processing**: Check event queue connectivity and processing status
6. **Histocrawler**: Verify blockchain endpoint accessibility
7. **Image Guard**: Check image scanning service health
8. **RPC Proxy**: Validate upstream RPC endpoint connectivity

#### Debug Commands
```bash
# Check pod status
kubectl get pods -A

# View logs
kubectl logs -f deployment/graphql-engine

# Check ArgoCD applications
argocd app list

# Validate Terraform state
terraform plan
```

### Additional Resources

- [GKE Documentation](https://cloud.google.com/kubernetes-engine/docs)
- [ArgoCD User Guide](https://argo-cd.readthedocs.io/)
- [TimescaleDB Documentation](https://docs.timescale.com/)
- [Hasura GraphQL Engine](https://hasura.io/docs/)
- [Hasura Documentation](https://hasura.io/docs/)
- [Alchemy Dashboard](https://dashboard.alchemy.com/)
- [Pinata Documentation](https://docs.pinata.cloud/)

### Next Steps

Once your node is running successfully:

1. **Monitor the logs** to ensure all services are healthy
2. **Test the CLI tool** to verify data ingestion
3. **Configure monitoring** for production deployments
4. **Join the network** and start contributing to the Intuition ecosystem

The node implementation is under active development, so check the repository regularly for updates and new features. 

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/kubernetes-deployment


# Run on Kubernetes Cluster

A comprehensive Kubernetes-based deployment infrastructure for blockchain indexing and data services, managed with ArgoCD and Terraform.

## Architecture Overview

This project deploys a complete blockchain indexing platform on Google Cloud Platform (GCP) using:

- **GKE Cluster**: Multi-node pool Kubernetes cluster
- **ArgoCD**: GitOps-based continuous deployment
- **Terraform**: Infrastructure as Code for GCP resources
- **Kustomize**: Kubernetes manifest management

## Core Services

### Data Layer
- **TimescaleDB**: Time-series database with PostgreSQL extensions and AI capabilities
- **Indexer Database**: Dedicated database for blockchain indexing operations

### Application Services
- **GraphQL Engine**: Hasura GraphQL API for data access
- **IPFS Node**: InterPlanetary File System for decentralized storage
- **Safe Content Service**: Content validation and processing
- **TimescaleDB Vectorizer Worker**: Vector processing for AI/ML workloads
- **Histocrawler**: Historical data crawling and indexing service
- **Image Guard**: Image validation and security service
- **RPC Proxy**: Blockchain RPC request routing and caching

### Consumer Services
- **Decoded Consumer**: Blockchain event decoding and processing
- **IPFS Upload Consumer**: IPFS content upload and management
- **Resolver Consumer**: Data resolution and lookup services

### Management Tools
- **pgAdmin**: PostgreSQL administration interface
- **Ingress Controller**: Traffic routing and load balancing

## Infrastructure Components

### GKE Cluster Suggested Configuration
- **Region**: `us-west2`
- **Project**: `be-cluster`
- **Network**: Custom VPC with private/public subnets
- **Node Pools**:
  - `db-pool`: n2-standard-16 (dedicated for databases)
  - `app-pool`: e2-standard-2 (application services)
  - `consumer-pool`: custom-4-8192 (data processing)

### Storage
- **Persistent Volumes**: GCP Persistent Disk with resizable storage class
- **IPFS Storage**: 50Gi persistent volume for IPFS data
- **Database Storage**: 50Gi for TimescaleDB

## Project Structure

```
gcp-deployment/
â”œâ”€â”€ apps/                    # Kubernetes applications
â”‚   â”œâ”€â”€ consumers/          # Data processing consumers
â”‚   â”‚   â”œâ”€â”€ decoded/        # Blockchain event decoder
â”‚   â”‚   â”œâ”€â”€ ipfs-upload/    # IPFS upload processor
â”‚   â”‚   â””â”€â”€ resolver/       # Data resolver service
â”‚   â”œâ”€â”€ graphql/            # Hasura GraphQL engine
â”‚   â”œâ”€â”€ histocrawler/       # Historical data crawler
â”‚   â”œâ”€â”€ image-guard/        # Image validation service
â”‚   â”œâ”€â”€ indexer-db/         # Indexer database
â”‚   â”œâ”€â”€ ipfs/               # IPFS node
â”‚   â”œâ”€â”€ pgadmin/            # PostgreSQL admin
â”‚   â”œâ”€â”€ rpc-proxy/          # RPC request proxy
â”‚   â”œâ”€â”€ safe-content/       # Content validation service
â”‚   â”œâ”€â”€ timescale_db/       # TimescaleDB instance
â”‚   â”œâ”€â”€ timescale_db_vectorizer/  # Vector processing
â”‚   â””â”€â”€ ingress/            # Ingress configuration
â”œâ”€â”€ argocd/                 # ArgoCD configuration
â”‚   â”œâ”€â”€ coreapps/           # Core application definitions
â”‚   â”œâ”€â”€ namespacedapps/     # Namespace-specific apps
â”‚   â”œâ”€â”€ projects/           # ArgoCD project definitions
â”‚   â””â”€â”€ repos/              # Repository secrets
â”œâ”€â”€ terraform/              # Infrastructure as Code
â”‚   â””â”€â”€ debug-gke/          # GKE cluster provisioning
â””â”€â”€ test-kustomize/         # Kustomize testing
```

## Quick Start

### Prerequisites
- Google Cloud SDK
- Terraform >= 1.0
- kubectl
- ArgoCD CLI

### 1. Deploy Infrastructure
```bash
cd terraform/debug-gke
terraform init
terraform plan
terraform apply
```

### 2. Configure ArgoCD
```bash
# Get GKE credentials
gcloud container clusters get-credentials debug-cluster --region us-west2

# Install ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Apply ArgoCD configuration
kubectl apply -f argocd/
```

### 3. Deploy Applications
Applications are automatically deployed via ArgoCD GitOps. The system monitors the Git repository and applies changes automatically.

## Configuration

### Environment Variables
Key services require environment-specific configuration:

- **GraphQL Engine**: Database connection, CORS settings
- **TimescaleDB**: PostgreSQL credentials, AI extensions
- **IPFS**: Storage paths, network configuration
- **Safe Content**: Content validation rules
- **Histocrawler**: Blockchain endpoints, indexing parameters
- **Image Guard**: Image scanning policies, security rules
- **RPC Proxy**: Upstream RPC endpoints, caching configuration
- **Consumers**: Event processing queues, database connections

### Secrets Management
Secrets are managed through Kubernetes secrets and external secret providers:
- Database credentials
- API keys
- Service account tokens

## Monitoring & Observability

### Health Checks
- Liveness probes configured for all services
- Readiness probes for database services
- Custom health endpoints for GraphQL and IPFS

### Logging
- Structured logging enabled for GraphQL engine
- Query logging for debugging
- WebSocket and HTTP request logging

## Security

### Network Security
- Private GKE cluster with private nodes
- VPC-native networking
- NAT gateway for outbound internet access
- Ingress controller for external access

### Access Control
- Workload Identity for GCP service accounts
- Kubernetes RBAC
- ArgoCD project-based access control

## Development

### Local Development
```bash
# Test Kustomize configurations
cd test-kustomize
kubectl kustomize . | kubectl apply --dry-run=client

# Validate manifests
kubectl kustomize apps/graphql/ | kubectl apply --dry-run=client
```

### Adding New Services
1. Create service directory in `apps/`
2. Add Kubernetes manifests (deployment, service, etc.)
3. Create ArgoCD application definition
4. Update project permissions if needed

## CI/CD Pipeline

The deployment follows GitOps principles:
1. Code changes pushed to Git repository
2. ArgoCD detects changes automatically
3. Applications updated in Kubernetes cluster
4. Health checks validate deployment

## Scaling

### Horizontal Scaling
- Application services can scale horizontally via HPA
- Database services use StatefulSets for data persistence
- IPFS and GraphQL support multiple replicas

### Vertical Scaling
- Node pools can be resized via Terraform
- Storage volumes support online resizing
- Resource limits configured per service

## Troubleshooting

### Common Issues
1. **Database Connection**: Check TimescaleDB service and secrets
2. **IPFS Storage**: Verify PVC and storage class
3. **GraphQL Health**: Check liveness probe and database connectivity
4. **ArgoCD Sync**: Verify repository access and permissions
5. **Consumer Processing**: Check event queue connectivity and processing status
6. **Histocrawler**: Verify blockchain endpoint accessibility
7. **Image Guard**: Check image scanning service health
8. **RPC Proxy**: Validate upstream RPC endpoint connectivity

### Debug Commands
```bash
# Check pod status
kubectl get pods -A

# View logs
kubectl logs -f deployment/graphql-engine

# Check ArgoCD applications
argocd app list

# Validate Terraform state
terraform plan
```

## Additional Resources

- [GKE Documentation](https://cloud.google.com/kubernetes-engine/docs)
- [ArgoCD User Guide](https://argo-cd.readthedocs.io/)
- [TimescaleDB Documentation](https://docs.timescale.com/)
- [Hasura GraphQL Engine](https://hasura.io/docs/)
- [Hasura Documentation](https://hasura.io/docs/)
- [Alchemy Dashboard](https://dashboard.alchemy.com/)
- [Pinata Documentation](https://docs.pinata.cloud/)

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/local-development-setup


Set up your local environment for developing and testing Intuition node services.

### Using Local Ethereum Node

Add to your `.env` file:
```bash
INTUITION_CONTRACT_ADDRESS=0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B
START_BLOCK=0
```

Create local test data:
```bash
cd integration-tests
npm install
npm run create-predicates
```

### Manual Service Management

```bash
# Start all services
docker-compose -f docker/docker-compose-apps.yml up -d

# Stop all services
./scripts/stop.sh

# View logs
docker-compose -f docker/docker-compose-apps.yml logs -f
```

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/overview


# Overview

Learn how to set up and run your own Intuition node to participate in the network using the official Rust implementation.

## What is an Intuition Node?

The `intuition-rs` workspace is a comprehensive Rust workspace for blockchain data indexing and processing, featuring a modular architecture with multiple specialized services. This implementation provides high performance, memory safety, and reliability for running Intuition nodes and backend services.

:::warning Node Requirements
Running an Intuition node requires Docker, Rust toolchain, and proper environment configuration. This guide provides comprehensive setup instructions for local development and production deployments.
:::

### Supported Contract Versions
- Multivault v2.0

## Why Run a Node?

Running your own Intuition node provides several key benefits:

- **Full Data Access**: Direct access to all blockchain data without relying on third-party services
- **Network Participation**: Actively contribute to the decentralization and resilience of the Intuition network
- **Custom Indexing**: Tailor data indexing and processing to your specific needs
- **Performance Control**: Optimize performance and resource allocation based on your requirements
- **Enhanced Privacy**: Process and query data without exposing your queries to external services
- **Development Freedom**: Ideal for building and testing applications in a controlled environment

## Architecture

This workspace contains the following core services:

### Event Processing Pipeline

The system processes blockchain events through multiple stages:

1. **RAW** - Raw event ingestion from blockchain
2. **DECODED** - Event decoding and parsing
3. **RESOLVER** - Data resolution and enrichment
4. **IPFS-UPLOAD** - Upload images to IPFS and track them in the local DB

## Prerequisites

### Required Tools

### Environment Configuration

You'll need to set up environment variables for various services. Create a `.env` file based on the `.env.sample` template with the following required variables:

| Variable | Description | Source |
|----------|-------------|---------|
| `OPENAI_API_KEY` | OpenAI API key for AI features | [OpenAI Platform](https://platform.openai.com/api-keys) |
| `PINATA_GATEWAY_TOKEN` | Pinata gateway token for IPFS | [Pinata Dashboard](https://app.pinata.cloud/developers/gateway-settings) |
| `PINATA_API_JWT` | Pinata API JWT for IPFS uploads | [Pinata Dashboard](https://app.pinata.cloud/developers/api-keys) |
| `BASE_MAINNET_RPC_URL` | Base mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `BASE_SEPOLIA_RPC_URL` | Base sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `ETHEREUM_MAINNET_RPC_URL` | Ethereum mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_MAINNET_RPC_URL` | Linea mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_SEPOLIA_RPC_URL` | Linea sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `TRUST_TESTNET_RPC_URL` | Trust testnet RPC endpoint (local geth) | Local development |
| `TRUST_MAINNET_RPC_URL` | Trust mainnet RPC endpoint (local geth) | Local development |
| `INDEXER_SCHEMA` | Database schema for indexer (set to "local") | Local development |
| `INTUITION_CONTRACT_ADDRESS` | Intuition contract address | Contract deployment |

## Next Steps

Once you understand the architecture and have the prerequisites ready:

1. Learn about [why we chose Rust](rust-backend.md) for the backend implementation
2. Follow the [Running a Node](run-an-intuition-node.md) guide to start your node
3. Explore [Local Development Setup](local-development-setup.md) for development workflows
4. Check [Kubernetes Deployment](kubernetes-deployment.md) for production deployments

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/run-an-intuition-node


# Get Started

**Note**: All scripts are located in the `scripts/` directory and should be run from the project root.

## Running the System

### Option 1: Using Published Docker Images (Recommended)

```bash
# Start with local Ethereum node
cargo make start-local
```

### Option 2: Building from Source

```bash
# Build all Docker images from source
cargo make build-docker-images

# Start the system
cargo make start-local
```

### Option 3: Running with Integration Tests

```bash
# Start with tests enabled
cargo make start-local test
```

## Testing

### Run All Tests
```bash
cargo nextest run
```

### Run Integration Tests
```bash
cd integration-tests
pnpm test src/follow.test.ts
```

### Run Specific Test Suites
```bash
# Test account operations
pnpm test src/create-person.test.ts

# Test vault operations
pnpm test src/vaults.test.ts

# Test AI agents
pnpm test src/ai-agents.test.ts
```

### Development Testing

#### CLI Tool
```bash
# Run the CLI to verify latest data
./scripts/cli.sh
```

#### Code Quality
```bash
# Format code
cargo make fmt

# Run linter
cargo make clippy

# Run all checks
cargo make check
```

#### Database Operations
```bash
# Start services and run migrations
cargo make start-docker-and-migrate

# Manual migration (if needed)
cp .env.sample .env
source .env
```

## Monitoring and Observability

### Logging

The system includes comprehensive logging capabilities:

**Features:**
- **Structured JSON Logging**: All services output machine-readable logs
- **Container Logs**: Direct access to service logs via Docker
- **Log Filtering**: Easy filtering by log level and service

**Benefits:**
- **Debugging**: Quickly find and analyze issues across services
- **Performance Monitoring**: Track service performance and bottlenecks
- **Audit Trail**: Complete visibility into system operations

**Getting Started:**
1. Start the system: `cargo make start-local`
2. View logs: `docker logs `
3. Filter logs: `docker logs  | grep '"level":"INFO"'`

**JSON Logging:**
All consumer services output structured JSON logs with the following fields:
- `timestamp`: ISO 8601 timestamp
- `level`: Log level (INFO, WARN, ERROR, DEBUG)
- `fields.message`: Log message content
- `target`: Module path
- `filename`: Source file name
- `line_number`: Line number in source file
- `threadId`: Thread identifier

**Viewing Logs:**
```bash
# View container logs directly
docker logs decoded_consumer | grep '"level":"INFO"'
docker logs resolver_consumer | grep '"level":"ERROR"'
docker logs ipfs_upload_consumer | grep '"level":"WARN"'
```

## Troubleshooting

### Common Issues

1. **Database connection errors**: Ensure PostgreSQL is running and credentials are correct
2. **RPC endpoint issues**: Verify your Alchemy endpoints are valid and have sufficient quota
3. **Docker resource limits**: Ensure Docker has sufficient memory and CPU allocation

### Getting Help

- Check the [intuition-rs repository](https://github.com/0xIntuition/intuition-rs) for latest updates
- Review the [DeepWiki documentation](https://deepwiki.com/0xIntuition/intuition-rs) for detailed technical information
- Join the Intuition community for support

## Next Steps

Once your node is running successfully:

1. **Monitor the logs** to ensure all services are healthy
2. **Test the CLI tool** to verify data ingestion
3. **Configure monitoring** for production deployments
4. **Join the network** and start contributing to the Intuition ecosystem

The node implementation is under active development, so check the repository regularly for updates and new features.

---

# 

Source: https://docs.intuition.systems/guides/intuition-node/rust-backend


# Rust Backend

## Why Rust?

The Intuition backend is built with Rust, a systems programming language that offers unique advantages for blockchain infrastructure:

## The Intuition Rust Monorepo

The `intuition-rs` repository is organized as a Rust workspace, which provides several key benefits:

### Monorepo Architecture
A monorepo (monolithic repository) consolidates all backend services and shared code in a single repository, offering:

- **Code sharing**: Common utilities and models shared across all services
- **Unified versioning**: All services stay in sync with compatible versions
- **Atomic changes**: Update multiple services in a single commit
- **Simplified dependencies**: Internal dependencies managed through workspace
- **Consistent tooling**: Shared build, test, and lint configurations

### Workspace Organization
The workspace is structured into logical layers:

#### Applications Layer (`apps/`)
Independent services that can be deployed separately:
- Each app has its own binary
- Shared dependencies managed at workspace level
- Services communicate through well-defined interfaces

#### Infrastructure Layer
Supporting services for data storage and APIs:
- Database migrations and schema management
- GraphQL API configuration
- Monitoring and observability tools

#### Shared Libraries
Common code used across multiple services:
- Domain models
- Utility functions
- Shared business logic

### Development Benefits
- **Faster builds**: Cargo caches dependencies and only rebuilds what changed
- **Type safety across services**: Shared types ensure compatibility
- **Easier refactoring**: Changes to shared code immediately show impact
- **Consistent testing**: Run all tests with a single command

## Project Structure

```
intuition-rs/
â”œâ”€â”€ apps/                 # Custom Rust applications
â”‚   â”œâ”€â”€ cli/             # Terminal UI client
â”‚   â”œâ”€â”€ consumer/        # Event processing pipeline (Redis Streams)
â”‚   â”œâ”€â”€ histocrawler/    # Historical data crawler
â”‚   â”œâ”€â”€ image-guard/     # Image processing service
â”‚   â”œâ”€â”€ models/          # Domain models & data structures
â”‚   â”œâ”€â”€ rpc-proxy/       # RPC proxy with caching
â”‚   â””â”€â”€ shared-utils/    # Common utilities
â”œâ”€â”€ infrastructure/      # Infrastructure components
â”‚   â”œâ”€â”€ hasura/         # GraphQL API & migrations
â”‚   â”œâ”€â”€ blockscout/     # Blockchain explorer
â”‚   â”œâ”€â”€ drizzle/        # Database schema management
â”‚   â”œâ”€â”€ geth/           # Local Ethereum node config
â”‚   â”œâ”€â”€ indexer-and-cache-migrations/  # Database migrations
â”‚   â”œâ”€â”€ migration-scripts/  # Migration utilities
â”‚   â””â”€â”€ prometheus/     # Monitoring configuration
â”œâ”€â”€ docker/             # Docker configuration
â”‚   â”œâ”€â”€ docker-compose-apps.yml   # Application services
â”‚   â”œâ”€â”€ docker-compose-shared.yml # Shared infrastructure
â”‚   â””â”€â”€ Dockerfile      # Multi-stage build
â”œâ”€â”€ scripts/            # Shell scripts
â”‚   â”œâ”€â”€ start.sh        # System startup
â”‚   â”œâ”€â”€ stop.sh         # System shutdown
â”‚   â”œâ”€â”€ cli.sh          # CLI runner
â”‚   â”œâ”€â”€ init-dbs.sh     # Database initialization
â”œâ”€â”€ integration-tests/  # End-to-end tests
â””â”€â”€ README.md          # Project documentation
```

### Core Applications

Terminal UI client for interacting with the Intuition system

Event processing pipeline using Redis Streams

Historical data crawler for blockchain indexing

Image processing and validation service

RPC call proxy with intelligent caching

Domain models and data structures

Common utilities used across services

### Infrastructure Components

The infrastructure layer provides essential services:

- **Hasura**: GraphQL API engine with database migrations
- **Blockscout**: Blockchain explorer for network transparency
- **Drizzle**: Type-safe database schema management
- **Geth**: Local Ethereum node for development
- **Prometheus**: Metrics collection and monitoring

### Development Tools

The repository includes comprehensive tooling:

- **Docker Compose**: Orchestrates all services for local development
- **Cargo Make**: Task automation and build scripts
- **Integration Tests**: End-to-end testing with pnpm
- **Shell Scripts**: Quick commands for common operations

---

# 

Source: https://docs.intuition.systems/guides/network


    Intuition Network
  
    Essential tools and applications for interacting with the Intuition ecosystem on the L3 network. From exploring the knowledge graph to bridging assets across networks.
    Enter

## What You'll Find Inside

Everything you need to build and test on Intuition's L3 network:

Build & Deploy

Deploy smart contracts, test transactions, and monitor your applications in a safe environment.

Connect & Test

Test APIs, validate SDK integrations, and explore the GraphQL playground with real data.

Monitor & Optimize

Track performance, monitor network health, and get test tokens to fuel your development.

## Getting Started

Ready to start building on Intuition? Follow these steps:

Use MetaMask or any Web3 wallet to connect to the testnet

Use the built-in faucet to obtain test tokens for transactions

Access all testnet tools and services from the centralized dashboard

Deploy your first smart contract or create your first atom

## Network Details

## Key Features

All testnet services are accessible from a single, intuitive interface that provides:

The hub integrates with all Intuition testnet services:

Built with developers in mind:

## Core Applications

Development environment hub for the Intuition testnet. Access all testnet services, tools, and resources in one centralized location.

Bridge assets between Ethereum testnets and Intuition testnet. Secure cross-chain transfers for testing and development purposes.

Real-time status monitoring for the Intuition network. Check service availability, network health, and uptime statistics.

The main interface for creating identities, making claims, and staking on the Intuition knowledge graph. Your gateway to the decentralized social network. Perfect for new users - start here to create your first identity and make claims.

Blockchain explorer for the Intuition testnet. View transactions, blocks, and network activity. Monitor testnet performance and verify test transactions.

Programmatic access to the Intuition network. Query blockchain data, submit transactions, and interact with smart contracts. Ideal for developers - use for programmatic access to the network.

## Support

Need help with any of these tools? Check out our [Community & Support](/docs/resources/community-and-support) page or [FAQ](/docs/resources/faq) for answers to common questions.

---

# 

Source: https://docs.intuition.systems/guides/network/mainnet


# Intuition Mainnet

:::info Coming Soon
The Intuition Mainnet is currently under development. Please use the [Testnet](/guides/network/testnet) for development and testing.
:::

## Stay Updated

Follow our progress and get notified when mainnet launches:

- [Twitter/X](https://x.com/0xintuition)
- [Discord](https://discord.gg/RgBenkX4mx)
- [GitHub](https://github.com/0xIntuition)

## Prepare for Mainnet

While you wait for mainnet, you can:

1. **Build on Testnet** - Develop and test your applications on our [testnet environment](/guides/network/testnet)
2. **Learn the Protocol** - Explore our [documentation](/guides) to understand the Intuition protocol
3. **Join the Community** - Connect with other developers in our [Discord](https://discord.gg/0xintuition)

---

# 

Source: https://docs.intuition.systems/guides/network/testnet/bridge


# Bridge

Secure cross-chain transfers between Ethereum testnets and the Intuition testnet. Built for testing and development, move assets safely between networks during the development process.

Open Bridge â†’

## Powered by Caldera's Metalayer

Intuition leverages **Caldera's Metalayer** infrastructure to provide seamless cross-chain bridging capabilities. As part of Caldera's **Internet of Chains**, we benefit from a robust, interconnected ecosystem of blockchain networks.

### What is Caldera's Metalayer?

The Metalayer is Caldera's innovative cross-chain infrastructure that enables:

- **Unified Bridging**: A single interface for transferring assets across multiple chains in the Caldera ecosystem
- **Shared Security**: Leveraging collective security models across interconnected chains
- **Interoperability**: Native communication between different blockchain networks without complex integrations
- **Simplified UX**: One-click bridging experiences that abstract away technical complexity

### The Internet of Chains

Caldera's Internet of Chains represents a new paradigm in blockchain connectivity:

- **Network Effects**: Each new chain added to the ecosystem increases the value for all participants
- **Composability**: Applications can seamlessly interact across different chains without friction
- **Shared Liquidity**: Assets can flow freely between chains, improving capital efficiency
- **Unified Standards**: Common protocols and standards across all connected chains

### Benefits for Intuition Users

By being part of this ecosystem, Intuition users gain:

- **Access to Multiple Networks**: Bridge assets from any chain in the Caldera network
- **Lower Costs**: Shared infrastructure reduces operational costs
- **Enhanced Security**: Battle-tested bridge infrastructure used by multiple production networks
- **Future Connectivity**: Automatic access to new chains as they join the ecosystem

### How It Works

The Metalayer uses advanced cryptographic techniques and consensus mechanisms to ensure:

1. **Asset Security**: Multi-signature validation and fraud proofs protect bridged assets
2. **Fast Finality**: Optimized confirmation times for cross-chain transfers
3. **Reliability**: Redundant infrastructure ensures high availability
4. **Transparency**: All bridge operations are verifiable on-chain

### Learn More

- [Caldera Documentation](https://docs.caldera.xyz)
- [Internet of Chains Overview](https://caldera.xyz/internet-of-chains)
- [Bridge Technical Specifications](https://docs.caldera.xyz/metalayer) 

---

# 

Source: https://docs.intuition.systems/guides/network/testnet/data-populator


# Data Populator

The **Intuition Data Populator** is a specialized tool designed to help users and developers efficiently populate the Intuition knowledge graph with high-quality, structured data. This application streamlines the process of creating atoms, triples, and establishing meaningful relationships within the decentralized knowledge network.

## Why did we create the Data Populator?

Do you have a large amount of data you want to add to the Intuition System, but not enough time or patience to manually create each data point as an atom or triple in the Portal? Look no further! The Data Populator V1 is here!

## What it does, in brief

You can use the Data Populator to load CSV files which contain long lists of atom data. The user interface will allow you to perform some basic proofreading of the data, and when you're ready you can submit it to the Intuition System in one fell swoop. This works by batching all of the atom data together into very large EVM transactions, after automatically pinning and filtering the metadata onto IPFS. This is very similar to the behavior in the Portal App, except it's designed to work with much larger volumes of data.

## Where you can access it

There are two deployments for the Data Populator - one for testing, which runs on Base Sepolia, and one for production which runs on Base.

- **Testnet Data Populator**: [https://data-populator-dev.onrender.com](https://data-populator-dev.onrender.com)
- **Mainnet Data Populator**: [https://upload.intuition.systems](https://upload.intuition.systems)

It's strongly recommended, especially for first time users, to start off with the **Testnet** version to verify everything looks good with your data before spending real Base Ethereum on populating it.

## Overview

The Data Populator serves as a bridge between traditional data sources and the Intuition ecosystem, enabling users to:

- **Bulk import data** - Efficiently create multiple atoms and triples from structured datasets
- **Validate data quality** - Ensure imported data meets Intuition's standards and requirements
- **Establish relationships** - Create meaningful connections between imported entities
- **Maintain data integrity** - Preserve the semantic structure and provenance of imported information

## Key Features

### ðŸ”„ **Bulk Data Import**
- Import large datasets in various formats (CSV, JSON, XML)
- Automated atom and triple creation from structured data
- Batch processing for efficient handling of large datasets
- Progress tracking and error reporting

### âœ… **Data Validation**
- Automatic validation of data structure and format
- Quality checks for imported atoms and triples
- Duplicate detection and resolution
- Semantic consistency verification

### ðŸ”— **Relationship Mapping**
- Automatic creation of triples based on imported relationships
- Support for complex relationship structures
- Mapping of traditional data schemas to Intuition's semantic model
- Preservation of data provenance and metadata

### ðŸŽ¯ **Quality Assurance**
- Data quality scoring and reporting
- Conflict resolution for conflicting claims
- Automated tagging and categorization
- Integration with Intuition's trust mechanisms

## Use Cases

### ðŸŽ“ **Academic Research**
- Import research datasets and establish connections between findings
- Create atoms for research entities, methodologies, and conclusions
- Build knowledge graphs for specific research domains
- Enable collaborative research through shared knowledge structures

### ðŸ’¼ **Business Intelligence**
- Import organizational data and establish entity relationships
- Create comprehensive knowledge graphs for business domains
- Enable data-driven decision making through structured insights
- Facilitate cross-organizational knowledge sharing

### ðŸ“š **Content Curation**
- Import content from various sources and establish semantic relationships
- Create comprehensive knowledge graphs for specific domains
- Enable content discovery and recommendation systems
- Build curated collections of related information

## Instruction Guide

### Authentication

The first thing you will need to do, if you haven't already, is authenticate and log into the system. If you are not authenticated yet, you will be shown a **Connect** button. Click the connect button and authorize using your method of choice. Follow the prompts shown on screen to complete the log-in process.

### User Interface Overview

After logging in, you'll see the main interface with:

- **Top menu bar**: Contains a helpful tooltip toggle button and a history button
- **Version indicator**: Shows which version of the Data Populator app you're using (TESTNET or MAINNET)
- **Four main tabs**: Select Atom Type, Load CSV, Publish Atoms, and Tag Atoms

### Select Atom Type

As of right now, you have 3 options here. Most users can stick with the default value of **Schema.org &lt;Thing&gt;** to create and tag basic metadata atoms. If you want to populate **CAIP-10** atoms or **Raw URI** atoms, you can select either option from the drop-down before pressing **Continue**.

#### **Schema.org &lt;Thing&gt;**

We currently support 1 type from schema.org, the **&lt;Thing&gt;**. Most of the atoms in the Intuition Portal are **&lt;Thing&gt;**s. The **&lt;Thing&gt;** has 6 fields:

| Field | Description |
|-------|-------------|
| @context | This will always be [https://schema.org](https://schema.org/) - it's used to identify where the metadata type is defined |
| @type | This will always be **&lt;Thing&gt;** - it's used to determine which metadata type is being used |
| name | This is the name of your atom. This could be the name of an article, person, place, or thing |
| description | A description of your atom. This is a more in-depth blob of text which helps people understand the thing being referenced |
| image | A URL pointing to an image for your atom. This might point to a logo, a twitter avatar, or anything which visually demonstrates the thing being referenced |
| url | A URL pointing to a website for your atom. This could be a social media profile, the website for a business, an article, or anything else on the web |

#### **CAIP-10**

A `CAIP-10` is a string of text which is used to reference smart contracts. `CAIP-10` atoms comprise of only one variable, the `CAIP-10` itself. The `CAIP-10` identifier is comprised of 4 `:` delimited values:

`CAIP10` `:` `[NAMESPACE]` `:` `[CHAIN_ID]` `:` `[ADDRESS]`

**Examples:**
```
# Ethereum mainnet (canonicalized with EIP-55 checksum)
CAIP10:eip155:1:0xab16a96D359eC26a11e2C2b3d8f8B8942d5Bfcdb

# Bitcoin mainnet
CAIP10:bip122:000000000019d6689c085ae165831e93:128Lkh3S7CkDTBZ8W7BbpsN3YYizJMp8p6

# Cosmos Hub
CAIP10:cosmos:cosmoshub-3:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0
```

You can read more about the `CAIP-10` standard here: [https://chainagnostic.org/CAIPs/caip-10](https://chainagnostic.org/CAIPs/caip-10)

#### **Raw URI**

The `Intuition System` also uses `Raw URI`s. These cannot be proofread, and are for advanced users only. One example use case for these is the [https://schema.org/keywords](https://schema.org/keywords) `Raw URI`. The `Intuition Portal` uses this as a `Predicate` in `Semantic Triples` in order to denote that something has a `Tag Keyword`.

### Load CSV

The `Load CSV` box allows you to load a `.csv` file from your PC which contains numerous `Atom`s. 

#### **Schema.org &lt;Thing&gt; CSV Example:**

```csv
@context,@type,name,url,description,image
https://schema.org,Thing,Google,https://www.google.com,"A website where you can search for stuff.",https://google.com/google_logo.jpg
https://schema.org,Thing,Facebook,https://www.facebook.com,"A social media website.",https://facebook.com/facebook_logo.jpg
```

#### **CAIP-10 CSV Example:**

```csv
CAIP10
eip155:1:0x1234567890abcdef1234567890aBcdef12345678
eip155:1:0x1234567890abcfeF1234567890aBCDEf12345675
eip155:1:0x1234567890aBcdeF1234567890AbcDef12345672
```

**Important Notes:**
- The column order, capitalization, and naming is crucial - ensure it matches the specification before exporting
- If there's anything weird going on with your `.csv` file, the Data Populator will show you a `Proofreading` window which flags any unusual characters or errors
- The application will attempt to fix any errors on its own, and can automatically checksum Ethereum addresses

### Publish Atoms

The `Publish Atoms` tab shows you some basic information about the `Atoms` you have loaded. Once you've reviewed them, you can select them and `publish` them using the `Publish Selected Atoms` button.

**Publishing Process:**
1. Select atoms using the checkbox on the left of their rows
2. Press `Publish Selected Atoms`
3. Confirm the transaction in the dialog
4. Approve the EVM transaction in your wallet
5. Wait for confirmation and see green "Atom Already Exists" icons

### Atoms View

The `Atoms View` appears below all four tabs in the application, and displays the `Atoms` you currently have loaded. It has several features:

- **Edit and Preview**: Cells can be selected and freely edited
- **Sort Data**: Click on any column header to sort the data
- **Duplicate Detection**: Identify partial duplicates before publishing
- **Delete Rows**: Select unwanted rows and press `Delete Row`
- **Save CSV**: Save a new copy to your PC after making edits
- **Add New Row**: Manually enter atom data directly into the Data Populator

### Tag Atoms

If you want to add your newly published `Atoms` to a `List`, you can use the `Tag Atoms` feature:

1. **Create the Tag**: Fill out the tag metadata fields and press `Create Tag`
2. **Publish Tag**: The tag will be published as another `Atom` in the system
3. **Tag Selected Atoms**: Once the tag exists, press `Tag Selected Atoms` to associate your atoms with it

**Important**: Be precise while entering metadata. Each `Atom's` uniqueness is determined by the exact contents of its data.

### History Window

If you press the `View Your History` button near the top-right corner of the screen, a new window will appear showing:

- History of all the `Atoms`, `Triples` (`Tags`), and `Requests` that you've submitted
- Ability to `Save` `.csv` files that you've previously submitted
- Helpful when working on multiple machines or collaborating with others

## Getting Started

### **Prerequisites**
- Access to the Intuition network
- Structured data in supported formats
- Understanding of Intuition's atom and triple concepts
- Familiarity with the data you want to import

### **Installation**
The Data Populator is available as a web application and can be accessed through the Intuition ecosystem.

### **Basic Workflow**

1. **Prepare your data** - Ensure your data is in a supported format and properly structured
2. **Validate data** - Use the built-in validation tools to check data quality
3. **Map relationships** - Define how your data relationships should be represented as triples
4. **Import data** - Execute the import process with appropriate settings
5. **Review results** - Check the imported atoms and triples for accuracy
6. **Iterate** - Refine your import process based on results

## Data Formats

### ðŸ“„ **Supported Formats**
- **CSV** - Comma-separated values with headers
- **JSON** - Structured JSON objects and arrays
- **XML** - Extensible Markup Language documents
- **Excel** - Microsoft Excel spreadsheets

### ðŸ“‹ **Data Structure Requirements**
- Clear entity identification
- Relationship definitions
- Metadata and provenance information
- Quality indicators and confidence scores

## Best Practices

### Data Preparation
- Clean and normalize your data before import
- Ensure consistent naming conventions
- Validate data quality and completeness
- Document data sources and transformation processes

### Relationship Mapping
- Clearly define how traditional relationships map to triples
- Consider the semantic meaning of relationships
- Plan for relationship validation and verification
- Account for relationship confidence and uncertainty

### Quality Control
- Implement comprehensive validation checks
- Monitor import success rates and error patterns
- Establish feedback loops for continuous improvement
- Maintain data provenance and audit trails

## Integration

### With Intuition Portal
- Imported data appears in the Portal for user interaction
- Users can stake on imported atoms and triples
- Integration with Portal's tagging and list features
- Support for Portal's social features and user interactions

### With Developer Tools
- Programmatic access to imported data through APIs
- Integration with custom applications and workflows
- Support for automated data processing and analysis
- Compatibility with Intuition's developer ecosystem

## Advanced Features

### Custom Mappings
- Define custom mapping rules for complex data structures
- Support for domain-specific ontologies and schemas
- Flexible relationship mapping and transformation
- Integration with external data sources and APIs

### Automated Processing
- Scheduled data imports and updates
- Real-time data synchronization
- Automated quality monitoring and reporting
- Integration with external data pipelines

### Analytics and Reporting
- Import statistics and success rates
- Data quality metrics and trends
- Usage analytics and impact assessment
- Performance monitoring and optimization

## Development

The Data Populator is part of the Intuition ecosystem and follows the same development principles:

- **Open source** - Available for community contribution and improvement
- **Modular design** - Flexible architecture for custom extensions
- **API-first** - Programmatic access for integration with other tools
- **Community-driven** - Development guided by user needs and feedback

## Getting Help

For support with the Data Populator:

- Check the [Intuition documentation](/guides) for detailed guides
- Visit the [GitHub repository](https://github.com/0xIntuition) for technical details
- Join the [community discussions](https://discord.gg/intuition) for user support
- Review the [API documentation](/guides/developer-tools) for integration help

## Getting Started

### ðŸš€ **Ready to populate your data?**

**[Testnet Data Populator](https://data-populator-dev.onrender.com)** - Start here for testing

**[Mainnet Data Populator](https://upload.intuition.systems)** - Production environment

## Related Resources

**[Portal](/guides/network/testnet/portal)** - Main interface for interacting with the knowledge graph

**[Explorer](/guides/network/testnet/explorer)** - Network exploration and transaction monitoring

**[Developer Tools](/guides/developer-tools)** - Programmatic access and integration

**[API Documentation](/guides/developer-tools/graphql-api)** - Technical integration guides


---

# 

Source: https://docs.intuition.systems/guides/network/testnet/explorer


# Explorer

The Intuition Explorer is a comprehensive blockchain explorer built on Blockscout, providing detailed insights into all network activity on the Intuition testnet. Monitor transactions, explore blocks, and analyze network performance with this powerful exploration tool.

## Quick Access

Access the Explorer directly at: [https://intuition-testnet.hub.caldera.xyz/](https://intuition-testnet.hub.caldera.xyz/)

## Overview

The Explorer serves as your window into the Intuition testnet blockchain, offering:

- Real-time transaction monitoring
- Block exploration and analysis
- Smart contract verification
- Network statistics and metrics
- Token tracking and transfers

## Key Features

### **Transaction Monitoring**
- View all network transactions in real-time
- Search transactions by hash, address, or block
- Monitor transaction status and confirmations
- Analyze gas usage and fees
- Track internal transactions and contract calls

### **Block Exploration**
- Browse the latest blocks
- View block details and included transactions
- Monitor network utilization
- Track block production times
- Analyze block rewards and fees

### **Smart Contract Features**
- Verify and publish smart contract source code
- Read contract state and interact with functions
- View contract creation and deployment history
- Monitor contract events and logs
- Track contract token transfers

### **Network Analytics**
- Real-time network statistics
- Gas price tracking and recommendations
- Network utilization metrics
- Transaction volume analysis
- Active address monitoring

## Navigation Guide

### **Homepage Dashboard**
The explorer homepage provides:
- Latest blocks and transactions
- Network utilization status
- Gas tracker with current prices
- Key network statistics
- Quick search functionality

### **Transaction Details**
Each transaction page shows:
- Transaction hash and status
- Block number and position
- Gas used and gas price
- Input data and logs
- Token transfers (if applicable)

### **Block Information**
Block pages display:
- Block hash and parent hash
- Block height and timestamp
- Transaction count and gas used
- Miner/validator information
- Block rewards and fees

### **Address Pages**
Address exploration includes:
- Balance and transaction history
- Token holdings and transfers
- Contract code (if applicable)
- Internal transactions
- Analytics and statistics

## Search Functionality

### **Supported Searches**
- Transaction hashes
- Block numbers or hashes
- Wallet addresses
- Contract addresses
- Token contract addresses

### **Advanced Filters**
- Filter transactions by type
- Sort by timestamp, value, or gas
- Filter by token transfers
- Search within specific time ranges

## API Access

### **REST API**
The explorer provides REST API access for:
- Transaction data retrieval
- Block information queries
- Address balance checks
- Contract interaction history
- Network statistics

### **GraphQL API**
Advanced querying capabilities through GraphQL:
- Complex data relationships
- Batch queries
- Real-time subscriptions
- Custom data aggregations

### **RPC Endpoints**
Standard Ethereum RPC methods:
- `eth_getBalance`
- `eth_getTransactionByHash`
- `eth_getBlockByNumber`
- Custom Intuition-specific methods

## Monitoring Network Health

### **Network Status Indicators**
- Green: All systems operational
- Yellow: Some delays or issues
- Red: Network problems detected

### **Performance Metrics**
Track important network health indicators:
- Average block time
- Transaction throughput
- Gas price trends
- Network congestion levels

### **Gas Tracker**
Monitor gas prices for optimal transaction timing:
- Current gas prices
- Historical gas trends
- Gas price recommendations
- Network congestion impact

## Developer Tools

### **Contract Verification**
Submit your smart contracts for verification:
1. Navigate to "Verify contract" section
2. Upload source code and compilation details
3. Provide constructor arguments
4. Submit for verification
5. View verified contract on explorer

### **API Integration**
Integrate explorer data into your applications:
- Real-time transaction monitoring
- Address balance tracking
- Contract event listening
- Network analytics integration

### **Testing and Debugging**
Use the explorer for development:
- Verify transaction execution
- Debug failed transactions
- Monitor contract interactions
- Track token transfers

## Common Use Cases

### **Transaction Verification**
- Confirm transaction completion
- Check transaction details and status
- Verify gas usage and fees
- Review transaction logs and events

### **Contract Monitoring**
- Track smart contract interactions
- Monitor contract state changes
- Verify contract deployments
- Debug contract execution

### **Network Analysis**
- Study network performance trends
- Analyze transaction patterns
- Monitor network congestion
- Track validator performance

## Integration with Other Tools

### **Bridge**
- View bridge transactions
- Track cross-chain transfers
- Monitor bridge contract interactions
- Verify asset movements

### **Hub**
- Quick access from hub dashboard
- Integrated transaction links
- Real-time status updates
- Development workflow integration

### **Developer Tools**
- SDK transaction verification
- API testing and validation
- Smart contract debugging
- Performance optimization

## Support and Resources

### **Getting Help**
- [Community & Support](/guides/resources/community-and-support) for explorer questions
- [FAQ](/guides/resources/faq) for common issues
- [Developer Tools](/guides/developer-tools) for technical integration

### **Additional Resources**
- Blockscout documentation
- API reference guides
- Integration examples
- Best practices for monitoring

## Next Steps

- Monitor your transactions and contracts
- Integrate explorer APIs into your applications
- Use with [Bridge](/guides/network/testnet/bridge) for cross-chain verification
- Check [Network Health](/guides/resources/network-health) for service health 

---

# 

Source: https://docs.intuition.systems/guides/network/testnet/farcaster-frames


# Farcaster Frames

The **Intuition Farcaster Frames** integration brings the power of Intuition's knowledge graph directly into the Farcaster social network. This integration enables users to create, verify, and interact with Intuition atoms and triples through interactive frames embedded in Farcaster posts, creating a seamless bridge between social media and decentralized knowledge.

## Overview

Farcaster Frames provide an interactive way for users to engage with Intuition's knowledge graph without leaving the Farcaster platform. Users can:

- **Create identities** - Generate Intuition atoms directly from Farcaster posts
- **Make claims** - Create triples and assertions through interactive frames
- **Stake on content** - Participate in the Token Curated Registry via frame interactions
- **Verify information** - Check the authenticity of claims and identities
- **Build reputation** - Establish credibility through social interactions

## Key Features

### Interactive Identity Creation

- Create Intuition atoms through simple frame interactions
- Add metadata and descriptions to identities
- Link Farcaster profiles to Intuition identities
- Build reputation through social validation

### Claim Verification

- Verify claims and assertions through frame interactions
- Stake on claims to express agreement or disagreement
- View community sentiment and staking activity
- Access detailed claim analytics and provenance

### Social Integration

- Seamless integration with Farcaster's social features
- Cross-platform identity and reputation building
- Social proof through community interactions
- Viral content discovery and sharing

### Trust Network Building

- Connect Farcaster users through Intuition's trust network
- Build reputation through social interactions
- Access personalized recommendations based on your network
- Establish credibility through community validation

## How It Works

### Frame Structure

Farcaster Frames are interactive HTML elements embedded in Farcaster posts that enable users to:

1. **View Information** - Display Intuition data and claims
2. **Take Actions** - Create atoms, make claims, or stake on content
3. **Get Results** - Receive confirmation and view outcomes
4. **Share Results** - Post outcomes back to Farcaster

### Integration Flow

1. **Frame Creation** - Developers create frames with Intuition functionality
2. **User Interaction** - Users interact with frames in Farcaster posts
3. **Blockchain Action** - Frame triggers Intuition blockchain transactions
4. **Result Display** - Frame shows transaction results and next steps
5. **Social Sharing** - Users can share results back to Farcaster

## Use Cases

### Content Creators

- **Create Brand Identities** - Establish verified identities for your content
- **Make Claims** - Assert expertise and achievements through frames
- **Build Reputation** - Earn reputation through community validation
- **Monetize Content** - Stake on your own content and earn rewards

### Researchers and Academics

- **Share Research** - Create atoms for research findings and methodologies
- **Verify Claims** - Use frames to verify research claims and relationships
- **Build Credibility** - Establish academic reputation through community validation
- **Collaborate** - Connect with other researchers through the trust network

### Business and Organizations

- **Establish Credibility** - Create verified organizational identities
- **Share Achievements** - Make claims about partnerships and accomplishments
- **Build Trust** - Leverage social proof for business relationships
- **Network** - Connect with partners and customers through the trust network

### Developers and Builders

- **Integrate Intuition** - Add Intuition functionality to your Farcaster apps
- **Build Frames** - Create custom frames with Intuition features
- **Access Data** - Use Intuition data in your applications
- **Contribute** - Help build the Intuition ecosystem

## Frame Types

### Identity Creation Frames

- **Simple Identity** - Basic atom creation with minimal metadata
- **Rich Identity** - Detailed atom creation with extensive metadata
- **Profile Linking** - Link Farcaster profiles to Intuition identities
- **Verification** - Verify existing identities through social proof

### Claim Creation Frames

- **Simple Claim** - Basic triple creation with three atom references
- **Rich Claim** - Detailed claim creation with evidence and context
- **Claim Discovery** - Search and discover existing claims
- **Claim Verification** - Verify claims through community validation

### Staking Frames

- **Positive Staking** - Stake on claims to express agreement
- **Negative Staking** - Stake against claims to express disagreement
- **Vault Overview** - View vault statistics and your position
- **Performance Tracking** - Monitor staking performance and returns

### Social Frames

- **Follow User** - Follow other users and build your network
- **Reputation Check** - View reputation scores and trust relationships
- **Recommendations** - Get personalized content recommendations
- **Network Analysis** - Analyze your trust network and connections

## Technical Implementation

### Frame Development

Frames are built using standard web technologies:

```html

    Intuition Identity Creation
  
      Create Your Identity
      
```

### SDK Integration

The Intuition Frame SDK provides easy integration:

```javascript
// Initialize the Intuition Frame SDK
const intuitionFrame = new IntuitionFrame({

---

# 

Source: https://docs.intuition.systems/guides/network/testnet


# Intuition Testnet

Welcome to the Intuition Testnet - your development and testing environment for building on the Intuition Network.

## Network Configuration

| Parameter | Value |
|-----------|-------|
| **Network Name** | Intuition Testnet |
| **Chain ID** | 13579 |
| **Native Token** | $TTRUST |
| **RPC URL** | `https://testnet.rpc.intuition.systems/http` |
| **WebSocket URL** | `wss://testnet.rpc.intuition.systems/ws` |
| **Block Explorer** | [https://explorer.intuition.systems](https://explorer.intuition.systems) |

## Available Tools

The testnet provides all the tools you need for development:

- [**Bridge**](./bridge) - Transfer assets between networks
- [**Explorer**](./explorer) - View transactions and blocks
- [**Portal**](./portal) - Create identities and make claims
- [**RPC Endpoints**](./rpc) - Connect your applications
- [**Data Populator**](./data-populator) - Generate test data
- [**Farcaster Frames**](./farcaster-frames) - Social integration tools
- [**MetaMask Snap**](./metamask-snap) - Wallet integration

## Getting Started

1. **Connect to the Network** - Add the testnet to your wallet using the network configuration above
2. **Get Test Tokens** - Visit the faucet to receive test $TTRUST tokens
3. **Start Building** - Use the tools and documentation to build your application

## Support

Need help? Join our [Discord](https://discord.gg/RgBenkX4mx) community for support.

---

# 

Source: https://docs.intuition.systems/guides/network/testnet/metamask-snap


# MetaMask Snap

The **Intuition MetaMask Snap** extends MetaMask's functionality to seamlessly integrate with the Intuition knowledge graph. This Snap enables users to interact with Intuition's decentralized identity and reputation system directly through their MetaMask wallet, providing a familiar and secure interface for managing atoms, triples, and staking operations.

## Overview

The MetaMask Snap serves as a bridge between traditional Web3 wallet functionality and Intuition's knowledge graph, enabling users to:

- **Manage identities** - Create and manage Intuition atoms directly from MetaMask
- **Make claims** - Create triples and assertions about entities in the knowledge graph
- **Stake on content** - Participate in the Token Curated Registry by staking on atoms and triples
- **Access trust networks** - View and interact with reputation and trust data
- **Cross-platform integration** - Use Intuition features across any dApp that supports MetaMask

## Key Features

### ðŸ†” **Identity Management**

- Create and manage Intuition atoms (identities) directly from MetaMask
- View your created atoms and their associated vaults
- Manage atom metadata and relationships
- Export and backup identity data

### ðŸ“ **Claim Creation**

- Create triples (claims) using the Subject-Predicate-Object structure
- Stake on existing claims to express agreement or disagreement
- View claim details and associated vault information
- Manage your claim portfolio and staking positions

### ðŸ’° **Staking Operations**

- Deposit ETH into atom and triple vaults
- Withdraw staked amounts and earned fees
- View staking history and performance metrics
- Monitor vault share prices and market dynamics

### ðŸ¤ **Trust Network Integration**

- View reputation scores and trust relationships
- Follow other users and build your social graph
- Access personalized recommendations based on your network
- Verify claims and identities through the trust network

## Installation

### **Prerequisites**

- MetaMask wallet installed in your browser
- Access to the Intuition network
- Understanding of basic Intuition concepts (atoms, triples, vaults)

### **Installation Steps**

1. **Open MetaMask** - Ensure you have MetaMask installed and unlocked
2. **Navigate to Snaps** - Go to the MetaMask Snaps directory or use the direct installation link
3. **Install Intuition Snap** - Click "Install" on the Intuition MetaMask Snap
4. **Grant Permissions** - Approve the necessary permissions for the Snap to function
5. **Connect to Intuition** - Link your MetaMask wallet to the Intuition network
6. **Start Using** - Begin creating identities, making claims, and staking on content

## Getting Started

### First-Time Setup

1. **Create Your First Identity** - Use the Snap to create your first atom (identity)
2. **Make Your First Claim** - Create a triple to make an assertion about something
3. **Stake on Content** - Deposit ETH to signal agreement with existing claims
4. **Build Your Network** - Follow other users and build your trust network

### Basic Workflow

1. **Access the Snap** - Open MetaMask and navigate to the Intuition Snap
2. **Choose an Action** - Select from Create Identity, Make Claim, or Stake
3. **Fill in Details** - Provide the necessary information for your chosen action
4. **Confirm Transaction** - Review and approve the transaction in MetaMask
5. **Monitor Results** - Track your transaction and view the results

## Features in Detail

### Identity Creation

- **Simple Interface** - Easy-to-use forms for creating atoms
- **Metadata Support** - Add rich metadata to your identities
- **IPFS Integration** - Automatic upload of identity data to IPFS
- **Vault Association** - Each identity gets its own vault for staking

### Claim Management

- **Triple Creation** - Create Subject-Predicate-Object relationships
- **Claim Discovery** - Search and discover existing claims
- **Staking Interface** - Easy staking on positive or negative vaults
- **Claim Analytics** - View claim performance and community sentiment

### Staking Interface

- **Vault Overview** - View total assets, share prices, and your position
- **Deposit/Withdraw** - Simple interface for staking and unstaking
- **Fee Tracking** - Monitor earned fees and performance
- **Market Data** - Real-time vault statistics and trends

### Trust Network

- **Reputation Scores** - View trust scores for entities and users
- **Social Connections** - Follow users and build your network
- **Recommendations** - Get personalized content recommendations
- **Verification** - Verify claims and identities through the network

## Security Features

### Wallet Integration

- **Secure Storage** - All Intuition data stored securely in MetaMask
- **Private Keys** - Your private keys never leave MetaMask
- **Transaction Signing** - All transactions signed through MetaMask's secure interface
- **Permission Management** - Granular control over Snap permissions

### Network Security

- **Blockchain Verification** - All operations verified on the Intuition blockchain
- **Immutable Records** - All atoms and triples permanently recorded
- **Audit Trail** - Complete transaction history and provenance
- **Fraud Prevention** - Built-in mechanisms to prevent malicious activity

## Use Cases

### Content Creators

- Create identities for your content and brand
- Make claims about your expertise and achievements
- Build reputation through community staking
- Monetize your knowledge and contributions

### Researchers

- Create atoms for research entities and findings
- Make claims about research relationships and conclusions
- Build collaborative knowledge graphs
- Establish credibility through community validation

### Business Users

- Create organizational identities and relationships
- Make claims about business partnerships and achievements
- Build trust networks with partners and customers
- Leverage reputation for business opportunities

### Developers

- Integrate Intuition features into your dApps
- Access trust and reputation data programmatically
- Build applications that leverage the knowledge graph
- Contribute to the Intuition ecosystem

## Advanced Features

### API Integration

- **Programmatic Access** - Use the Snap's API for custom integrations
- **Webhook Support** - Receive notifications for important events
- **Data Export** - Export your Intuition data for external use
- **Custom Interfaces** - Build custom interfaces using the Snap's capabilities

### Analytics and Reporting

- **Performance Tracking** - Monitor your staking performance and returns
- **Network Analysis** - Analyze your trust network and connections
- **Claim Analytics** - Track the performance of your claims
- **Reputation Metrics** - Monitor your reputation score and trends

### Automation

- **Automated Staking** - Set up automated staking strategies
- **Claim Monitoring** - Get alerts for important claim updates
- **Portfolio Management** - Automated portfolio rebalancing
- **Social Automation** - Automated following and network building

## Troubleshooting

### Common Issues

- **Installation Problems** - Ensure MetaMask is up to date and properly configured
- **Transaction Failures** - Check gas settings and network connectivity
- **Permission Errors** - Review and update Snap permissions as needed
- **Sync Issues** - Refresh the Snap to sync with the latest blockchain state

### Getting Help

- **Documentation** - Review this guide and related documentation
- **Community Support** - Join the Intuition community for user support
- **Technical Support** - Contact the development team for technical issues
- **GitHub Issues** - Report bugs and feature requests on GitHub

## Development

The MetaMask Snap is open source and welcomes contributions:

- **GitHub Repository** - [https://github.com/0xIntuition/intuition-snap](https://github.com/0xIntuition/intuition-snap)
- **Documentation** - Comprehensive developer documentation
- **Testing** - Extensive test suite and quality assurance
- **Community** - Active development community and support

## Related Resources

- [Portal](/guides/network/testnet/portal) - Main web interface for Intuition
- [Browser Extension](/guides/network/testnet/browser-extension) - Chrome extension for web browsing
- [Developer Tools](/guides/developer-tools) - Programmatic access and integration
- [API Documentation](/guides/developer-tools/graphql-api) - Technical integration guides
- [Community](https://discord.gg/0xintuition) - Join the Intuition community

---

# 

Source: https://docs.intuition.systems/guides/network/testnet/portal


# The Intuition Portal

The Portal is Intuition's first Explorer (akin to a block explorer), which provides users with easy access to the social and knowledge graph. Positioned at the application layer, the Portal offers an intuitive interface for users to create, manage, and interact with Identities (Atoms) and Claims (Triples). It serves as the gateway for creating decentralized identities, making claims, and managing your stake, transforming the exploration of the knowledge graph into an accessible and user-friendly experience.

While most explorers are only meant for exploring, The Portal also provides a user interface for easily interacting with the Intuition Graph in its entirety.

### ðŸ“‹ **Covered in this guide:**

This guide provides step-by-step instructions for The Portal's core features:

- **Creating Identities** - Build your digital presence
- **Creating Claims** - Make assertions and statements
- **Staking on Identities and Claims** - Participate in the Token Curated Registry
- **Using Tags** - Organize and discover content
- **Organizing Lists** - Create curated collections
- **Following Users** - Build your social network

## 1. Creating and Managing Identities (Atoms)

Identities, also known as **Atoms**, are the fundamental building blocks in the Intuition system. Each Atom represents a concept, such as a person, organization, or product, and comes with a unique decentralized identifier, structured data, and an associated Vault for signaling its relevancy.

### **How to Create an Identity**

1. **Click the "Create" action button** in the bottom left section of the menu panel
2. **Select "Create Identity"** from the dropdown menu
3. **Input data** to describe the Identity you are creating
4. **Optionally deposit ETH** to stake on your newly created Identity

### **What Happens After Creation?**

When you create an Identity, the data is uploaded to IPFS, generating an IPFS CID that is used to create an Atom in the Intuition contracts. This Atom can now be referenced universally across the web.

## 2. Making Claims (Triples)

**What are Claims?** Claims, or **Triples**, allow you to assert statements about anything using a **[Subject][Predicate][Object]** structure. For example, **[Alice][is][trustworthy]**. Creating a Claim does not automatically express agreement with the claim; you must stake on the Claim to do so.

### **How to Create a Claim:**

1. **Click the "Create" action button** in the bottom left section of the menu panel
2. **Select "Create Claim"** from the dropdown menu
3. **Choose three Atoms/Identities** to form your Claim

### **Helpful Tips:**

- **Existing Claims**: If a claim already exists, simply stake on the existing claim to express your agreement with it
- **Prerequisites**: To create a claim, Atoms must already exist for the subject, predicate and object. If any one of the 3 required Atoms does not exist, you will first need to follow step 1 above to create the necessary identities before composing your claim

## 3. Staking (Signal Conviction)

**What is Staking?** Staking in Intuition allows you to signal what is important or what you believe to be true by staking ETH on Identities (Atoms) or Claims (Triples). This process contributes to a **Token Curated Registry (TCR)**, where the most relevant information rises to the top.

### **Staking on an Identity:**

- **Signals the relevancy** of the Identity
- **Grants you shares** in the Identity, earning fees from future stakes

### **Staking on a Claim:**

- Claims have a **Positive Vault** (for supporting the Claim) and a **Negative Vault** (for opposing the Claim)
- Staking on a Claim also stakes on the Claim's underlying Identities

### **Unstaking:**

You can unstake your ETH at any time to retrieve your deposit (minus fees).

### **Staking Economics:**

Staking grants you shares that provide a proportionate amount of fee revenue accumulated by the Identity or Claim, incentivizing you to stake on high-traction items.

## 4. Using Tags

**What are Tags?** Tags are shortcuts to organizing and finding relevant information. Tagging is achieved by creating a Claim using the **[has tag]** Atom as the Predicate. The ability to create tags is one of the first features to leverage "special predicates" and demonstrates how functionality can be built around specific types of claims. In this case, tags are the foundation on which users can create and manage Lists.

### **Creating and Using Tags:**

- **New Tag Creation**: To create a new Tag, you must create a new Identity for the tag you want to use if it doesn't already exist. Just like any other claim, Identities (Atoms) must exist for the Subject, Predicate, and Object of your **[has tag]** claim. When adding a new tag, we know the Subject and Predicate exist, so users only need to ensure an Object Atom exists (which represents the tag to be added)

- **Tagging Process**: Tag something by searching through "Existing Tags" or creating a new one
- **Benefits**: Tagging enhances discoverability and adds items to relevant Lists

## 5. Organizing with Lists

**What are Lists?** Lists allow you to group related items or data in a way that makes sense to you, helping others discover, save, and provide feedback. Lists are constructed through deterministic queries, making it easy to organize and navigate complex data.

### **Creating a List:**

- Lists are formed by Claims with the **[has tag]** Predicate
- Tag an Identity to include it in a specific List

### **Adding to and Managing Lists:**

- Use the **"Add to list"** and **"Save list"** buttons to manage your Lists
- Lists are **Token Curated Registries (TCR)**, where you can stake ETH to order entries within a List

## 6. Following Users

**What is Following?** Following in Intuition is a contextual statement made by staking on the Claim **[I][am following][User]**. This staking process reflects the strength of your connection and is part of the open data available for developers to use in building a social graph.

### **How to Follow/Unfollow:**

- **To follow**: Click on a user's profile and select "Follow," then optionally stake ETH
- **To unfollow**: Click "Following" on the user's profile and select "Unfollow." Unfollowing also redeems your staked ETH

## Getting Started

### ðŸš€ **Ready to begin your journey?**

Visit **[portal.intuition.systems](https://portal.intuition.systems)** to start creating identities, making claims, and building your presence in the Intuition knowledge graph.

## Related Resources

**[Explorer](/guides/network/testnet/explorer)** - Network exploration tools

**[Bridge](/guides/network/testnet/bridge)** - Cross-chain functionality

**[RPC](/guides/network/testnet/rpc)** - Network connectivity options


---

# 

Source: https://docs.intuition.systems/guides/network/testnet/rpc


# RPC

The Intuition RPC (Remote Procedure Call) service provides programmatic access to the Intuition network.

## Overview

RPC endpoints allow developers and applications to:

- Query blockchain data
- Submit transactions
- Monitor network state
- Access historical data
- Interact with smart contracts

## Available Endpoints

### Core RPC Methods

- **eth_getBalance**: Get account balance
- **eth_getBlockByNumber**: Retrieve block information
- **eth_getTransactionByHash**: Get transaction details
- **eth_sendRawTransaction**: Submit signed transactions
- **eth_call**: Execute contract calls
- **eth_getLogs**: Retrieve event logs

### Intuition-Specific Methods

- **intuition_getAtoms**: Query atom data
- **intuition_getTriples**: Retrieve triple information
- **intuition_getSignals**: Access signal data
- **intuition_getBondingCurves**: Get bonding curve data

## Authentication

RPC access requires authentication for production use:

## Usage Examples

```javascript
// Connect to Intuition RPC
const provider = new ethers.providers.JsonRpcProvider(
  'https://rpc.intuition.network'
);

// Query account balance
const balance = await provider.getBalance(address);

// Get latest block
const block = await provider.getBlock('latest');
```

Ready to Connect?

Start building with the Intuition RPC service and integrate blockchain functionality into your applications.
Get Started

GraphQL API

*[Placeholder content - to be expanded with actual RPC documentation and examples]* 

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms


# Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph â€“ the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

## Understanding Atoms

In the spirit of the Semantic Web and linked data, an Atom can correspond to virtually anything:

- **People**: User identities, profiles, public figures
- **Organizations**: Companies, DAOs, institutions, projects
- **Addresses**: Cryptocurrency wallets, smart contracts, validators
- **Documents**: Files, articles, research papers, certificates
- **Temporal markers**: Dates, timestamps, time periods
- **Categories**: Tags, classifications, taxonomies
- **Concepts**: Ideas, words, phrases, abstract notions

Each Atom's unique ID is deterministically generated based on its `atomData` field â€“ meaning the same data will always produce the same Atom ID. This ensures that duplicate Atoms cannot be created for identical data, and anyone can independently verify an Atom's ID by hashing its data. This design makes Atoms act as a bridge between on-chain identifiers and the rich context of off-chain data â€“ similar to how an NFT token ID might reference metadata stored elsewhere.

## Technical Architecture

### Core Structure

Under the hood, creating a new Atom mints a tokenized record using the ERC-1155 multi-token standard that includes:

1. **Unique Atom ID**: A permanent, immutable identifier deterministically derived from the atomData
2. **Atom Data**: Can contain any arbitrary data (URIs, text, JSON, references to external resources)
3. **Associated Smart Contract Wallet**: Enabling the Atom itself to own assets and interact with contracts

Every Atom carries `atomData` which can contain any arbitrary information relevant to that entity. For example:
- An Atom for "Solar Energy" might contain a link to a Wikipedia page about solar power
- An Atom for a user's identity might contain a DID document reference or profile JSON
- An Atom for a document might contain an IPFS content hash
- An Atom for a concept might contain a simple text string or structured JSON data

### Staking Vaults and Bonding Curves

Each Atom has one or more Vaults attached to it for staking. These vaults operate on a bonding curve, meaning:

- The cost to acquire a stake (or "share") in an Atom increases as more is already staked
- Early stakers get a larger stake for their investment
- Latecomers pay a premium for popular Atoms

This mechanism incentivizes early discovery of important Atoms and creates a form of priority signaling â€“ the community collectively "bids up" the Atoms deemed valuable or relevant by risking capital in their vaults.

### Atom Creation Process

  {() => }

## The Problem Atoms Solve

### Universal Reference Standardization

Today's web is siloed â€“ the same entity might be referred to in dozens of different ways across different platforms. Consider how many separate user accounts or content IDs one person might have across various sites.

Intuition's Atoms provide:
- A single, canonical identifier for each real-world thing
- Universal reusability across any application or user
- Easy reconciliation and trust of data from disparate sources
- Automatic deduplication through deterministic ID generation

By converging on a universal set of Atoms, every piece of data about Alice can point to the same Atom `[Alice]`, rather than being scattered across unlinked profiles. Since Atom IDs are deterministically generated from their data, if two users try to create an Atom with identical data, they'll generate the same ID â€“ preventing duplicates at the protocol level.

### Market-Driven Ontology Management

While deterministic IDs prevent exact duplicates, similar concepts might still be represented with slightly different data (e.g., "DeFi" vs "Decentralized Finance"). The protocol employs Token Curated Registry (TCR) logic for these cases:

1. **Competition**: Users tend to stake on the Atom that others find more useful or legitimate
2. **Signal Accumulation**: One variant accrues more Signal and usage over time
3. **Natural Selection**: The preferred Atom wins out as the standard
4. **Economic Incentives**: Early backers of the "winning" Atom are rewarded through vault fees and token emissions

This market-driven approach, combined with deterministic ID generation, ensures the knowledge base converges on canonical representations while preventing exact duplicates.

## Design Principles: Atomic Granularity

### The Power of Flat Data

A crucial best practice is keeping information modular and atomic. You are economically incentivized to create "flatter" Atoms â€“ each representing a single, minimal concept â€“ rather than packing composite information into one Atom.

#### Why Granularity Matters

Consider representing the statement: **"Tiger Research was founded in 2021"**

**âŒ Monolithic Approach** (Not Recommended):
```javascript
// One Atom containing all information
const statementAtom = {

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms/best-practices


# Best Practices

## Creating Effective Atoms

1. **Leverage Deterministic IDs**: Remember that identical atomData will always produce the same Atom ID
2. **Check for Similar Atoms**: Search for canonical Atoms before creating variations
3. **Use Clear Data**: Choose descriptive, unambiguous data values
4. **Maintain Single Purpose**: Each Atom should represent one thing
5. **Consider Reusability**: Design Atoms others will want to reference

## Atom Design Patterns

Think of Atoms as **words in the Intuition dictionary**:
- They are the lego-like pieces that snap into many contexts
- Community Signal concentrates on the words that matter most
- Triples form the "sentences" that connect these dictionary words together

## Integration with Triples

Atoms gain their true power when connected via Triples:
- **Subject Atoms**: The entity being described
- **Predicate Atoms**: The relationship or property
- **Object Atoms**: The value or target of the relationship

This separation allows each component to be independently verified, updated, and trusted.

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms/design-principles


# Design Principles: Atomic Granularity

:::tip The Power of Flat Data
A crucial best practice is keeping information modular and atomic. You are economically incentivized to create "flatter" Atoms â€“ each representing a single, minimal concept â€“ rather than packing composite information into one Atom.
:::

## Why Granularity Matters

Consider representing the statement: **"Tiger Research was founded in 2021"**

### Monolithic Approach (Not Recommended)

```javascript
// One Atom containing all information
const statementAtom = {

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms/overview


# Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph â€“ the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

## Understanding Atoms

In the spirit of the Semantic Web and linked data, an Atom can correspond to virtually anything:

- **People**: User identities, profiles, public figures
- **Organizations**: Companies, DAOs, institutions, projects
- **Addresses**: Cryptocurrency wallets, smart contracts, validators
- **Documents**: Files, articles, research papers, certificates
- **Temporal markers**: Dates, timestamps, time periods
- **Categories**: Tags, classifications, taxonomies
- **Concepts**: Ideas, words, phrases, abstract notions

Each Atom's unique ID is deterministically generated based on its `atomData` field â€“ meaning the same data will always produce the same Atom ID. This ensures that duplicate Atoms cannot be created for identical data, and anyone can independently verify an Atom's ID by hashing its data. This design makes Atoms act as a bridge between on-chain identifiers and the rich context of off-chain data â€“ similar to how an NFT token ID might reference metadata stored elsewhere.

## Technical Architecture

### Core Structure

Under the hood, creating a new Atom mints a tokenized record using the ERC-1155 multi-token standard that includes:

1. **Unique Atom ID**: A permanent, immutable identifier deterministically derived from the atomData
2. **Atom Data**: Can contain any arbitrary data (URIs, text, JSON, references to external resources)
3. **Associated Smart Contract Wallet**: Enabling the Atom itself to own assets and interact with contracts

Every Atom carries `atomData` which can contain any arbitrary information relevant to that entity. For example:
- An Atom for "Solar Energy" might contain a link to a Wikipedia page about solar power
- An Atom for a user's identity might contain a DID document reference or profile JSON
- An Atom for a document might contain an IPFS content hash
- An Atom for a concept might contain a simple text string or structured JSON data

### Staking Vaults and Bonding Curves

Each Atom has one or more Vaults attached to it for staking. These vaults operate on a bonding curve, meaning:

- The cost to acquire a stake (or "share") in an Atom increases as more is already staked
- Early stakers get a larger stake for their investment
- Latecomers pay a premium for popular Atoms

This mechanism incentivizes early discovery of important Atoms and creates a form of priority signaling â€“ the community collectively "bids up" the Atoms deemed valuable or relevant by risking capital in their vaults.

### Atom Creation Process

  {() => }

## Explore More

Dive deeper into Atoms with these detailed guides:

- **[The Problem Atoms Solve](./problem-atoms-solve)**: Understand how Atoms enable universal reference standardization and market-driven ontology management
- **[Design Principles: Atomic Granularity](./design-principles)**: Learn why granularity matters and how to design effective, reusable Atoms
- **[Best Practices](./best-practices)**: Discover patterns and guidelines for creating high-quality Atoms
- **[Practical Examples](./practical-examples)**: See real-world examples of Identity, Concept, and Relationship Atoms

## Next Steps

With Atoms as your foundation, you can:
- Learn about [Triples](../triples) to create meaningful relationships between Atoms
- Explore [Signals](../signals) to understand attestation and trust mechanics
- Review [Vaults](../vaults) for staking and economic participation
- Check the [SDK Documentation](/docs/developer-tools/sdks/overview) for implementation details

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms/practical-examples


# Practical Examples

## Identity Atom

```javascript
const aliceAtom = {

---

# 

Source: https://docs.intuition.systems/guides/primitives/atoms/problem-atoms-solve


# The Problem Atoms Solve

## Universal Reference Standardization

Today's web is siloed â€“ the same entity might be referred to in dozens of different ways across different platforms. Consider how many separate user accounts or content IDs one person might have across various sites.

Intuition's Atoms provide:
- A single, canonical identifier for each real-world thing
- Universal reusability across any application or user
- Easy reconciliation and trust of data from disparate sources
- Automatic deduplication through deterministic ID generation

By converging on a universal set of Atoms, every piece of data about Alice can point to the same Atom `[Alice]`, rather than being scattered across unlinked profiles. Since Atom IDs are deterministically generated from their data, if two users try to create an Atom with identical data, they'll generate the same ID â€“ preventing duplicates at the protocol level.

## Market-Driven Ontology Management

While deterministic IDs prevent exact duplicates, similar concepts might still be represented with slightly different data (e.g., "DeFi" vs "Decentralized Finance"). The protocol employs Token Curated Registry (TCR) logic for these cases:

1. **Competition**: Users tend to stake on the Atom that others find more useful or legitimate
2. **Signal Accumulation**: One variant accrues more Signal and usage over time
3. **Natural Selection**: The preferred Atom wins out as the standard
4. **Economic Incentives**: Early backers of the "winning" Atom are rewarded through vault fees and token emissions

This market-driven approach, combined with deterministic ID generation, ensures the knowledge base converges on canonical representations while preventing exact duplicates.

---

# 

Source: https://docs.intuition.systems/guides/primitives/overview


# Primitives Overview

Intuition's data model is built on three fundamental primitives that work together to create a rich, self-regulating knowledge graph:

The basic entities or identifiers - unique decentralized identifiers for everything in existence. Think of them as the nodes in the knowledge graph, or the words in the dictionary.

Structured relationships or claims linking entities together in Subject-Predicate-Object format. These are the edges in the knowledge graph / the sentences in the language of Intuition.

The weight of trust or consensus behind each entity or claim, determined by community staking. These represent the edge weights in the graph, or 'who is saying what about what, with what level of conviction'.

---

## The Three Primitives Explained

### Atoms: Universal Identifiers for Everything

An **Atom** is a unique decentralized identifier that can reference literally anything â€“ from people and organizations to concepts, data points, or even raw bytes of information. Each Atom acts as a globally referenceable identity in the Intuition system, with an on-chain ID that serves as its permanent, verifiable address.

:::info What Makes Atoms Unique
Unlike traditional identifiers that are limited to URIs or specific data formats, Atoms can point to **arbitrary data (bytes)**. This means an Atom can reference:
- **Raw strings**: Direct text like "Alice", "is friend of", or "2024-01-15"
- **URIs**: Web pages, IPFS hashes, blockchain addresses
- **Binary data**: Images, documents, encrypted content
- **Structured data**: JSON objects, protocol buffers, or any serialized format
- **Abstract concepts**: Ideas, emotions, or theoretical constructs
:::

#### Real-World Atom Examples

**Person Atom**
```
Atom ID: 0x123...

---

# 

Source: https://docs.intuition.systems/guides/primitives/signals/overview


# Overview

Signals represent the trust, confidence, or relevance that the community assigns to Atoms and Triples in the Intuition knowledge graph. Think of the knowledge graph as a weighted graph where Signal is the weight on each node (Atom) or edge (Triple), indicating how strongly people believe in or care about this information.

## Understanding Signals

Signals transform static data into a dynamic, trusted intelligence layer. When someone stakes $TRUST tokens on an Atom or Triple, they emit a Signal expressing that they find that piece of information important or true. Conversely, staking on a Triple's negative side signals doubt. These individual signals aggregate to form an overall weighted state for each item in the knowledge graph.

In essence, Signals are the lifeblood of Intuition's trust layer. They turn subjective judgments into quantifiable, shareable data, creating an internet where information is contextualized with trustâ€”allowing everyone to navigate knowledge supported by transparent evidence and collective wisdom.

### The Vision

Intuition aims to create an internet where every piece of information carries its trust signatureâ€”where we navigate knowledge with an intuition of what to believe, supported by transparent evidence and collective wisdom rather than blind faith in centralized authorities.

## How Signals are Created

The core mechanism for creating signals is through **staking** (also called attesting). When you deposit $TRUST tokens into an Atom's vault or a Triple's vaults, you're effectively buying "shares" in that piece of information.

### Staking Mechanics

- **Atoms**: Each Atom has a single staking vault
- **Triples**: Each Triple has two vaults (positive and negative)
- **Shares**: Your stake represents proportional ownership and conviction

For example:
- Staking 100 TRUST on the Atom `[Ethereum]` gives you a fraction of total Atom Shares for `[Ethereum]`
- Staking 50 TRUST on `[Alice] is Friend Of [Bob]` in the affirmative vault gives you Triple Shares supporting that friendship claim

### Bonding Curves

The bonding curve mechanics mean share prices depend on existing stake levels:
- Early stakers get better prices
- Later stakers pay more for the same signal increment
- This creates a perpetual prediction market for information

### Continuous Markets

Staking is not a one-time vote but a continuous market:
- Add more stake to increase your signal
- Withdraw stake (with potential rewards or penalties)
- Counter-stake on opposite sides for Triples
- Market "odds" constantly adjust to reflect aggregated beliefs

## Total Value Locked and Consensus

Each Atom and Triple accrues **Total Value Locked (TVL)** in its vaultsâ€”a direct measure of tokenized trust. Higher TVL generally implies greater relevance or credibility, helping filter signal from noise.

### Consensus Calculation

The consensus score weighs multiple variables:
- Amount staked on each side
- Number of distinct attestors
- Past reliability (reputation) of attestors

For example, if a claim has:
- 10,000 TRUST staked in support (from 2 whales)
- 2,000 TRUST staked against (from 100 knowledgeable users)

The raw numbers alone don't tell the full story. The consensus algorithm factors in these nuances, which can be tuned through governance.

### Economic Incentives and Ownership

Signals create a revolutionary ownership model for information. When you stake TRUST on an Atom or Triple, you're not just votingâ€”you're buying ownership shares in that piece of data.

#### How Signal Economics Work

1. **Stake TRUST, Receive Tokens**: When you stake TRUST on any Atom or Triple, you receive proportional tokens representing your ownership share
   - Each Atom and Triple has its own token supply
   - The number of tokens you receive depends on the bonding curve price at the time of staking
   - Early stakers get more tokens per TRUST than later stakers

2. **Bonding Curve Pricing**: Everything operates on bonding curves, creating dynamic pricing:
   - Initial stakes are cheap (more tokens per TRUST)
   - As more people stake, the price increases
   - This rewards early discovery and conviction
   - Creates a market mechanism for information value

3. **Fee Distribution to Token Holders**: Here's where it gets powerfulâ€”token holders earn from all interactions:
   - When someone queries the data, fees go to token holders
   - When others stake on the same Atom/Triple, trading fees accrue to existing holders
   - When the data is traversed in graph queries, micro-fees flow to owners
   - The more useful the data, the more fees it generates

#### Signals as Data Ownership

This model transforms Signals from simple attestations into **programmatic value flows**:

```javascript
// Example: Staking creates ownership
const stake = await stakeOnAtom({

---

# 

Source: https://docs.intuition.systems/guides/primitives/signals/practical-implementation


# Practical Implementation Examples

## Creating and Querying Signals

```javascript
// Stake on an Atom
const atomSignal = await stake({
  vaultId: ethereumAtom.vaultId,
  amount: 100 // 100 TRUST tokens
});

// Stake on a Triple (positive)
const tripleSignal = await stake({
  vaultId: friendshipTriple.positiveVaultId,
  amount: 50
});

// Counter-stake (negative)
const disputeSignal = await stake({
  vaultId: claimTriple.negativeVaultId,
  amount: 75
});

// Query with confidence threshold
const trustedClaims = await query({
  minConsensus: 0.7,
  minTVL: 1000
});
```

## Building Trust-Aware Applications

```javascript
// Create a trust-filtered API
class TrustAPI {
  async getVerifiedFacts(topic, minTrust = 0.8) {
    const results = await intuition.query({
      pattern: `[*] [relatesTo] [${topic}]`,
      filters: {
        consensus: { gte: minTrust },
        attestors: { gte: 10 }
      }
    });

    return results.map(r => ({
      fact: r.triple,
      trust: r.consensus,
      evidence: r.signals
    }));
  }
}
```

---

# 

Source: https://docs.intuition.systems/guides/primitives/signals/strategies-best-practices


# Signal Strategies and Best Practices

## Optimal Signaling Strategy

The game-theoretic optimal strategy is to:
1. Identify accurate, useful information early
2. Stake before widespread recognition
3. Earn from value flow as data gets utilized
4. Build reputation through consistent accuracy

## Risk Considerations

- **No Absolute Truth Guarantee**: Signals represent consensus and confidence, not absolute truth
- **Early Stage Risks**: Fewer participants can mean less reliable signals
- **Potential for Manipulation**: Large stakes can temporarily skew consensus
- **Opportunity Cost**: Staking on irrelevant or unused claims means missing better opportunities

## Defensive Strategies

- Always examine the trust trail behind strong signals
- Drill down into attestor profiles and motivations
- Consider contrarian positions when consensus seems wrong
- Diversify across multiple claims and domains

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples


# Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] â€“ [Predicate] â€“ [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

## Understanding Triples

A Triple is a fundamental data structure that expresses relationships between Atoms, following the classic RDF triple format used in semantic web technologies. This makes Intuition's data inherently machine-readable and structured.

Every Triple represents a claimâ€”it asserts that a Subject has some relationship (Predicate) to an Object. For example:

```
[Alice] -- [livesIn] --> [Paris]
```

This Triple asserts a fact about Alice's location, where:
- **Alice** is the subject Atom
- **livesIn** is the predicate Atom (describing the type of relationship)
- **Paris** is the object Atom

Each component of a Triple is an Atom ID under the hood. The system doesn't store free-form text "Alice" or "Paris" but rather pointers to those Atom records, which might contain rich data, alternate labels, and additional metadata.

## The Graph Structure

Triples naturally form a graph of nodes and links. You can visualize:
- **Atoms as nodes** in the graph
- **Triples as directed edges** from subject to object, labeled by the predicate

This graph structure enables powerful capabilities:
- Deterministic queries like "find all objects that Alice is connected to via livesIn"
- Traversal of relationships to discover indirect connections
- Pattern matching across the knowledge graph

## Why Triples Matter

### Semantic Clarity
By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice â€”livesInâ†’ Paris`.

### Reconciliation & Interoperability
The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systemsâ€”knowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

### Extensibility
Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

### Composability
The data model is open-endedâ€”you can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

## Nested Triples: Meta-Claims & Context

One of Intuition's most powerful features is that Triples can reference other Triples, effectively nesting statements to provide context or provenance. Intuition supports using a Triple itself as a Subject or Object in another Triple.

### Example: Disputing a Claim
Consider an initial Triple:
```
[Bob] -- [isFriendOf] --> [Alice]
```

If Alice disagrees with this claim, we can create a nested Triple:
```
[Alice] -- [disproves] --> (Bob isFriendOf Alice)
```

Here, the Object of the second Triple is not an Atom but a reference to the first Triple (identified by its Triple ID). Alice is essentially asserting that the friendship claim is false.

### Adding Evidence & Sources
You can link Triples to evidence or citations:
```
[Triple X] -- [basedOn] --> [Document Y]
```

This ability to compose Triples into higher-order statements gives the graph a fractal qualityâ€”small facts build into bigger facts, and complex relationships can be broken down into simpler ones.

## Positive and Negative Claims

Unlike traditional databases that store only "the one truth," Intuition allows multiple competing Triples and uses Signals (stakes) to gauge their validity.

### Two-Sided Staking Vaults
Every Triple has two logical versions:
- **YES vault**: Supporting the claim (affirmative)
- **NO vault**: Denying the claim (negative)

Users can stake on either side, effectively casting weighted votes about the truth of that Triple. This design means a Triple object encapsulates both the claim and its counter-claim within one structure.

### Example: Contested Relationships
For the Triple `[Bob] -- [isFriendOf] --> [Alice]`:
- The affirmative vault contains stakes from those who agree Bob and Alice are friends
- The negative vault contains stakes from those who disagree (potentially including Alice herself!)

### Consensus Evaluation
The network evaluates consensus by:
- Comparing signals on both sides
- Factoring in attestor reputation
- Considering the number of attestors
- Calculating confidence scores that adjust over time

Importantly, Intuition doesn't force a single authoritative truthâ€”it records the spectrum of belief. Multiple "canonical" Triples can compete, and the TCR mechanism with staking tends to favor the most accurate representations.

## Best Practices for Structuring Triples

### Use Precise Predicates
The Predicate Atom is crucial for clarity. Guidelines:
- **Search first**: Check if a canonical predicate already exists
- **Reuse standards**: Don't create `[worksFor]` if `[employeeOf]` is widely used
- **Converge on conventions**: Using common predicates helps data link up instead of fragmenting

The Intuition community and token mechanics organically push toward standard predicates through signal accumulation.

### One Fact Per Triple
Each Triple should capture a single discrete claim:
- âŒ "Alice isFriendOf Bob and coworker at CompanyX"
- âœ… Two separate Triples: one for friendship, another for workplace

Keeping to one relation makes staking and validation straightforwardâ€”people can agree with one link and not the other.

### Leverage Nesting for Context
When statements need qualification:
- Create auxiliary Triples rather than complicating the original
- Attach timeframes or sources through supporting Triples
- Use nested Triples for meta-information

Example: Time-bound relationships
```
Main Triple: [Alice] -- [isFriendOf] --> [Bob]
Context Triple: [Triple ID] -- [validSince] --> [2023]
```

### Handle Counter-Claims Wisely
Generally, you don't need to manually create "not X" Triplesâ€”the negative staking vault handles disagreement. However, sometimes a negation has specific meaning that deserves its own predicate (e.g., `[isNotFriendOf]` as a distinct relation type).

The "Counter Triple" concept is more about how the UI and indexing organize the negative vault signal than about separate data objects.

## Core Benefits

### Semantic Clarity and Interoperability
Each Triple makes a small, clear statement that can be understood in isolation or as part of larger datasets. This semantic structure means data from Intuition is immediately useful to other systemsâ€”knowledge graphs and AI can ingest these triples without guessing their meaning.

### Flexibility & Composability
Triples can represent simple facts or be combined into complex graphs. You can always extend the graph by adding another Triple rather than modifying existing ones. Because Triples can reference other Triples, you get composability in assertionsâ€”building evidence chains, tracking consensus over time, and more.

### Built-In Conflict Resolution
Triples come with a native way to handle conflicting views through the two-vault mechanism. This keeps contradictory information tethered to the original claim, improving data organization. Rather than disjointed claims floating around, everything is anchoredâ€”a false claim isn't simply deleted but gets counter-staked and remains in the graph with a low trust score.

### Context and Evolution
Knowledge in Intuition is not static. When statements become outdated or need context, you don't replace old dataâ€”you supplement it. For example, if Alice moves from Paris to London:
1. Mark the Paris Triple as no longer current (stake against it or add an "endDate" context triple)
2. Add `[Alice] -- [livesIn] --> [London]` as a new Triple with current timestamp

The history is preserved, and queries can be time-scoped or context-aware thanks to the graph structure.

## Practical Implementation

### Creating Triples
```javascript
// Basic Triple creation
const triple = await createTriple({
  subjectId: aliceAtom.id,
  predicateId: livesInAtom.id,
  objectId: parisAtom.id
});

// With temporal context
const employmentTriple = await createTriple({
  subjectId: person.id,

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/core-benefits

## Why Triples Matter

### Semantic Clarity
By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice â€”livesInâ†’ Paris`.

### Reconciliation & Interoperability
The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systemsâ€”knowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

### Extensibility
Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

### Composability
The data model is open-endedâ€”you can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

# Core Benefits

## Semantic Clarity and Interoperability

Each Triple makes a small, clear statement that can be understood in isolation or as part of larger datasets. This semantic structure means data from Intuition is immediately useful to other systemsâ€”knowledge graphs and AI can ingest these triples without guessing their meaning.

By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice â€”livesInâ†’ Paris`.

## Flexibility & Composability

Triples can represent simple facts or be combined into complex graphs. You can always extend the graph by adding another Triple rather than modifying existing ones. Because Triples can reference other Triples, you get composability in assertionsâ€”building evidence chains, tracking consensus over time, and more.

The data model is open-endedâ€”you can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

## Built-In Conflict Resolution

Triples come with a native way to handle conflicting views through the two-vault mechanism. This keeps contradictory information tethered to the original claim, improving data organization. Rather than disjointed claims floating around, everything is anchoredâ€”a false claim isn't simply deleted but gets counter-staked and remains in the graph with a low trust score.

## Context and Evolution

Knowledge in Intuition is not static. When statements become outdated or need context, you don't replace old dataâ€”you supplement it. For example, if Alice moves from Paris to London:
1. Mark the Paris Triple as no longer current (stake against it or add an "endDate" context triple)
2. Add `[Alice] -- [lives In] --> [London]` as a new Triple with current timestamp

The history is preserved, and queries can be time-scoped or context-aware thanks to the graph structure.

## Reconciliation & Interoperability

The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systemsâ€”knowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

## Extensibility

Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/how-to-create


# How to create

There are multiple ways to create Triples on the Intuition platform. Choose the method that best fits your development workflow:

## Development Options

Use the Intuition SDK for a streamlined development experience with TypeScript support and built-in helpers.

Interact directly with Intuition smart contracts for maximum control and customization.

---

## Practical Implementation

### Creating Triples

```javascript
// Basic Triple creation
const triple = await createTriple({
  subjectId: aliceAtom.id,
  predicateId: livesInAtom.id,
  objectId: parisAtom.id
});

// With temporal context
const employmentTriple = await createTriple({
  subjectId: person.id,

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/nested-triples-practical-implementation


# Practical Implementation

## Contextualization with Nested Triples

One of the most powerful features of nested Triples is the ability to add context and nuance to claims. Rather than making broad, absolute statements, you can progressively refine claims with additional layers of context.

### Progressive Context Building

Consider how trust can be contextualized at different levels:

**Level 1: Basic Trust Statement**
```
[I] -- [trust] --> [Billy]
```
This is a simple, general claim of trust without any specific context.

**Level 2: Domain-Specific Trust**
```
[I] -- [trust] --> [Billy]
[[I trust Billy]] -- [in context of] --> [Web3]
```
Here, we've added a layer of context by creating a nested Triple that specifies the domain. The trust claim now has a qualifier: it applies specifically within the Web3 ecosystem.

**Level 3: Adding Justification**
```
[I] -- [trust] --> [Billy]
[[I trust Billy]] -- [in context of] --> [Web3]
[[[I trust Billy] in context of Web3]] -- [because] --> [Intuition]
```
We can further refine by adding justification or reasoning. This creates a rich, layered claim that captures not just what you believe, but why and in what context.

### Why This Matters

This progressive contextualization allows for:
- **Precision**: Claims can be as specific or general as needed
- **Transparency**: The reasoning behind beliefs becomes explicit and verifiable
- **Flexibility**: Context can evolve without invalidating the base claim
- **Nuance**: Complex real-world relationships aren't reduced to binary yes/no statements

Instead of creating separate, disconnected claims for each variation, nested Triples build upon each other, creating a structured hierarchy that preserves the relationships between related statements.

---

## Nested Triple Example

```javascript
// Create the base claim
const friendshipClaim = await createTriple({
  subjectId: bob.id,
  predicateId: isFriendOf.id,
  objectId: alice.id
});

// Alice disputes the claim
const dispute = await createTriple({
  subjectId: alice.id,
  predicateId: disproves.id,
  objectId: friendshipClaim.id  // Reference to the Triple itself
});
```

## Building Evidence Chains

```javascript
// Create a research finding
const researchClaim = await createTriple({
  subjectId: study.id,
  predicateId: concludes.id,
  objectId: result.id
});

// Link to supporting document
const evidence = await createTriple({
  subjectId: researchClaim.id,  // Triple as subject
  predicateId: basedOn.id,
  objectId: peerReviewedPaper.id
});
```

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/nested-triples


# Nested Triples: Meta-Claims & Context

One of Intuition's most powerful features is that Triples can reference other Triples, effectively nesting statements to provide context or provenance. Intuition supports using a Triple itself as a Subject or Object in another Triple.

## Example: Disputing a Claim

Consider an initial Triple:
```
[Bob] -- [isFriendOf] --> [Alice]
```

If Alice disagrees with this claim, we can create a nested Triple:
```
[Alice] -- [disproves] --> (Bob isFriendOf Alice)
```

Here, the Object of the second Triple is not an Atom but a reference to the first Triple (identified by its Triple ID). Alice is essentially asserting that the friendship claim is false.

## Adding Evidence & Sources

You can link Triples to evidence or citations:
```
[Triple X] -- [basedOn] --> [Document Y]
```

This ability to compose Triples into higher-order statements gives the graph a fractal qualityâ€”small facts build into bigger facts, and complex relationships can be broken down into simpler ones.

## Linguistic Compression

Think of it as linguistic compressionâ€”instead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes.

This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/overview


# Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] â€“ [Predicate] â€“ [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

## Understanding Triples

A Triple is a fundamental data structure that expresses relationships between Atoms, following the classic RDF triple format used in semantic web technologies. This makes Intuition's data inherently machine-readable and structured.

Every Triple represents a claimâ€”it asserts that a Subject has some relationship (Predicate) to an Object. For example:

```
[Alice] -- [lives In] --> [Paris]
```

This Triple asserts a fact about Alice's location, where:
- **Alice** is the subject Atom
- **livesIn** is the predicate Atom (describing the type of relationship)
- **Paris** is the object Atom

Each component of a Triple is an Atom ID under the hood. The system doesn't store free-form text "Alice" or "Paris" but rather pointers to those Atom records, which might contain rich data, alternate labels, and additional metadata.

## Integration with Other Primitives

### With Atoms

- Triples connect Atoms into meaningful relationships
- Atoms gain context through Triple connections
- Triple predicates can themselves be Atoms for maximum flexibility

### With Signals

- Signals add weight to Triple claims through staking
- Community validates Triples through Signal attestations
- Signal strength directly affects Triple credibility and consensus

## The Graph Structure

Triples naturally form a graph of nodes and links. You can visualize:
- **Atoms as nodes** in the graph
- **Triples as directed edges** from subject to object, labeled by the predicate

This graph structure enables powerful capabilities:
- Deterministic queries like "find all objects that Alice is connected to via livesIn"
- Traversal of relationships to discover indirect connections
- Pattern matching across the knowledge graph

## Summary

Triples allow Intuition to form a living, searchable web of knowledge. When adding Triples, the goal is to make each claim as clear and verifiable as possible, selecting the right words (Atoms) from the global dictionary, and then letting the network of users and their Signals determine validity.

With Atoms as the words in our global dictionary and Triples as the sentences we construct from them, we can express any arbitrarily-complex concept while maintaining discrete, referenceable structure. Here's where it becomes powerful: each Triple receives its own unique ID, effectively becoming a new "word" in the system that encapsulates an entire concept. This ID can then be referenced by other Triples, allowing you to build increasingly sophisticated expressions.

Think of it as linguistic compressionâ€”instead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes. This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

The result is an extraordinarily efficient knowledge transmission system. Rather than sending verbose descriptions, systems can exchange compact Triple IDs that expand into rich, contextual information. Each ID carries with it not just data, but the entire graph of relationships, evidence, and community consensus that supports it. The addition of Signals completes the picture by measuring which sentences (facts) are trusted by the community.
## Explore More

Dive deeper into Triples with these detailed guides:

- **[Nested Triples: Meta-Claims & Context](./nested-triples)**: Learn how Triples can reference other Triples for context and provenance
- **[Positive and Negative Claims](./positive-negative-claims)**: Understand the two-sided staking mechanism and consensus evaluation
- **[Best Practices for Structuring Triples](./best-practices)**: Guidelines for creating effective, reusable Triples
- **[Core Benefits](./core-benefits)**: Discover the semantic clarity, flexibility, and conflict resolution capabilities
- **[Practical Implementation](./practical-implementation)**: Code examples for creating Triples, nested claims, and evidence chains
- **[Use Cases](./use-cases)**: Explore real-world applications in knowledge graphs, identity, supply chain, and DeFi
- **[Querying Triples](./querying-triples)**: Learn how to query and traverse the knowledge graph
- **[Integration with Other Primitives](./integration)**: See how Triples work with Atoms and Signals

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/positive-negative-claims


# Positive and Negative Claims

Unlike traditional databases that store only "the one truth," Intuition allows multiple competing Triples and uses Signals (stakes) to gauge their validity.

## Two-Sided Staking Vaults

Every Triple has two logical versions:
- **YES vault**: Supporting the claim (affirmative)
- **NO vault**: Denying the claim (negative)

Users can stake on either side, effectively casting weighted votes about the truth of that Triple. This design means a Triple object encapsulates both the claim and its counter-claim within one structure.

## Example: Contested Relationships

For the Triple `[Bob] -- [isFriendOf] --> [Alice]`:
- The affirmative vault contains stakes from those who agree Bob and Alice are friends
- The negative vault contains stakes from those who disagree (potentially including Alice herself!)

## Consensus Evaluation

The network evaluates consensus by:
- Comparing signals on both sides
- Factoring in attestor reputation
- Considering the number of attestors
- Calculating confidence scores that adjust over time

:::warning
Importantly, Intuition doesn't force a single authoritative truthâ€”it records the spectrum of belief. Multiple "canonical" Triples can compete, and the TCR mechanism with staking tends to favor the most accurate representations.
:::

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/querying-triples


# Querying Triples

## Basic Queries

```graphql
# Find all facts about Alice
query {
  triples(where: { subjectId: "alice_atom_id" }) {
    predicate
    object {
      data
    }
  }
}

# Find all friendship relationships
query {
  triples(where: { predicate: "isFriendOf" }) {
    subject { data }
    object { data }
  }
}
```

## Traversing the Graph

```graphql
# Find where Alice's friends live
query {
  triples(where: {

---

# 

Source: https://docs.intuition.systems/guides/primitives/triples/use-cases


# Use Cases

## Knowledge Graphs

Build comprehensive knowledge networks for:
- Academic citations and research connections
- Information hierarchies and taxonomies
- Cross-referenced documentation systems

## Identity & Reputation

Create verifiable identity systems with:
- Professional credentials and certifications
- Social connections and endorsements
- Achievement records and skill attestations

## Supply Chain

Track product journeys through:
- Origin verification and authenticity
- Ownership transfers and custody chains
- Quality attestations and compliance records

## DeFi & Finance

Express financial relationships including:
- Asset ownership and portfolio composition
- Lending positions and collateralization
- Liquidity provisions and yield farming positions

---

# 

Source: https://docs.intuition.systems/guides/quickstart/getting-started


# Getting Started

Get started building with Intuition in minutes. This guide provides direct code snippets to create atoms, triples, and signal on them.

:::info Version Compatibility
This guide uses the v2 contract architecture and requires the following package versions:
- [`@0xintuition/sdk@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/sdk)
- [`@0xintuition/protocol@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/protocol)
- [`@0xintuition/graphql@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/graphql)
:::

## Prerequisites

- Node.js 18+ and npm/pnpm/bun
- A Web3 wallet (MetaMask, Coinbase Wallet, etc.)
- Basic knowledge of React and TypeScript

## Network Configuration

### Option 1: Using Wagmi + RainbowKit

```bash
npm install wagmi viem @rainbow-me/rainbowkit @0xintuition/protocol
```

```typescript

// Define Intuition Testnet
  id: 13579,
    >
      
}
```

## Install the Intuition SDK

```bash
npm install @0xintuition/sdk @0xintuition/protocol
```

## Creating Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph â€“ the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

[Learn more about Atoms â†’](/docs/primitives/atoms)

### Create an Atom from a String

```typescript

function CreateAtom() {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()

  const handleCreate = async () => {
    const address = getMultiVaultAddressFromChainId(chainId)

    const result = await createAtomFromString(
      { walletClient, publicClient, address },
      'My First Atom'

    console.log('Atom created:', result.transactionHash)
    console.log('Atom ID:', result.state.termId)
  }

}
```

### Create an Atom from a Thing (with metadata)

```typescript

const result = await createAtomFromThing(
  { walletClient, publicClient, address },
  {
```

### Create an Atom from Ethereum Account

```typescript

const result = await createAtomFromEthereumAccount(
  { walletClient, publicClient, address },
  {
```

## Reading Data

### Get Atom Details

Retrieve detailed information about an atom using its ID:

```typescript

const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21'

console.log('Atom data:', atomData)
// Returns atom information including metadata, vault details, and more
```

### Get Triple Details

Retrieve information about a triple relationship:

```typescript

const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6'

console.log('Triple data:', tripleData)
// Returns subject, predicate, object atoms and relationship metadata
```

### Search the Knowledge Graph

Perform a global search across atoms, triples, accounts, and collections:

```typescript

const results = await globalSearch('ethereum', {
  atomsLimit: 10,
  accountsLimit: 5,
  triplesLimit: 10,
  collectionsLimit: 5,
})

console.log('Search results:', results)
```

### Semantic Search

Use AI-powered semantic search to find relevant atoms:

```typescript

const results = await semanticSearch(
  'decentralized identity protocols',
  { limit: 5 }

console.log('Semantic search results:', results)
```

### Read On-Chain Atom Data

Read atom data directly from the smart contract:

```typescript

const atomOnChain = await getAtom(
  { publicClient, address },
  { args: [BigInt(atomId)] }

console.log('On-chain atom:', atomOnChain)
// Returns [walletAddress, vaultId, atomData]
```

## Creating Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] â€“ [Predicate] â€“ [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

[Learn more about Triples â†’](/docs/primitives/triples)

```typescript

// First create three atoms
const subject = await createAtomFromString(
  { walletClient, publicClient, address },
  'Alice'

const predicate = await createAtomFromString(
  { walletClient, publicClient, address },
  'knows'

const object = await createAtomFromString(
  { walletClient, publicClient, address },
  'Bob'

// Create the triple: "Alice knows Bob"
const triple = await createTripleStatement(
  { walletClient, publicClient, address },
  {
    args: [
      subject.state.termId,
      predicate.state.termId,
      object.state.termId
    ],
    value: 1000000000000000000n, // 1 ETH deposit in wei
  }

console.log('Triple created:', triple.transactionHash)
```

## Signaling (Staking on Atoms/Triples)

Signals represent the trust, confidence, or relevance that the community assigns to Atoms and Triples in the Intuition knowledge graph. Think of the knowledge graph as a weighted graph where Signal is the weight on each node (Atom) or edge (Triple), indicating how strongly people believe in or care about this information.

[Learn more about Signals â†’](/docs/primitives/signals)

### Deposit (Signal Support)

```typescript

// Deposit on an atom or triple vault
const txHash = await deposit(
  { walletClient, publicClient, address },
  {
    args: [
      BigInt(vaultId), // The vault ID (atom or triple)
      BigInt(depositAmount), // Amount in wei
      walletClient.account.address // Receiver address
    ],
    value: BigInt(depositAmount),
  }

console.log('Deposited:', txHash)
```

### Redeem (Remove Signal)

```typescript

// Redeem from a vault
const txHash = await redeem(
  { walletClient, publicClient, address },
  {
    args: [
      BigInt(vaultId), // The vault ID
      BigInt(sharesToRedeem), // Amount of shares to redeem
      walletClient.account.address, // Receiver address
      walletClient.account.address, // Owner address
    ]
  }

console.log('Redeemed:', txHash)
```

### Preview Redeem

Preview how many assets you'll receive when redeeming shares:

```typescript

// Preview redeem to see assets received
const assetsToReceive = await previewRedeem(
  { walletClient, publicClient, address },
  { args: [BigInt(vaultId), BigInt(sharesToRedeem)] }

console.log('Assets you will receive:', assetsToReceive)
```

## Complete Example Component

```typescript

function IntuitionQuickstart() {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()
  const [atomId, setAtomId] = useState('')

  const address = getMultiVaultAddressFromChainId(chainId)

  const createAtom = async () => {
    const result = await createAtomFromString(
      { walletClient, publicClient, address },
      'My Cool Idea'
    setAtomId(result.state.termId)
    console.log('Created atom:', result.state.termId)
  }

  const signalAtom = async () => {
    if (!atomId) return

    const depositAmount = 100000000000000000n // 0.1 ETH
    await deposit(
      { walletClient, publicClient, address },
      {
        args: [BigInt(atomId), depositAmount, walletClient.account.address],
        value: depositAmount,
      }
    console.log('Signaled support!')
  }

  return (
      Intuition Quickstart
      {atomId && (
      )}
}
```

## Advanced Concepts

### Batch Create Atoms

Create multiple atoms in a single transaction for efficiency and gas savings:

```typescript

// Batch create multiple atoms at once
const atomData = [
  {

console.log('Created atoms:', result.state)
console.log('Transaction:', result.transactionHash)
```

### Batch Create Triples

Create multiple triple relationships in a single transaction:

```typescript

// Assuming you have atom IDs already created
const tripleData = [
  [subjectId1, predicateId1, objectId1], // Triple 1
  [subjectId2, predicateId2, objectId2], // Triple 2
  [subjectId3, predicateId3, objectId3], // Triple 3
]

const result = await batchCreateTripleStatements(
  { walletClient, publicClient, address },
  tripleData,
  1000000000000000000n // Optional: 1 ETH deposit

console.log('Created triples:', result.state)
```

### Batch Deposit

Deposit on multiple vaults (atoms or triples) in a single transaction:

```typescript

// Deposit on multiple vaults at once
const depositData = [
  [vaultId1, vaultId2, vaultId3], // Vault IDs
  [amount1, amount2, amount3], // Amounts in wei
  [receiverAddress, receiverAddress, receiverAddress], // Receiver addresses
]

const result = await batchDepositStatement(
  { walletClient, publicClient, address },
  depositData

console.log('Batch deposit completed:', result.transactionHash)
```

:::tip Gas Optimization
Batch operations significantly reduce gas costs when working with multiple atoms or triples. Instead of paying gas fees for each individual transaction, you pay once for the entire batch.
:::

## Use Cases

Now that you know the basics, explore what you can build:

- **[List Curation & Ranking](/docs/use-cases#list-curation--ranking-systems)** - Create curated lists and reputation systems
- **[Verification & Fraud Protection](/docs/use-cases#verification-and-fraud-protection)** - Build trust and safety mechanisms
- **[Social Platforms](/docs/use-cases#community-owned-social-platforms)** - Portable identities and attestations
- **[Reputation Scores](/docs/use-cases#reputation-scores)** - Context-aware trust scoring
- **[Q&A Platforms](/docs/use-cases#qa-platforms)** - Knowledge sharing with proof
- **[Oracles](/docs/use-cases#oracles)** - Decentralized data feeds

[View all use cases â†’](/docs/use-cases)

## Next Steps

- **[Explore the SDK](/docs/developer-tools/sdks/overview)** - Deep dive into SDK capabilities
- **[Smart Contracts](/docs/developer-tools/contracts/contract-architecture)** - Contract architecture and ABIs
- **[GraphQL API](/docs/developer-tools/graphql-api/overview)** - Query the knowledge graph
- **[Join the Community](/docs/resources/community-and-support)** - Get help and share ideas

---

# 

Source: https://docs.intuition.systems/guides/quickstart/intuition-kits


# Intuition Kits

Jump-start your development with our official Intuition kits and resources. These pre-configured templates and official tools provide everything you need to build Intuition-powered applications.

## Official Kits

### Core Development Tools

| Resource | Description | Primary Use |
|----------|-------------|-------------|
| **[intuition-ts](https://github.com/0xIntuition/intuition-ts)** | TypeScript SDK and tools | Main SDK for application development |
| **[intuition-contracts-v2](https://github.com/0xIntuition/intuition-contracts-v2)** | Smart contracts and protocol implementation | Core protocol and contract development |
| **[intuition-rs](https://github.com/0xIntuition/intuition-rs)** | Rust implementation | High-performance applications and services |

### Integration Tools

| Resource | Description | Primary Use |
|----------|-------------|-------------|
| **[intuition-mcp-server](https://github.com/0xIntuition/intuition-mcp-server)** | MCP server implementation | AI integration and model context protocol |

### Documentation & Ecosystem

| Resource | Description |
|----------|-------------|
| **[intuition-docs](https://github.com/0xIntuition/intuition-docs)** | Documentation and guides |

## Getting Started with Official Resources

### TypeScript SDK (intuition-ts)
The official TypeScript SDK provides the core functionality for interacting with the Intuition protocol:

```bash
# Install the SDK
npm install @0xintuition/sdk

# Basic usage

const config = {
  walletClient,
  publicClient,
  ethMultiVaultAddress
}

const result = await createAtomFromString(config, 'Hello World')
```

### Smart Contracts (intuition-contracts-v2)
The protocol implementation includes all necessary smart contracts:

```bash
# Clone the contracts repository
git clone https://github.com/0xIntuition/intuition-contracts-v2.git
cd intuition-contracts-v2

# Install dependencies
npm install

# Compile contracts
npm run compile
```

## Community Kits

### Coming Soon

Community-built kits and templates will be available here soon. We're working on creating a platform for the Intuition community to share their starter kits, templates, and specialized solutions.

Stay tuned for:
- Community-contributed starter kits
- Industry-specific templates
- Specialized use case solutions
- Community showcase and reviews

## Development Workflow

1. **Choose your starting point**: SDK, contracts, or ecosystem tools
2. **Set up your environment**: Configure wallet connections and network settings
3. **Build your application**: Use the SDK to create atoms, triples, and relationships
4. **Test and deploy**: Use the provided testing frameworks and deployment scripts

## Next Steps

- Learn about [Smart Contracts](/docs/developer-tools/contracts) for advanced features
- Check out the [GraphQL API](/docs/developer-tools/graphql-api) for data integration
- Explore the [SDK Guide](/docs/developer-tools/sdks) for application development

Start building with the official Intuition resources and join the community!

---

# 

Source: https://docs.intuition.systems/guides/resources/community-and-support


# Community & Support

Connect with the Intuition community, get help, and stay updated with the latest developments.

## Official Channels

Follow us on X for real-time updates, announcements, and community highlights.

Join our Discord community for discussions, support, and real-time collaboration.

Watch video recordings, tutorials, and community content on our YouTube channel.

Read our latest articles, insights, and technical deep-dives on Medium.

## Support Channels

Get general support and assistance for questions about Intuition.

Visit our official website for the latest updates, information, and resources.

## Feedback & Improvement

Contribute to our open-source projects, report issues, and suggest improvements.

Share your feedback, suggestions, and ideas to help improve Intuition.


---

# 

Source: https://docs.intuition.systems/guides/resources/faq


# FAQ

This page is organized into expandable sections for easy navigation. Click on any section below to explore the questions within that category.

## Getting Started

### What is Intuition?

Intuition is a decentralized protocol that enables the creation of trustful interactions through atomic primitives. It provides a foundation for building decentralized applications that can establish and maintain trust between parties without centralized intermediaries.

The protocol uses atomic primitives (atoms, triples, signals, and bonding curves) to create trustful interactions. These primitives can be combined to build complex decentralized applications that maintain trust through cryptographic proofs and economic incentives.

### How do I get started with Intuition?

**Step 1: Read the Documentation**  
Start with the [Introduction](/docs/introduction) and [Overview](/docs/introduction/overview) guides to understand the core concepts.

**Step 2: Connect to Testnet**  
Visit the [Intuition Hub](/docs/hub) to access the testnet and get your development environment set up.

**Step 3: Set up Development Environment**  
Install the necessary SDKs and tools for your preferred programming language.

**Step 4: Build Your First App**  
Follow the tutorials to create a simple application using Intuition primitives.

**Step 5: Join the Community**  
Connect with other developers and get support through our community channels.

### What are the main components of Intuition?

**Atoms**: The basic units of trust and reputation - unique identifiers for any entity (people, concepts, products)

**Triples**: Relationships between atoms that encode trust - structured as Subject â†’ Predicate â†’ Object

**Signals**: Mechanisms for updating trust relationships - actions that express intent, belief, or support

**Bonding Curves**: Economic models for token pricing and liquidity - automated market making for application tokens

## Development & Integration

### What programming languages are supported?

Intuition supports multiple programming languages through various SDKs:

- **JavaScript/TypeScript**: Official SDK with full feature support
- **Python**: Python SDK for backend development
- **Rust**: Low-level SDK for performance-critical applications
- **Go**: Go SDK for server-side applications

### How do I connect to the Intuition testnet?

**Step 1: Access the Hub**  
Visit the [Intuition Hub](/docs/hub) at [intuition-testnet.hub.caldera.xyz](https://intuition-testnet.hub.caldera.xyz/) for centralized access to all Intuition L3 network services.

**Step 2: Configure Your Wallet**  
Add the Intuition testnet to your wallet using the network details provided in the hub dashboard. The hub will display the current Chain ID and RPC URL.

**Step 3: Get Test Tokens**  
Use the built-in faucet available in the hub to obtain test tokens for development and testing.

**Step 4: Explore Services**  
Access the [Bridge](/docs/hub/bridge) for cross-chain transfers, [Explorer](/docs/hub/explorer) for blockchain exploration, and monitor network status through the status page.

### How do I integrate Intuition into my existing app?

**Step 1: Install SDK**  
Add the appropriate Intuition SDK to your project using your package manager.

**Step 2: Configure Connection**  
Set up connection to the Intuition testnet first using the network details from the [Hub](/docs/hub).

**Step 3: Implement Primitives**  
Use atoms, triples, signals, and bonding curves in your application logic.

**Step 4: Test Integration**  
Thoroughly test your integration on testnet before production deployment.

### How do I deploy an application?

**Step 1: Develop Your App**  
Build your application using Intuition primitives and follow best practices.

**Step 2: Test on Testnet**  
Use the [Intuition testnet](/docs/hub) to thoroughly test your application before mainnet deployment. Access all testnet services through the hub.

**Step 3: Deploy Contracts**  
Deploy your smart contracts to the network using the appropriate deployment tools. Start with testnet deployment first.

**Step 4: Launch Application**  
Make your application available to users and monitor its performance using the network monitoring tools.

### What are the best practices for building with Intuition?

**Start Simple**: Begin with basic primitives before building complex systems to understand the fundamentals.

**Test Extensively**: Use the [Intuition testnet](/docs/hub) for all development and testing to avoid costly mistakes. Access the full testing infrastructure through the hub.

**Follow Security Guidelines**: Implement proper security measures and follow established patterns. Review our [security audits](/docs/resources/audits) for best practices.

**Document Your Code**: Maintain clear documentation for your applications to help other developers.

**Monitor Applications**: Use the network monitoring tools to track your application's performance and catch issues early.

## Economics & Rewards

### How does the token economics work?

Intuition uses a dual-token system:

**INTUITION**: The main network token used for staking, governance, and network security.

**Application Tokens**: Specific to individual applications for their economic models and bonding curves.

The system provides automated market making and liquidity for application tokens, enabling dynamic pricing and efficient token distribution through bonding curves.

### How can I earn rewards?

**Staking**: Stake INTUITION tokens to earn rewards and participate in network security.

**Running Nodes**: Operate network nodes to earn block rewards and contribute to decentralization.

**Building Applications**: Create successful applications that generate fees and provide value to users.

**Contributing**: Participate in governance and development to help shape the protocol's future.

### What are bonding curves?

Bonding curves are mathematical functions that determine token pricing based on supply and demand. They provide:

- **Automated Market Making**: Continuous liquidity without traditional market makers
- **Dynamic Pricing**: Token prices that automatically adjust based on supply and demand
- **Efficient Distribution**: Fair token distribution through mathematical models
- **Liquidity Provision**: Built-in liquidity for application tokens

## Troubleshooting & Support

### How do I handle errors and edge cases?

**Implement Error Handling**: Add comprehensive error handling to your applications to gracefully handle failures.

**Use Fallback Mechanisms**: Implement fallbacks for critical operations to ensure reliability.

**Monitor Applications**: Set up monitoring and alerting for your applications to catch issues early.

**Plan for Upgrades**: Design your applications to be upgradeable as the protocol evolves.

### What if I can't connect to the testnet?

If you're having trouble connecting to the Intuition testnet, try these troubleshooting steps:

**Check Network Configuration**  
Verify that your wallet is configured with the correct network details from the [Hub dashboard](/docs/hub). The Chain ID and RPC URL should match exactly.

**Check Network Status**  
Visit the network status page to see if there are any ongoing issues with the testnet services.

**Clear Wallet Cache**  
Try clearing your wallet's cache or switching to a different RPC endpoint if multiple are available in the hub.

**Check Firewall/VPN**  
Ensure your firewall or VPN isn't blocking connections to the testnet endpoints.

### What if my transaction fails?

If your transaction fails, check your wallet to confirm whether your tokens have been returned. In most cases, failed transactions automatically result in the tokens being returned to your wallet.

Common causes of transaction failures:

- **Insufficient Gas**: Ensure you have enough gas for the transaction
- **Network Congestion**: Try again during less busy periods
- **Incorrect Parameters**: Double-check all transaction parameters before signing
- **Network Issues**: Check the Hub for any ongoing L3 network problems

### How do I get help and support?

**Community Support**: Join our [Discord](https://discord.com/invite/0xintuition) for real-time help from the community.

**Documentation**: Check our comprehensive [documentation](/docs) for detailed guides and tutorials.

**GitHub**: Report issues and contribute to the project on [GitHub](https://github.com/0xintuition).

**Email Support**: Contact us directly at [support@intuition.systems](mailto:support@intuition.systems) for technical assistance.

## Use Cases & Contributing

### What are the main use cases for Intuition?

**Knowledge Curation**: Build applications that help users discover and verify information through community consensus.

**Social Platforms**: Create decentralized social networks with built-in reputation and trust systems.

**Trust & Reputation**: Develop verifiable reputation systems that work across platforms and applications.

**Verification & QA**: Use collective intelligence to verify and validate any type of information or claim.

**Prediction Markets**: Build prediction markets with built-in verification and community consensus.

**Business & Professional Platforms**: Create platforms that verify professional credentials and facilitate trusted business relationships.

### How do I contribute to the Intuition ecosystem?

**Develop Applications**: Build applications that leverage Intuition's primitives and contribute to the ecosystem.

**Improve Documentation**: Help improve our documentation by suggesting edits or contributing new guides.

**Participate in Governance**: Stake tokens and participate in protocol governance decisions.

**Report Issues**: Help improve the protocol by reporting bugs and suggesting improvements.

**Community Building**: Help grow the community by answering questions and mentoring new developers.

## Need More Help?

We're here to help! Reach out to our community or support team for assistance.
Join Community

Contact Support


---

# 

Source: https://docs.intuition.systems/guides/resources


# Resources

Essential resources for working with Intuition, including key terminology, frequently asked questions, community support, utilities, and audit reports.

## What's Inside

Our resources provide comprehensive support for developers and users working with Intuition:

Master the essential terminology and concepts that form the foundation of the Intuition ecosystem. Understanding these terms is crucial for working effectively with Intuition.

Find answers to frequently asked questions about Intuition. From basic concepts to advanced implementation details, get quick answers to common questions.

Monitor real-time network status, uptime statistics, and service availability. Stay informed about maintenance windows and incident notifications.

Connect with the Intuition community and get help when you need it. Join discussions, get support, and collaborate with other developers.

Useful tools and utilities for working with Intuition. Discover helpful resources, tools, and scripts to enhance your development workflow.

Security audits and best practices for Intuition. Review audit reports and learn about security considerations for building on Intuition.


---

# 

Source: https://docs.intuition.systems/guides/resources/key-terms


# Key Terms

This page defines the essential terminology and concepts you need to understand the Intuition protocol. Terms are organized by category to help you quickly find what you're looking for.

## Quick Navigation

This page is organized into expandable sections for easy navigation. Click on any section below to explore the terms within that category.

## Core Primitives

### **Atoms**

**Atoms** are the fundamental building blocks of the Intuition knowledge graph. Each atom represents a unique entity or concept and points to arbitrary data via a URI.

**Key Characteristics:**
- **Universal Identifiers**: Each atom has a unique identifier across the entire system
- **URI References**: Atoms point to any arbitrary URI (web pages, IPFS hashes, etc.)
- **Economic Units**: Atoms can have economic value through bonding curves
- **Composable**: Atoms can be combined to create more complex structures

**Examples:**
- A person's profile (points to their social media or personal website)
- A smart contract address (points to the contract's metadata)
- A piece of content (points to the actual content file)
- An organization (points to their official website)

### **Triples**

**Triples** represent relationships between atoms, forming the edges of the knowledge graph. Each triple consists of three atoms: a subject, predicate, and object.

**Structure:**
```
Subject â†’ Predicate â†’ Object
```

**Key Characteristics:**
- **Semantic Relationships**: Express meaningful connections between entities
- **Economic Value**: Triples can have economic value through bonding curves
- **Verifiable**: All relationships are cryptographically verifiable
- **Composable**: Triples can be combined to create complex knowledge structures

**Examples:**
- **Subject**: Alice (atom)
- **Predicate**: "works for" (atom)
- **Object**: Intuition Systems (atom)

This creates the statement: "Alice works for Intuition Systems"

### **Signals**

**Signals** represent user attestations or endorsements of atoms and triples. They indicate the strength of belief or support for a particular piece of information.

**Key Characteristics:**
- **Economic Weight**: Signals have economic value and can be traded
- **Subjective**: Represent personal beliefs and opinions
- **Aggregatable**: Multiple signals can be combined to show collective sentiment
- **Time-Bound**: Signals can change over time as opinions evolve

**Types of Signals:**
- **Positive Signals**: Endorsements or agreements
- **Negative Signals**: Disagreements or refutations
- **Neutral Signals**: Acknowledgment without taking a position

## Economic Components

### **Bonding Curves**

**Bonding curves** are mathematical functions that determine the price of shares in atoms and triples based on supply and demand. They create economic incentives for information quality.

**Key Functions:**
- **Price Discovery**: Automatically determine fair market value
- **Incentive Alignment**: Reward early adopters of valuable information
- **Liquidity**: Provide continuous trading opportunities
- **Anti-Speculation**: Prevent manipulation through mathematical constraints

**Curve Types:**
- **Pro-Rata Curves**: Linear pricing for stable assets
- **Bonding Curves**: Dynamic pricing that rewards early adopters
- **Custom Curves**: Specialized functions for specific use cases

### **Vaults**

**Vaults** are smart contracts that hold the economic value associated with atoms and triples. They manage deposits, redemptions, and share distribution.

**Key Functions:**
- **Asset Management**: Safely store and manage user deposits
- **Share Distribution**: Mint and burn shares based on economic activity
- **Fee Collection**: Collect small fees to maintain the system
- **Liquidity Provision**: Enable users to enter and exit positions

**Vault Types:**
- **Pro-Rata Vaults**: Traditional vaults with stable pricing
- **Bonding Curve Vaults**: Dynamic vaults with variable pricing
- **Multi-Curve Vaults**: Vaults supporting multiple pricing models

### **Terms**

**Terms** are the conceptual representations of atoms and triples that contain multiple vaults. They represent the underlying semantic meaning regardless of economic implementation.

**Key Characteristics:**
- **Semantic Identity**: Maintains the core meaning across different vaults
- **Economic Flexibility**: Can have multiple vaults with different curves
- **Market Cap Aggregation**: Combines value across all associated vaults
- **Universal Reference**: Provides a stable identifier for the concept

## Network Components

### **Trust Protocol**

The **Trust Protocol** is the foundational mechanism that enables trustful interactions through cryptoeconomic incentives. It rewards users for contributing valuable information.

**Core Principles:**
- **Economic Incentives**: Users are rewarded for valuable contributions
- **Quality Signals**: Economic activity indicates information quality
- **Decentralized Curation**: No central authority controls information
- **Transparent Rules**: All mechanisms are open and verifiable

### **Knowledge Graph**

The **Knowledge Graph** is the collective network of atoms, triples, and signals that represents humanity's shared knowledge. It grows organically through user contributions.

**Key Features:**
- **Permissionless**: Anyone can contribute information
- **Verifiable**: All contributions are cryptographically verifiable
- **Composable**: Information can be combined and reused
- **Economic**: Valuable information is economically rewarded

### **Attestations**

**Attestations** are user statements about atoms and triples that contribute to the collective knowledge. They can be positive, negative, or neutral.

**Types of Attestations:**
- **Factual Claims**: Statements about objective reality
- **Opinions**: Subjective beliefs and preferences
- **Endorsements**: Support for existing information
- **Refutations**: Disagreements with existing information

## Technical Components

### **GraphQL API**

The **GraphQL API** provides a unified interface for querying and interacting with the Intuition knowledge graph. It enables efficient data retrieval and real-time updates.

**Key Features:**
- **Real-Time Queries**: Get live data from the knowledge graph
- **Flexible Schema**: Query exactly the data you need
- **Subscription Support**: Receive updates as data changes
- **Batch Operations**: Efficiently process multiple requests

### **SDKs**

**Software Development Kits (SDKs)** provide pre-built tools and libraries for integrating with the Intuition protocol. They simplify common development tasks.

**Available SDKs:**
- **JavaScript/TypeScript SDK**: For web applications
- **React Components**: Pre-built UI components
- **GraphQL Client**: Optimized for Intuition's GraphQL API
- **Smart Contract Interfaces**: For direct blockchain interaction

### **Smart Contracts**

**Smart contracts** are the on-chain components that handle the economic and governance aspects of the Intuition protocol. They ensure transparency and immutability.

**Core Contracts:**
- **EthMultiVault**: Manages deposits, redemptions, and share distribution
- **AtomWallet**: Handles atom and triple creation
- **BondingCurveRegistry**: Manages different curve implementations
- **TrustBonding**: Implements trust-based economic mechanisms

## User Roles

### **Attestors**

**Attestors** are users who contribute information to the knowledge graph by creating atoms, triples, and signals. They are rewarded for valuable contributions.

**Responsibilities:**
- **Information Creation**: Add new atoms and triples to the graph
- **Quality Assurance**: Provide signals to indicate information quality
- **Community Building**: Participate in knowledge curation
- **Economic Participation**: Engage with bonding curves and vaults

### **Curators**

**Curators** are users who specialize in organizing and validating information within the knowledge graph. They help maintain quality and coherence.

**Activities:**
- **Signal Provision**: Provide economic signals for information quality
- **Relationship Mapping**: Create meaningful triples between atoms
- **Quality Assessment**: Evaluate and endorse valuable information
- **Community Leadership**: Guide discussions and resolve disputes

### **Developers**

**Developers** build applications and tools that interact with the Intuition protocol. They create the interfaces and experiences that make the knowledge graph accessible.

**Development Areas:**
- **Frontend Applications**: User interfaces for interacting with the graph
- **Data Analytics**: Tools for analyzing knowledge graph data
- **Integration Services**: APIs and services that connect to Intuition
- **Mobile Applications**: Native mobile experiences

## Economic Terms

### **Market Cap**

**Market cap** represents the total theoretical value of all shares in a term (atom or triple). It is calculated as the product of total shares and current share price.

**Calculation:**
```
Market Cap = Total Shares Ã— Current Share Price
```

**Significance:**
- **Value Indicator**: Shows the perceived value of information
- **Comparison Metric**: Allows comparison between different terms
- **Investment Guide**: Helps users make informed decisions
- **Quality Signal**: Higher market caps often indicate higher quality

### **Share Price**

**Share price** is the current cost to purchase one share of a term. It is determined by the bonding curve function based on supply and demand.

**Factors Affecting Price:**
- **Supply**: Number of shares currently in circulation
- **Demand**: User interest and willingness to pay
- **Curve Function**: Mathematical relationship between supply and price
- **Market Activity**: Recent trading volume and patterns

### **Liquidity**

**Liquidity** refers to the ease with which shares can be bought or sold without significantly affecting the price. High liquidity enables efficient trading.

**Liquidity Factors:**
- **Trading Volume**: Amount of shares traded regularly
- **Market Depth**: Number of buy and sell orders
- **Price Stability**: How much price changes with large trades
- **Accessibility**: How easy it is for users to participate

## Governance Terms

### **Proposals**

**Proposals** are suggested changes to the Intuition protocol that are voted on by the community. They can include parameter changes, new features, or governance updates.

**Proposal Types:**
- **Parameter Changes**: Adjusting bonding curve parameters
- **Feature Additions**: Adding new functionality to the protocol
- **Governance Updates**: Changing how decisions are made
- **Emergency Actions**: Responding to critical issues

### **Voting**

**Voting** is the process by which the community makes decisions about the protocol. Votes are weighted by economic stake and participation.

**Voting Mechanisms:**
- **Token Weighted**: Votes are proportional to token holdings
- **Time Locked**: Some proposals require time delays
- **Multi-Sig**: Critical decisions require multiple approvals
- **Emergency Powers**: Special procedures for urgent situations

---

> **Ready to dive deeper?** Explore our [Architecture Guide](/guides/developer-tools/deep-dive/architecture) to understand how these components work together, or check out our [Quick Start Guide](/guides/quickstart) to begin building with Intuition. 

---

# 

Source: https://docs.intuition.systems/guides/use-cases


![Use Cases](/img/use-cases.png)

This article outlines use cases that take advantage of Intuition's unique knowledge graph and claim infrastructure. There are many more ways to use Intuition (and we would love to see what you come up with!), but here are some ideas to get you started.

## List Curation & Ranking Systems

Intuition can be used to create permissionless, community-curated ranked lists and registries. Anyone can create a list that groups together identities with a common claim about them (such as sharing a common tag, use case, purpose, etc). The list can then be curated by the original uploader and anyone else on the platform by adding additional identities or supporting/opposing each item with a financial stake to change itâ€™s ranking. Users can filter and sort results from that list to find what matters to them. They can see the global list of everything added by anyone, just their own contributions, or items vetted by people they follow or trust.

- Web3 Ecosystem: Curate trusted smart contracts, addresses, DeFi protocols, memecoins, NFT communities, and Web3 games based on reputation formed by on-chain metadata and user attestations
- AI resources: Find and orchestrate trusted AI agents based on rich metadata and on-chain reputation, know the best models based on community feedback, and train AI with validated data sources and efficiently structured knowledge
- Entertainment and media: Rank top and emerging music, movies, news sources, podcasts, sports teams, and more based on staked TRUST â€œsupportâ€ positions and attestations from users you follow who share your taste
- Data and Research: Find the most reliable data sources and reports based on peer review attestations and supporting positions from trusted colleagues
- Consumer Products: Find and help rank top-rated consumer products, applications, and more
- Product improvements: Have your community share their top feature requests and bugs to fix so you can prioritize which to tackle first
- Travel: Uncover popular travel destinations through collective recommendations

## Verification and Fraud Protection

Intuition helps trusted experts flag potentially dangerous websites, smart contracts, products, and more using structure claims to help everyday consumers stay safe.

- Decentralized Information Validation: Engage a distributed community to verify and endorse the accuracy and authenticity of any data (e.g. smart contracts, information, packaged good supply chains, images, news, etc)
- Fraud Detection and Alerts: Engage a worldwide team of incentivized auditors and moderators to report potentially dangerous or fraudulent activities, including crypto scams and malicious AI agents, and alert users when they are about to engage with a threat on the Web.
- Curator & Auditor Recognition: Rank individualsâ€”whether they're auditing contracts or curating newsâ€”based on their proficiency, accuracy, and community credibility. This ensures a transparent trajectory in both contract auditing and news curation.

## Community-Owned Social Platforms

Intuition creates on-chain decentralized identities for people and concepts, and allows any account to make verifiable claims about themselves and others. These primitives can form the basis of powerful social networks, driven by publicly visible and searchable graphs of verified connections and attestations.

- Portable On-Chain Identity: Each person on the social network gets a self-sovereign identity, allowing them to own their verifiable data (claims by and about them) and make it portable to any other system, instead of being locked into keeping their data with a single platform.
- Advanced Signaling and Verification: Transform traditional up-vote/down-vote and/or likes/dislikes into attestations, offering richer feedback and community insights for debates, conversations, and more.
- Member Credibility: Promote trust between distributed community members by highlighting verifiable achievements and certifications, providing community reputation attestations and scores, and more.

## Incentivized Ratings and Referrals

Using claims, Intuition can provide on-chain ratings and referrals for media, software, travel destinations, and more. Tastemakers can earn money by being early to place support or oppose financial positions to rate promising items they know their communities will find relevant, capturing fees when subsequent reviewers follow suite.

- Attestation-Backed Ratings: Transition from simplistic star ratings to attestations, ensuring each review reflects a more comprehensive and verified experience
- Transparent Reviewer Profiles: Utilize attestations to validate reviewer authenticity, experience, and expertise, giving more weight to trusted community members' feedback
- Community-Driven Trustworthiness: Allow community members to vouch for or against reviews, enhancing the credibility of feedback and reducing the impact of fraudulent reviews.
- Simple Referrals: Businesses can request referrals for their offerings from tastemakers, rewarding those tastemakers financially when others catch on, place their own support position, and make the offering go viral.
- Review Aggregation & Insights: Harness the power of structured attestation data to generate summary insights from reviews, helping customers make informed decisions faster and helping businesses understand their strengths and areas of improvement.

## Q&A Platforms

Question and answer platforms can yield results from structured knowledge sharing, support/oppose positions on claims, and in-depth identity and reputation for each participant.

- Claiming Expertise: Users self-attest areas of knowledge, setting the stage for their contributions and peer review.
- Community Attestations: Peer validation of answers allows for real-time quality & sentiment checks.
- Verification: Answer validation is reinforced by the wisdom of the crowd, balancing answer credibility.
- Reputation Building: Continuous positive attestations lead to a trustworthy reputation score, distinguishing genuine experts from the crowd.

## Reputation scores

Intuition facilitates both financial and social signals about identities and claims to help people construct their own sense of reputation for things they encounter. From these primitives, third-party developers can construct reputation scores that make this contextual trust easy to interpret.

- Trustworthiness Index: Evaluate entities based on their past track record and overarching  conduct within different contexts.
- Platform Credibility: Prioritize platforms known for specific things - such as undercollateralized lending - spotlighting those with a track record for precise credit evaluations.
- Credit Scoring: Harness the transparency of blockchain for decentralized credit scores, presenting a holistic and immutable snapshot of an individual's or entity's lending history.
- Lending Confidence: Empower lenders to confidently engage in undercollateralized loans, underpinned by clear and transparent Web3 credit reputation metrics.

## Oracles

Decentralized applications can use on-chain claims made by trusted accounts managed by people or secure bots (or a combination of these entities and their collective opinions) in Intuition to trigger other on-chain events.

- Consensus Result Extraction: Derive a data beacon or collective answer based on the weight and credibility of aggregated attestations, and use it to provide triggers for smart contract logic.
- Censorship Resistance: Define trust so that any entity that fits the criteria can support dApps with reliable information to guide actions, free of censorship.

## Business, Employment & Consulting Platforms

Companies and consultancies, as well as the people who work for them, can use decentralized identifiers and claims made by those that have done business with them to determine whether their potential collaborators are trustworthy and fit for the task at hand.

- Professional Credibility: Evaluate the authenticity of individuals, organizations, and services based on proven credentials.
- Expertise Showcase: Verify the skills, experiences, and specializations of consultants to match with appropriate projects or clients.
- Credential-Based Products: Incorporate platforms enhanced with reputation systems to assess credibility and reliability in the consulting domain.
- Collaborative Experiences: Attest to the quality and outcome of consulting projects and share insights from fruitful partnerships.
- Consultation Metrics: Utilize advanced tools and analytics to measure the impact and effectiveness of consulting services offered.
- Transparent Feedback Loop: Allow clients to provide feedback on consulting services, ensuring continual improvement and trust-building in the community.

## Verified Voting

Verified community members can create proposals as identities, then allow other community members to make claims about those proposals with evidence, support or oppose the proposals, or rank the proposals in a list to signal what the community should handle next.

- Identity Assurance: Implement mechanisms to ensure that each vote is tied to a verified identity, eliminating duplicate votes and ensuring transparency.
- Hackathon Judging: Accurately capture and reflect community votes to determine hackathon winners and associated projects, fostering a fair competitive environment.
- DAO Proposal Voting: Promote permissionless executions grounded in community consensus and sentiment, enabling decentralized decisions with integrity.
- Vote Attestation: Allow members to vouch for or challenge voting results, adding an additional layer of community-backed verification to the process.
- Reputation-Based Voting Power: Adjust the weight of votes based on the track record and credibility of members, ensuring experienced voices have a significant say.

## Trading Knowledge

Intuition can help surface knowledgable market voices, and even gather intelligence on bullish opportunities through curated lists of assets with support or oppose positions to signal their attractiveness as an investment.

- Evaluate and ascertain the credibility of traders or investors based on historical decisions, profitability, and ethical behavior.
- Assess and rank trading/investment platforms using community-driven reviews, transaction success rates, and security protocols.
- Determine the trustworthiness of diverse investment assets through community ratings, feedback, and historical performance benchmarks.

## Verifiable Predictions, Claims & Forecasting

Intuition can help people signal what they believe will happen next or be advantageous in the future, making early verifiable claims about events or opportunities and putting financial positions behind them to communicate their certainty. These claims and commitments can be used by others who need to decide whatâ€™s most likely to happen in the future, like a perpetual, non-resolving prediction market.

- Know Your Futurist: Elevate trusted voices whose foresight consistently aligns with events and who posses domain knowledge, emphasizing their expertise within the community.
- Provable Track Records: Assess past predictions in the form of claims from thought leaders in Intuition, including any financial stake they placed on the prediction, to determine their likelihood of correctly predicting future events.

---

